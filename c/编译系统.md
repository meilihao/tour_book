# 编译系统(compilation system)

其包括:预处理(cpp,),编译器(ccl),汇编器(as),连接器(ld).

## 编译流程

编译C源码有四个步骤：预处理---> 编译 ---> 汇编 ---> 链接.

演示例子(hello.c):
```
#include <stdio.h>

int main()  
{  
     printf("Hello World\n");
     return 0;
}
```

1. 预处理: 根据以字符`#`开头的命令来处理源代码,结果是文本.
```
gcc -E hello.c -o hello.i
```

预处理阶段主要处理`#include`,`#define`,`#ifdef`，`#endif`等命令，
比如把`#include`包含进来的头文件插入到`#include`所在的位置，
把源程序中使用到的由`#define`定义的宏用实际的字符串代替.

2. 编译: 检查代码规范和语法,无误后将hello.i翻译成汇编代码(文本).
```
gcc -S hello.i -o hello.s
```

3. 汇编: 将汇编代码翻译成机器语言,生成可重定位目标程序(二进制).
```
gcc -c hello.s -o hello.o
```

4. 链接: 将汇编生成的可重定位目标程序和用到的库文件链接起来，生成可执行文件.
```
gcc hello.o -o hello
```

链接涉及到函数库.

在例子中并没有定义“printf”的函数实现，且在预编译中包含进去的“stdio.h”中也只有该函数的声明，而没有定义函数的实现，那么“printf”函数是在哪里实现的呢？
答案是：系统把这些函数实现都做到了名为libc.so.6的库文件中去了，在没有特别指定时，gcc会到系统默认的搜索路径“/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就等于实现了函数“printf”，而这也就是链接的作用.

**合并流程**为:
```
gcc hello.c -o hello
```

## FAQ
### 内联(inline)函数
函数会在它被调用的位置上展开, 以消除函数调用和返回所带来的开销(寄存器保存和恢复), 同时编译器会把函数代码和内联展开代码放在一起进行优化, 因此有了进一步优化的可能.

缺点: 占用更多内存和占用更多的指令缓存. kerne通常把对时间要求高, 本身长度短的函数定义为内联函数. 如何函数较大, 会被反复调用, 且没有特别的时间限制, 此时不建议做成内联函数.

> 内联函数必须在使用前就定义好, 否则无法展开.

> linux kernel中, 为了类型安全和易读性, 优先使用内联函数而不是复杂的宏.

### 内联汇编
通过`asm()`指令来支持.

linux kernel混合使用了c和汇编. 在偏近arch底层和对执行时间要求严格的地方会使用汇编.

### likely()/unlikely()
gcc对fi条件选择语句的优化.

场景:
-  likely  : 经常触发
- unlikely : 绝少触发

> 场景用错会导致性能下降.