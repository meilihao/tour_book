# source
k8s 1.20.5

## 代码生成
参考:
- [使用 code generator 生成 kubernetes 的 crd 代码](https://www.g5niusx.com/2020/03/kubernetes-1.html)
- [code-generator使用](https://tangxusc.github.io/2019/05/code-generator%E4%BD%BF%E7%94%A8/)

更新code gen方法: `hack/update-codegen.sh`

### Tag
代码生成器通过Tags（标签）来识别一个包是否需要生成代码及确定生成代码的方式，Kubernetes提供的Tags可以分为如下两种:
- 全局Tags ：定义在每个包的doc.go文件中，对整个包中的类型自动生成代码

    比如`pkg/apis/node/doc.go`:
    ```go
    // +k8s:deepcopy-gen=package
    // +groupName=node.k8s.io
    ```

    全局Tags告诉deepcopy-gen代码生成器为该包中的每个类型自动生成DeepCopy函数。其中的//+groupName定义了资源组名称，资源组名称一般使用域名形式命名。
- 局部Tags ：定义在Go语言的类型声明上方，只对指定的类型自动生成代码

    比如`pkg/apis/core/types.go`：
    ```go
    // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
    ```

    局部Tags定义在Pod资源类型的上方，它定义了该类型有一个代码生成器deepcopy-gen: deepcopy-gen代码生成器为这个资源类型自动生成DeepCopy函数.

    > 关于Tags的位置，局部Tags一般定义在类型声明的上方，但如果该类型有注释信息，则局部Tags的定义需要与类型声明的注释信息之间至少有一个空行. 这是因为Kubernetes的API文档生成器会根据类型声明的注释信息（comment-block）生成文档, 为了避免Tags信息出现在文档中，故将Tags定义在注释的上方并空一行.

Tags的定义规则通常为//+tag-name或//+tag-name=value，它们被定义在注释中.

### 代码生成器
顶层Makefile中定义了generated_files命令，该命令用于构建代码生成器. `make generated_files`生成的二进制工具会被输出到`_output/bin`. 它实际调用的是`hack/make-rules/build.sh`, 会根据传入的代码生成器的main入口文件路径，构建二进制文件.

- conversion-gen

    自动生成Convert函数的代码生成器，用于资源对象的版本转换函数.

    给定一个包的目录路径作为输入源，conversion-gen会遍历包中的所有类型，若类型为types.Struct且过滤掉了私有的Struct类型，则为该类型生成Convert函数，并为该类型同时生成RegisterConversions注册函数，这些函数可以为对象在内部和外部类型之间提供转换函数.

    conversion-gen的生成规则: `vendor/k8s.io/code-generator/cmd/conversion-gen/generators/conversion.go#(*genConversion) convertibleOnlyWithinPackage()`

    为整个包生成Convert相关函数时，其Tags形式如下：`// +k8s:conversion-gen=<peer-pkg>`, 其中的`<peer-pkg>`用于定义包的导入路径

    为整个包生成Convert相关函数且依赖其他包时，其Tags形式如下：`// +k8s:conversion-gen-external-types=<type-pkg>`, 其中的`<type-pkg>`用于定义其他包的路径.

    在排除某个属性后生成Convert相关函数时，其Tags形式如下：`// +k8s:conversion-gen=false`

    构建conversion-gen二进制文件，并执行conversion-gen代码生成器，为k8s.io/kubernetes/pkg/apis/abac/v1beta1包生成zz_generated.conversion.go代码文件:
    ```bash
    $ cd $GOPATH/src/k8s.io/kubernetes
    $ hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/conversion-gen
    $ ./hack/run-in-gopath.sh ./_output/bin/conversion-gen --v 1 --logtostderr -i k8s.io/kubernetes/pkg/apis/abac/v1beta1 --extra-peer-dirs k8s.io/kubernetes/pkg/apis/core,k8s.io/kubernetes/pkg/apis/core/v1,k8s.io/api/core/v1 -O zz_generated.conversion # run-in-gopath.sh不能省略
    ```

- deepcopy-gen

    自动生成DeepCopy函数的代码生成器，用于资源对象的深复制函数.

    给定一个包的目录路径作为输入源, deepcopy-gen会遍历包中的所有类型，若类型为types.Struct，则会为该类型生成深复制函数, 这些函数可以有效地执行每种类型的深复制操作, 避免性能开销.

    deepcopy-gen的生成规则: `vendor/k8s.io/gengo/examples/deepcopy-gen/generators/deepcopy.go#copyableType()`

    为整个包生成DeepCopy相关函数时，其Tags形式：`+k8s:deepcopy-gen=package`

    为单个类型生成DeepCopy相关函数时，其Tags形式：`+k8s:deepcopy-gen=true`

    为整个包生成DeepCopy相关函数时，可以忽略单个类型，其Tags形式：`+k8s:deepcopy-gen=false`

    有时在Kubernetes源码里会看到deepcopy-gen的Tags被定义成runtime.Object，这时deepcopy-gen会为该类型生成返回值为runtime.Obejct类型的DeepCopyObject函数, 原始代码(`pkg/apis/abac/types.go`)如下:
    ```go
    // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

    // Policy contains a single ABAC policy rule
    type Policy struct {
        metav1.TypeMeta

        // Spec describes the policy rule
        Spec PolicySpec
    }
    ```

    生成代码(`pkg/apis/abac/zz_generated.deepcopy.go`)如下:
    ```go
    // DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
    func (in *Policy) DeepCopyObject() runtime.Object {
        if c := in.DeepCopy(); c != nil {
            return c
        }
        return nil
    }
    ```

    构建deepcopy-gen二进制文件，并执行deepcopy-gen代码生成器，为`k8s.io/kubernetes/pkg/apis/abac/v1beta1`包生成`zz_generated.deepcopy.go`代码文件:
    ```bash
    $ cd $GOPATH/src/k8s.io/kubernetes
    $ hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/deepcopy-gen
    $ ./_output/bin/deepcopy-gen --v 1 --logtostderr -i k8s.io/kubernetes/pkg/apis/abac --bounding-dirs k8s.io/kubernetes -o $GOPATH/src -O zz_generated.deepcopy # `-i`从GOPATH查找package
    ```

    deepcopy-gen参数说明如下:
    - --v ：指定日志级别
    - --logtostderr ：日志输出到“标准错误输出”
    - -i，--input-dirs ：输入源，即.todo文件中的目录列表，以逗号分隔
    - --bounding-dirs ：依赖的包并为其生成深复制的类型
    - -O，--output-file-base ：输出文件的名字

- defaulter-gen

    自动生成Defaulter函数的代码生成器，用于资源对象的默认值函数.

    给定一个包的目录路径作为输入源，defaulter-gen会遍历包中的所有类型，若类型属性拥有特定类型（如TypeMeta、ListMeta、ObjectMeta），则为该类型[生成Defaulter函数](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/rbac/v1/zz_generated.defaults.go)，并为其生成RegisterDefaults注册函数.

    defaulter-gen的生成规则: `k8s.io/gengo/examples/defaulter-gen/generators/defaulter.go`

    为拥有TypeMeta属性的类型生成Defaulter相关函数时，其Tags形式如下：`// +k8s:defaulter-gen=TypeMeta`
    为拥有ListMeta属性的类型生成Defaulter相关函数时，其Tags形式如下：`// +k8s:defaulter-gen=ListMeta`
    为拥有ObjectMeta属性的类型生成Defaulter相关函数时，其Tags形式如下：`// +k8s:defaulter-gen=ObjectMeta`

    defaulter-gen的Tags都属于全局Tags，没有局部Tags. 其值可以为TypeMeta、ListMeta、ObjectMeta，最常用的是TypeMeta.有时在Kubernetes源码里会看到[defaulter-gen-input](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/storage/v1/doc.go)，这说明当前包会依赖于指定的路径包，代码示例如下：`// +k8s:defaulter-gen-input=../../../../vendor/k8s.io/api/storage/v1`.

    构建defaulter-gen二进制文件，并执行defaulter-gen代码生成器，为k8s.io/kubernetes/pkg/apis/rbac/v1包生成zz_generated.defaults.go代码文件:
    ```bash
    $ cd $GOPATH/src/k8s.io/kubernetes
    $ hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/defaulter-gen
    $ ./hack/run-in-gopath.sh ./_output/bin/defaulter-gen --v 1 --logtostderr -i k8s.io/kubernetes/pkg/apis/rbac/v1 --extra-peer-dirs k8s.io/kubernetes/pkg/apis/rbac/v1 -o $GOPATH/src -O zz_generated.defaults # run-in-gopath.sh不能省略
    ```

- go-bindata

    是一个第三方工具。它能够将静态资源文件嵌入Go语言中，例如在Web开发中将静态的HTML、JavaScript等静态资源文件嵌入Go语言代码文件中并提供一些操作方法. 给定一个静态资源目录路径作为输入源，go-bindata可以为其生成go文件.

    ```bash
    $ cd $GOPATH/src/k8s.io/kubernetes
    $ hack/make-rules/build.sh ./vendor/github.com/jteeuwen/go-bindata/go-bindata
    $ ./hack/run-in-gopath.sh hack/generate-bindata.sh
    ```

    generate-bindata.sh脚本重点执行如下代码:
    ```bash
    # 为translations静态资源目录生成pkg/kubectl/generated/bindata.go.tmp文件. translations目录存放的是与i18n（国际化）语言包相关的文件，在不修改内部代码的情况下支持不同语言及地区
    go-bindata -nometadata -nocompress -o "${BINDATA_OUTPUT}.tmp" -pkg generated \
    -ignore .jpg -ignore .png -ignore .md -ignore 'BUILD(\.bazel)?' \
    "translations/..."
    ```

- openapi-gen

    自动生成OpenAPI定义文件（OpenAPI Definition File）的代码生成器.

    给定一个包的目录路径作为输入源，openapi-gen会遍历包中的所有类型，若类型为types.Struct并忽略其他类型，则为types.Struct类型生成OpenAPI定义文件，该文件用于kube-apiserver服务上的OpenAPI规范的生成.

    openapi-gen的生成规则: `vendor/k8s.io/kube-openapi/pkg/generators/openapi.go#(openAPITypeWriter) generate()`

    为特定类型或包生成OpenAPI定义文件时，其Tags形式如下：`// +k8s:openapi-gen=true`

    排除为特定类型或包生成OpenAPI定义文件时，其Tags形式如下：`// +k8s:openapi-gen=false`

    构建openapi-gen二进制文件，并执行openapi-gen代码生成器，为k8s.io/kubernetes/vendor/k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1包生成zz_generated.openapi.go代码文件，该代码文件存放在k8s.io/kubernetes/pkg/generated/openapi目录下:
    ```bash
    $ cd $GOPATH/src/k8s.io/kubernetes
    $ hack/make-rules/build.sh ./vendor/k8s.io/code-generator/cmd/openapi-gen
    $ ./hack/run-in-gopath.sh ./_output/bin/openapi-gen --v 1 --logtostderr -i k8s.io/kubernetes/vendor/k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1 -p k8s.io/kubernetes/pkg/generated/openapi -O zz_generated.openapi2 -h vendor/k8s.io/code-generator/hack/boilerplate.go.txt -r _output/violattions.report  # run-in-gopath.sh不能省略
    ```

代码生成器生成代码的流程基本相同，以deepcopy-gen代码生成器为例，生成过程可分为如下3步:
1. 构建deepcopy-gen二进制文件
1. 生成.todo文件(在`.make/_output/bin/*.todo`)

    .todo文件相当于临时文件，用来存放被Tags标记过的包. 通过shell的grep命令可以将所有代码包中被Tags标记过的包目录记录在.todo文件中，这样可方便记录哪些包需要使用代码生成功能.

    ```bash
    // from Makefile.generated_files
    ALL_K8S_TAG_FILES := $(shell                             \
    find $(ALL_GO_DIRS) -maxdepth 1 -type f -name \*.go  \
        | xargs grep --color=never -l '^// *+k8s:'       \
    )


    DEEPCOPY_DIRS := $(shell                                             \
    grep --color=never -l '+k8s:deepcopy-gen=' $(ALL_K8S_TAG_FILES)  \
        | xargs -n1 dirname                                          \
        | LC_ALL=C sort -u                                           \
    )
    ```

    Makefile.generated_files中定义了ALL_K8S_TAG_FILES变量，其用于获取Kubernetes代码中被“/+k8s：”标签标记过的包；也定义了DEEPCOPY_DIRS变量，其用于从ALL_K8S_TAG_FILES中筛选出被`+k8s：deepcopy-gen`标签标记过的包. 最终将筛选出的包目录路径输出到.todo文件中.

1. 生成DeepCopy（深复制）相关函数


    ```bash
    // from Makefile.generated_files
    gen_deepcopy: $(DEEPCOPY_GEN) $(META_DIR)/$(DEEPCOPY_GEN).todo
    if [[ -s $(META_DIR)/$(DEEPCOPY_GEN).todo ]]; then                 \
        pkgs=$$(cat $(META_DIR)/$(DEEPCOPY_GEN).todo | paste -sd, -);  \
        if [[ "$(DBG_CODEGEN)" == 1 ]]; then                           \
            echo "DBG: running $(DEEPCOPY_GEN) for $$pkgs";            \
        fi;                                                            \
        ./hack/run-in-gopath.sh $(DEEPCOPY_GEN)                        \
            --v $(KUBE_VERBOSE)                                        \
            --logtostderr                                              \
            -i "$$pkgs"                                                \
            --bounding-dirs $(PRJ_SRC_PATH),"k8s.io/api"               \
            -O $(DEEPCOPY_BASENAME)                                    \
            "$$@";                                                     \
    fi                                                                 \
    ```

### gengo代码生成核心实现

Kubernetes的代码生成器都是在k8s.io/gengo包的基础上实现的. 代码生成器都会通过一个输入包路径（--input-dirs）参数，根据gengo的词法分析、抽象语法树等操作，最终生成代码并输出（--output-file-base）.

gengo代码目录结构说明如下:
- args ：代码生成器的通用flags参数.
- examples ：包含deepcopy-gen、defaulter-gen、import-boss、set-gen等代码生成器的生成逻辑.
- generator ：代码生成器通用接口Generator.
- namer ：命名管理，支持创建不同类型的名称. 例如，根据类型生成名称，定义type foo string，能够生成func FooPrinter（f*foo）{Print（string（*f））}.
- parser ：代码解析器，用来构造抽象语法树.
- types ：类型系统，用于数据类型的定义及类型检查算法的实现.

gengo的代码生成逻辑与编译器原理非常类似，大致可分为如下几个过程:
1. Gather The Info ：收集Go语言源码文件信息及内容

    gengo收集Go包信息可分为两步:
    1. 为生成的目标代码文件设置构建标签

        在[Default函数](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/args/args.go#L42)中定义了默认的GeneratedBuildTag字符串，在每次构建时，代码生成器会将GeneratedBuildTag作为构建标签打入生成的代码文件中. 每个代码生成器都会通过Packages函数执行该操作，以deepcopy-gen代码生成器为例: deepcopy-gen代码生成器中的[Packages函数](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/examples/deepcopy-gen/generators/deepcopy.go#L128)将GeneratedBuildTag字段进行拼接，每一个通过deepcopy-gen代码生成器生成的代码文件（如zz_generated.deepcopy.go），第1行总是构建标签, 最后生成代码的构建标签如下: `// +build !ignore_autogenerated`, 表示该文件是由代码生成器自动生成的，不需要人工干预或人工编辑该文件.


    2. 收集Go包信息并读取源码内容.

        代码生成器通过[--input-dirs参数](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/args/args.go#L131)指定传入的Go包路径，通过build.Import方法收集Go包的信息，build.Import支持多种模式，其中build.ImportComment用于解析import语句后的注释信息；build.FindOnly用于查找包所在的目录，不读取其中的源码内容。代码函数层级为`b.AddDir→[b.importPackage](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/parser/parse.go#L124)→[b.addDir](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/parser/parse.go#L295)`.

        通过build.Import方法获得Go包信息以后，就可以得到包下面的所有源码文件的路径了，将所有Go源码内容读入内存中，等待Lexer词法解析器的下一步处理.


1. Lexer/Parser ：通过Lexer词法分析器进行一系列词法分析 -> AST Generator ：生成抽象语法树 -> Type Checker ：对抽象语法树进行类型检查

    Kubernetes gengo是在Go语言标准库支持代码解析功能的基础上进行的功能封装.

    gengo的代码解析:

    首先，通过[token.NewFileSet](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/parser/parse.go#L107)实例化得到token.FileSet对象，该对象用于记录文件中的偏移量、类型、原始字面量及词法分析的数据结构和方法等.

    得到Tokens后，在[addFile](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/parser/parse.go#L180)函数中，使用parser.ParseFile解析器对Tokens数据进行处理，Parser解析器将传入两种标识，其中parser.DeclarationErrors表示报告声明错误，parser.ParseComments表示解析代码中的注释并将它们添加到抽象语法树中, 最终得到抽象语法树结构.

    得到抽象语法树结构后，就可以[对其进行类型检查](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/parser/parse.go#L418)了，通过Go语言标准库go/types下的Check方法进行检查，会对检查过程进行一些优化，使程序执行得更快.

    [gengo的类型系统（Type System）](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/types/types.go#L65)在Go语言本身的类型系统之上归类并添加了几种类型. gengo的类型系统在Go语言标准库go/types的基础上进行了封装.

    所有的类型都通过`vendor/k8s.io/gengo/parser/parse.go`的walkType方法进行识别. gengo类型系统中的Struct、Map、Pointer、Interface等，与Go语言提供的类型并无差别. gengo与Go语言不同的类型，例如Builtin、Alias、DeclarationOf、Unknown、Unsupported及Protobuf. 另外，Signature并非是一个类型，它依赖于Func函数类型，用来描述Func函数的接收参数信息和返回值信息等.

    1. Builtin（内置类型）
    Builtin将多种Base类型归类成一种类型，以下几种类型在gengo中统称为Builtin类型:
    - 内置字符串类型——string
    - 内置布尔类型——bool
    - 内置数字类型——int、float、complex64等

    2. Alias（别名类型）
    Alias类型是Go 1.9版本中支持的特性.

    ```go
    type T1 struct{}
    type T2 = T1
    ```

    在Go语言标准库的reflect（反射）包识别T2的原始类型时，会将它识别为Struct类型，而无法将它识别为Alias类型. 原因在于，Alias类型在运行时是不可见的.

    如何让Alias类型在运行时可被识别呢？答案是因为gengo依赖于go/types的Named类型，所以要让Alias类型在运行时可被识别，在声明时将TypeName对象绑定到Named类型即可.

    3. DeclarationOf（声明类型）
    
    DeclarationOf并不是严格意义上的类型，它表示声明过的函数、全局变量或常量，但并未被引用过.

    在pkg/apis/abac/v1beta1/register.go中，AddToScheme变量在声明后未被其他对象引用过，则可以认为它是DeclarationOf类型的.
    
    4. Unknown（未知类型）
    当对象匹配不到以上所有类型的时候，它就是Unknown类型的

    5.Unsupported（未支持类型）

    当对象属于Unknown类型时，则会设置该对象为Unsupported类型，并在其使用过程中报错

    6. Protobuf（Protobuf类型）

    由go-to-protobuf代码生成器单独处理的类型

 
1. Code Generation ：生成代码，将抽象语法树转换为机器代码

    编译器生成的代码一般是二进制代码，而Kubernetes的代码生成器生成的是Go语言代码. gengo的[Generator接口](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/generator/generator.go#L90)字段说明如下:

    - Name ：代码生成器的名称，返回值为生成的目标代码文件名的前缀，例如deepcopy-gen代码生成器的目标代码文件名的前缀为zz_generated.deepcopy
    - Filter ：类型过滤器，过滤掉不符合当前代码生成器所需的类型
    - Namers ：命名管理器，支持创建不同类型的名称. 例如，根据类型生成名称
    - Init ：代码生成器生成代码之前的初始化操作
    - Finalize ：代码生成器生成代码之后的收尾操作
    - PackageVars ：生成全局变量代码块，例如var（…）
    - PackageConsts ：生成常量代码块，例如consts（…）
    - GenerateType ：生成代码. 块根据传入的类型生成代码
    - Imports ：获得需要生成的import代码块. 通过该方法生成Go语言的import代码块，例如import（…）
    - Filename ：生成的目标代码文件的全名，例如deepcopy-gen代码生成器的目标代码文件名为zz_generated.deepcopy.go
    - FileType ：生成代码文件的类型，一般为golang，也有protoidl、api-violation等代码文件类型

Kubernetes目前提供的每个代码生成器都可以实现以上方法. 如果代码生成器没有实现某些方法，则继承默认代码生成器（DefaultGen）的方法，DefaultGen定义于vendor/k8s.io/gengo/generator/default_generator.go中.

`./_output/bin/deepcopy-gen --v 1 --logtostderr -i k8s.io/kubernetes/pkg/apis/abac/v1beta1 --bounding-dirs k8s.io/kubernetes,"k8s.io/api" -O zz_generated.deepcopy`生成流程详解:
1. 实例化generator.Packages对象

    deepcopy-gen代码生成器根据输入的包的目录路径（即输入源），实例化[generator.Packages](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/examples/deepcopy-gen/generators/deepcopy.go#L208)对象，根据generator.Packages结构生成代码.

    在deepcopy-gen代码生成器的Packages函数中，实例化generator.Packages对象并返回该对象。根据输入源信息，实例化当前Packages对象的结构：PackageName字段为v1beta1，PackagePath字段为k8s.io/kubernetes/pkg/apis/abac/v1beta1. 其中，最主要的是GeneratorFunc定义了Generator接口的实现（即NewGenDeepCopy实现了Generator接口方法）.

2.执行代码生成

    在gengo中，generator定义代码生成器通用接口Generator. 通过[ExecutePackage](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/generator/execute.go#L215)函数，调用不同代码生成器（如deepcopy-gen）的Generator接口方法，并生成代码.

    ExecutePackage代码生成执行流程：生成Header代码块→生成Imports代码块→生成Vars全局变量代码块→生成Consts常量代码块→生成Body代码块. 最后，调用assembler.AssembleFile函数，将生成的代码块信息写入zz_generated.deepcopy.go文件，生成pkg/apis/abac/v1beta1/zz_generated.deepcopy.go代码结构.

    deepcopy-gen代码生成器最终生成了代码文件zz_generated.deepcopy.go，该文件的整体结构可分为如下部分:
    1. Header代码块信息，包括build tag和license boilerplate文件（存放开源软件作者及开源协议等信息），其中license boilerplate文件可以从hack/boilerplate/boilerplate.go.txt中获取
    1. Imports代码块信息，引入外部包
    1. Vars全局变量代码块信息，当前代码文件未使用Vars
    1. Consts常量代码块信息，当前代码文件未使用Consts
    1. Body代码块信息，生成DeepCopy深复制函数

    在生成代码的过程中，Filter函数和GenerateType函数非常重要. deepcopy-gen代码生成器根据[Filter类型过滤器](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/examples/deepcopy-gen/generators/deepcopy.go#L397)筛选需要生成哪些结构.

    通过Filter→copyableType的实现，deepcopy-gen代码生成器只筛选出了类型为Struct结构的数据（即只为Struct结构的数据生成DeepCopy函数）. 

    [GenerateType函数](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/gengo/examples/deepcopy-gen/generators/deepcopy.go#L582)会其根据传入的类型生成Body代码块信息. 内部通过Go语言标准库text/template模板语言渲染出生成的Body代码块信息.

    generator.NewSnippetWriter内部封装了text/template模板语言，通过将模板应用于数据结构来执行模板. SnippetWriter对象在实例化时传入模板指令的标识符（即指令开始为$，指令结束为$，有时候也会使用{{}}作为模板指令的标识符）.

    SnippetWriter通过Do函数加载模板字符串，并执行渲染模板. 模板指令中的点（`.`）表示引用args参数传递到模板指令中. 模板指令中的（`|`）表示管道符，即把左边的值传递给右边.

# 核心数据结构
参考:
- [Using The Kubernetes API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/)

在整个Kubernetes体系架构中，资源是Kubernetes最重要的概念，可以说Kubernetes的生态系统都围绕着资源运作. Kubernetes系统虽然有相当复杂和众多的功能，但它本质上是一个资源控制系统——注册、管理、调度资源并维护资源的状态.

在Kubernetes庞大而复杂的系统中，只有资源是远远不够的，Kubernetes将资源再次分组和版本化，形成Group（资源组）、Version（资源版本）、Resource（资源）.
- Group ：被称为资源组，在Kubernetes API Server中也可称其为APIGroup
- Version ：被称为资源版本，在Kubernetes API Server中也可称其为APIVersions
- Resource ：被称为资源，在Kubernetes API Server中也可称其为APIResource
- Kind ：资源种类，描述Resource的种类，与Resource为同一级别

![Group、Version、Resource核心数据结构](/misc/img/container/k8s/group-version-resource.jpg)

Kubernetes系统支持多个Group，每个Group支持多个Version，每个Version支持多个Resource，其中部分资源同时会拥有自己的子资源（即SubResource）. 例如，Deployment资源拥有Status子资源.

资源组、资源版本、资源、子资源的完整表现形式为`<group>/<version>/<resource>/<subresource>`. 以常用的Deployment资源为例，其完整表现形式为`apps/v1/deployments/status`
另外，资源对象（Resource Object）由“资源组+资源版本+资源种类”组成，并在实例化后表达一个资源对象，例如Deployment资源实例化后拥有资源组、资源版本及资源种类，其表现形式为`<group>/<version>，Kind=<kind>`，例如`apps/v1，Kind=Deployment`.

每一个资源都拥有一定数量的资源操作方法（即Verbs），资源操作方法用于Etcd集群存储中对资源对象的增、删、改、查操作. 目前Kubernetes系统支持8种资源操作方法，分别是create、delete、deletecollection、get、list、patch、update、watch操作方法.

每一个资源都至少有两个版本，分别是外部版本（External Version）和内部版本（Internal Version）. 外部版本用于对外暴露给用户请求的接口所使用的资源对象. 内部版本不对外暴露，仅在Kubernetes API Server内部使用.

Kubernetes资源也可分为两种，分别是Kubernetes Resource（Kubernetes内置资源）和Custom Resource（自定义资源）. 开发者通过CRD（即Custom Resource Definitions）可实现自定义资源，它允许用户将自己定义的资源添加到Kubernetes系统中，并像使用Kubernetes内置资源一样使用它们.

## ResourceList
Kubernetes Group、Version、Resource等核心数据结构存放在[vendor/k8s.io/apimachinery/pkg/apis/meta/v1](https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1)目录中. 它包含了Kubernetes集群中所有组件使用的通用核心数据结构，例如APIGroup、APIVersions、APIResource等. 其中，可以通过APIResourceList数据结构描述所有Group、Version、Resource的结构.

Kubernetes的每个资源可使用metav1.APIResource结构进行描述，它描述资源的基本信息，例如资源名称（即Name字段）、资源所属的命名空间（即Namespaced字段）、资源种类（即Kind字段）、资源可操作的方法列表（即Verbs字段）.

每一个资源都属于一个或多个资源版本，资源所属的版本通过metav1.APIVersions结构描述，一个或多个资源版本通过Versions []string字符串数组进行存储.

在APIResourceList中，通过GroupVersion字段来描述资源组和资源版本，它是一个字符串，当资源同时存在资源组和资源版本时，它被设置为`<group>/<version>`；当资源不存在资源组（Core Group）时，它被设置为`/<version>`. 可以看到Pod、Service资源属于v1版本，而Deployment资源属于apps资源组下的v1版本.

另外，可以通过Group、Version、Resource结构来明确标识一个资源的资源组名称、资源版本及资源名称. Group、Version、Resource简称GVR，在Kubernetes源码中该数据结构被大量使用，它被定义在[vendor/k8s.io/apimachinery/pkg/runtime/schema](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/schema/group_version.go#L96)中. 在`vendor/k8s.io/apimachinery/pkg/runtime/schema`包中还定义了常用的资源数据结构:
- GroupResource   GR  资源组+资源
- GroupKind   GK  资源组+资源种类
- GroupVersion    GV  资源组+资源版本
- GroupVersionKind    GVK 资源自+资源版本+资源种类

    当资源对象的GVK输出为“/，Kind=”时，我们同样认为它是内部版本的资源对象.
- GroupVersions   GVS 资源组内多个资源版本

## Group（资源组）
Kubernetes系统中定义了许多资源组，这些资源组按照不同功能将资源进行了划分，资源组特点如下:
- 将众多资源按照功能划分成不同的资源组，并允许单独启用/禁用资源组. 当然也可以单独启用/禁用资源组中的资源
- 支持不同资源组中拥有不同的资源版本. 这方便组内的资源根据版本进行迭代升级
- 支持同名的资源种类（即Kind）存在于不同的资源组内
- 资源组与资源版本通过Kubernetes API Server对外暴露，允许开发者通过HTTP协议进行交互并通过动态客户端（即DynamicClient）进行资源发现
- 支持CRD自定义资源扩展
- 用户交互简单，例如在使用kubectl命令行工具时，可以不填写资源组名称

group用[APIGroup](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go#L943)表示:
- Name ：资源组名称
- Versions ：资源组下所支持的资源版本
- PreferredVersion ：首选版本. 当一个资源组内存在多个资源版本时，Kubernetes API Server在使用资源时会选择一个首选版本作为当前版本
在当前的Kubernetes系统中，支持两类资源组，分别是拥有组名的资源组和没有组名的资源组
- 拥有组名的资源组 ：其表现形式为<group>/<version>/<resource>，例如apps/v1/deployments

    拥有组名的资源组的HTTP PATH以/apis为前缀，其表现形式为/apis/<group>/<version>/<resource>，例如http://localhost：8080/apis/apps/v1/deployments.
- 没有组名的资源组 ：被称为Core Groups（即核心资源组）或Legacy Groups，也可被称为GroupLess（即无组）。其表现形式为/<version>/<resource>，例如/v1/pods

    没有组名的资源组的HTTP PATH以/api为前缀，其表现形式为/api/<version>/<resource>，例如http://localhost：8080/api/v1/pods

    > 没有组名的资源组，表示资源组名称为空。在后面会经常出现类似于/v1的表达，用来表示核心资源组下的v1资源版本

## version
Kubernetes的资源版本控制类似于语义版本控制（Semantic Versioning），在该基础上的资源版本定义允许版本号以v开头，例如v1beta1. 每当发布新的资源时，都需要对其设置版本号，这是为了在兼容旧版本的同时不断升级新版本，这有助于帮助用户了解应用程序处于什么阶段，以及实现当前程序的迭代. 语义版本控制应用得非常广泛，目前也是开源界常用的一种版本控制规范.

Kubernetes的资源版本控制可分为3种，分别是Alpha、Beta、Stable，它们之间的迭代顺序为Alpha→Beta→Stable，其通常用来表示软件测试过程中的3个阶段:
1. Alpha是第1个阶段，一般用于Kubernetes开发者内部测试

    该版本是不稳定的，可能存在很多缺陷和漏洞，官方随时可能会放弃支持该版本。在默认的情况下，处于Alpha版本的功能会被禁用. Alpha版本名称一般为v1alpha1、v1alpha2、v2alpha1等.
1. Beta是第2个阶段，该版本已经修复了大部分不完善之处，但仍有可能存在缺陷和漏洞，一般由特定的用户群来进行测试

    相对稳定的版本，Beta版本经过官方和社区很多次测试，当功能迭代时，该版本会有较小的改变，但不会被删除. 在默认的情况下，处于Beta版本的功能是开启状态的, Beta版本命名一般为v1beta1、v1beta2、v2beta1.
1. Stable是第3个阶段，此时基本形成了产品并达到了一定的成熟度，可稳定运行

    为正式发布的版本，Stable版本基本形成了产品，该版本不会被删除。在默认的情况下，处于Stable版本的功能全部处于开启状态. Stable版本命名一般为v1、v2、v3.

version用[APIVersions](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go#L915)表示:
- Versions ：所支持的资源版本列表

## Resource
一个资源被实例化后会表达为一个资源对象（即Resource Object）. 在Kubernetes系统中定义并运行着各式各样的资源对象. 所有资源对象都是Entity, Kubernetes使用这些Entity来表示当前状态. 可以通过Kubernetes API Server进行查询和更新每一个资源对象. Kubernetes目前支持两种Entity:
- 持久性实体（Persistent Entity） ：在资源对象被创建后，Kubernetes会持久确保该资源对象存在. 大部分资源对象属于持久性实体，例如Deployment资源对象
- 短暂性实体（Ephemeral Entity） ：也可称其为非持久性实体（Non-Persistent Entity）. 在资源对象被创建后，如果出现故障或调度失败，不会重新创建该资源对象，例如Pod资源对象.

Resource用[APIResource](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go#L984)表示:
- Name ：资源名称。
- SingularName ：资源的单数名称，它必须由小写字母组成，默认使用资源种类（Kind）的小写形式进行命名。例如，Pod资源的单数名称为pod，复数名称为pods
- Namespaced ：资源是否拥有所属命名空间
- Group ：资源所在的资源组名称
- Version ：资源所在的资源版本
- Kind ：资源种类
- Verbs ：资源可操作的方法列表，例如get、list、delete、create、update等
- ShortNames ：资源的简称，例如Pod资源的简称为po

### 资源外部版本与内部版本
Kubernetes资源代码定义在pkg/apis目录下，在Kubernetes系统中，同一资源对应着两个版本: 外部版本（External Version）与内部版本（Internal Version）. 例如，Deployment资源，它所属的外部版本表现形式为apps/v1，内部版本表现形式为apps/__internal.

- External Object ：外部版本资源对象，也称为Versioned Object（即拥有资源版本的资源对象）. 外部版本用于对外暴露给用户请求的接口所使用的资源对象，例如，用户在通过YAML或JSON格式的描述文件创建资源对象时，所使用的是外部版本的资源对象. 外部版本的资源对象通过资源版本（Alpha、Beta、Stable）进行标识
- Internal Object ：内部版本资源对象。内部版本不对外暴露，仅在Kubernetes API Server内部使用. 内部版本用于多资源版本的转换，例如将v1beta1版本转换为v1版本，其过程为v1beta1→internal→v1，即先将v1beta1转换为内部版本（internal），再由内部版本（internal）转换为v1版本. 内部版本资源对象通过runtime.APIVersionInternal（即__internal）进行标识.

资源版本（如v1beta1、v1等）与外部版本/内部版本概念不同: **拥有资源版本的资源属于外部版本，拥有runtime.APIVersionInternal标识的资源属于内部版本**

资源的外部版本代码定义在`pkg/apis/<group>/<version>/`目录下，资源的内部版本代码定义在`pkg/apis/<group>/`目录下. 例如，Deployment资源，它的外部版本定义在`pkg/apis/apps/{v1，v1beta1，v1beta2}/`目录下，它的内部版本定义在`pkg/apis/apps/`目录下（内部版本一般与资源组在同一级目录下）.

资源的外部版本和内部版本是需要相互转换的，而用于转换的函数需要事先初始化到资源注册表（Scheme）中. 多个外部版本（External Version）之间的资源进行相互转换，都需要通过内部版本（Internal Version）进行中转. 这也是Kubernetes能实现多资源版本转换的关键.

在Kubernetes源码中，外部版本的资源类型定义在vendor/k8s.io/api目录下，其完整描述路径为`vendor/k8s.io/api/<group>/<version>/<resource file>`.例如，Pod资源的外部版本，定义在vendor/k8s.io/api/core/v1/目录下.

资源的外部版本与内部版本的代码定义也不太一样，外部版本的资源需要对外暴露给用户请求的接口，所以资源代码定义了JSON Tags和Proto Tags，用于请求的序列化和反序列化操作。内部版本的资源不对外暴露，所以没有任何的JSON Tags和Proto Tags定义. 可通过`vendor/k8s.io/api/core/v1/types.go`和`pkg/apis/core/types.go`中的`type Pod struct`比较.

### 资源代码定义
Kubernetes资源代码定义在pkg/apis目录下，同一资源对应着内部版本和外部版本，内部版本和外部版本的资源代码结构并不相同.

资源的内部版本定义了所支持的资源类型（types.go）、资源验证方法（validation.go）、资源注册至资源注册表的方法（install/install.go）等. 而资源的外部版本定义了资源的转换方法（conversion.go）、资源的默认值（defaults.go）等.

以Deployment资源为例，它的内部版本定义在pkg/apis/apps/目录下，其资源代码结构如下：
- doc.go ：GoDoc文件，定义了当前包的注释信息。在Kubernetes资源包中，它还担当了代码生成器的全局Tags描述文件
- register.go ：定义了资源组、资源版本及资源的注册信息
- types.go ：定义了在当前资源组、资源版本下所支持的资源类型
- v1 、v1beta1 、v1beta2 ：定义了资源组下拥有的资源版本的资源（即外部版本）
- install ：把当前资源组下的所有资源注册到资源注册表中
- validation ：定义了资源的验证方法
- zz_generated.deepcopy.go ：定义了资源的深复制操作，该文件由代码生成器自动生成

每一个Kubernetes资源目录，都通过register.go代码文件定义所属的资源组和资源版本，内部版本资源对象通过runtime.APIVersionInternal（即__internal）标识.
每一个Kubernetes资源目录，都通过type.go代码文件定义当前资源组/资源版本下所支持的资源类型.

以Deployment资源为例，它的外部版本定义在pkg/apis/apps/{v1，v1beta1，v1beta2}目录下，其资源代码结构如下:
- 其中doc.go和register.go的功能与内部版本资源代码结构中的相似
- conversion.go ：定义了资源的转换函数（默认转换函数），并将默认转换函数注册到资源注册表中
- zz_generated.conversion.go ：定义了资源的转换函数（自动生成的转换函数），并将生成的转换函数注册到资源注册表中。该文件由代码生成器自动生成。
- defaults.go ：定义了资源的默认值函数，并将默认值函数注册到资源注册表中
- zz_generated.defaults.go ：定义了资源的默认值函数（自动生成的默认值函数），并将生成的默认值函数注册到资源注册表中。该文件由代码生成器自动生成。
外部版本与内部版本资源类型相同，都通过register.go代码文件定义所属的资源组和资源版本，外部版本资源对象通过资源版本（Alpha、Beta、Stable）标识

### 将资源注册到资源注册表中
在每一个Kubernetes资源组目录中，都拥有一个install/install.go代码文件，它负责将资源信息注册到资源注册表（Scheme）中, 以apps的`pkg/apis/apps/install/install.go`为例:
```go
func init() {
    Install(legacyscheme.Scheme)
}

// Install registers the API group and adds types to a scheme
func Install(scheme *runtime.Scheme) {
    utilruntime.Must(apps.AddToScheme(scheme))
    utilruntime.Must(v1beta1.AddToScheme(scheme))
    utilruntime.Must(v1beta2.AddToScheme(scheme))
    utilruntime.Must(v1.AddToScheme(scheme))
    utilruntime.Must(scheme.SetVersionPriority(v1.SchemeGroupVersion, v1beta2.SchemeGroupVersion, v1beta1.SchemeGroupVersion))
}
```

legacyscheme.Scheme是kube-apiserver组件的全局资源注册表，Kubernetes的所有资源信息都交给资源注册表统一管理. apps.AddToScheme函数注册apps资源组内部版本的资源. v1.AddToScheme函数注册apps资源组外部版本的资源. scheme.SetVersionPriority函数注册资源组的版本顺序，如有多个资源版本，排在最前面的为资源首选版本, 因此scheme.SetVersionPriority注册版本顺序很重要.

#### 资源首选版本
首选版本（Preferred Version），也称优选版本（Priority Version），一个资源组下拥有多个资源版本，例如，apps资源组拥有v1、v1beta1、v1beta2等资源版本. 当使用apps资源组下的Deployment资源时，在一些场景下，如不指定资源版本，则使用该资源的首选版本
以apps资源组为例，注册资源时会注册多个资源版本，分别是v1、v1beta2、v1beta1.

当通过资源注册表[scheme.PreferredVersionAllGroups](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go#L638)函数获取所有资源组下的首选版本时，将位于最前面的资源版本作为首选版本.

> 在`(*Scheme)versionPriority`结构中并不存储资源对象的内部版本

除了scheme.PreferredVersionAllGroups函数外，还有另两个函数用于获取资源版本顺序相关的操作:
- scheme.PrioritizedVersionsForGroup ：获取指定资源组的资源版本，按照优先顺序返回
- scheme.PrioritizedVersionsAllGroups ：获取所有资源组的资源版本，按照优先顺序返回

### 资源操作方法
在Kubernetes系统中，针对每一个资源都有一定的操作方法（即Verbs），例如，对于Pod资源对象，可以通过kubectl命令行工具对其执行create、delete、get等操作. Kubernetes系统所支持的操作方法目前有8种操作，分别是create、delete、deletecollection、get、list、patch、update、watch. 这些操作方法可分为四大类，分别属于增、删、改、查，对资源进行创建、删除、更新和查询.

资源操作方法可以通过[metav1.Verbs](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go#L1023)进行描述.

不同资源拥有不同的操作方法，例如，针对Pod资源对象与pod/logs子资源对象，Pod资源对象拥有create、delete、deletecollection、get、list、patch、update、watch等操作方法，pod/logs子资源对象只拥有get操作方法，因为日志只需要执行查看操作。Pod资源对象与pod/logs子资源对象的操作方法分别通过metav1.Verbs进行描述.

资源对象的操作方法与存储（Storage）相关联，增、删、改、查实际上都是针对存储的操作。如何了解一个资源对象拥有哪些可操作的方法呢？需要查看与存储相关联的源码包registry，其定义在vendor/k8s.io/apiserver/pkg/registry/目录下. 每种操作方法对应一个操作方法接口（Interface）:

![资源对象操作方法接口说明](/misc/img/container/k8s/resource-verbs.jpg)

以Pod资源对象为例，Pod资源对象的存储（Storage）实现了以上接口的方法，Pod资源对象继承了genericregistry.Store，该对象可以管理存储（Storage）的增、删、改、查操作; 以pod/logs子资源对象为例，该资源对象只实现了get操作方法:
```go
// https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/core/pod/storage/storage.go#L50

// PodStorage includes storage for pods and all sub resources
type PodStorage struct {
    Pod                 *REST
    ...
    Log                 *podrest.LogREST
    ...
}

// REST implements a RESTStorage for pods
type REST struct {
    *genericregistry.Store
    ...
}

// https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L93

func (e *Store) Create(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, error) {}

// https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/core/pod/rest/log.go#L74
func (r *LogREST) Get(ctx context.Context, name string, opts runtime.Object) (runtime.Object, error) {}
```

### 资源与命名空间
Kubernetes系统支持命名空间（Namespace），其用来解决Kubernetes集群中资源对象过多导致管理复杂的问题. 每个命名空间相当于一个“虚拟集群”，不同命名空间之间可以进行隔离，当然也可以通过某种方式跨命名空间通信.

在一些使用场景中，命名空间常用于划分不同的环境，比如将Kubernetes系统划分为3个环境，分别是pro生产环境、test测试环境及dev开发环境，它们之间相互隔离，admin管理员用户对3个环境都拥有权限，而derek作为开发者只对dev开发环境拥有权限.

Kubernetes系统中默认内置了4个命名空间，分别介绍如下:
- default ：所有未指定命名空间的资源对象都会被分配给该命名空间
- kube-system ：所有由Kubernetes系统创建的资源对象都会被分配给该命名空间
- kube-public ：此命名空间下的资源对象可以被所有人访问（包括未认证用户）
- kube-node-lease ：此命名空间下存放来自节点的心跳记录（节点租约信息）

通过运行kubectl get namespace命令查看Kubernetes系统上所有的命名空间信息. 另外，在Kubernetes系统中，大部分资源对象都存在于某些命名空间中（例如Pod资源对象）. 但并不是所有的资源对象都存在于某个命名空间中（例如Node资源对象）. 决定资源对象属于哪个命名空间，可通过资源对象的ObjectMeta.Namespace描述.

### 自定义资源
Kubernetes系统拥有强大的高扩展功能，其中自定义资源（Custom Resource）就是一种常见的扩展方式，即可将自己定义的资源添加到Kubernetes系统中. Kubernetes系统附带了许多内置资源，但是仍有些需求需要使用自定义资源来扩展Kubernetes的功能.

自Kubernetes 1.7开始支持CustomResourceDefinitions（自定义资源定义，简称CRD）.

开发者通过CRD可以实现自定义资源，它允许用户将自己定义的资源添加到Kubernetes系统中，并像使用Kubernetes内置资源一样使用这些资源，例如，在YAML/JSON文件中带有Spec的资源定义都是对Kubernetes中的资源对象的定义，所有的自定义资源都可以与Kubernetes系统中的内置资源一样使用kubectl或client-go进行操作.

### 资源对象描述文件定义
Kubernetes资源可分为内置资源（Kubernetes Resources）和自定义资源（Custom Resources），它们都通过资源对象描述文件（Manifest File）进行定义.

一个资源对象需要用5个字段来描述它，分别是Group/Version、Kind、MetaData、Spec、Status, 这些字段定义在YAML或JSON文件中. Kubernetes系统中的所有的资源对象都可以采用YAML或JSON格式的描述文件来定义，下面是某个Pod文件的资源对象描述文件为例:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: static-web
  labels:
    role: myrole
spec:
  containers:
    - name: web
      image: nginx
      ports:
        - name: web
          containerPort: 80
          protocol: TCP
```

- apiVersion ：指定创建资源对象的资源组和资源版本，其表现形式为<group>/<version>，若是core资源组（即核心资源组）下的资源对象，其表现形式为<version>
- kind ：指定创建资源对象的种类
- metadata ：描述创建资源对象的元数据信息，例如名称、命名空间等
- spec ：包含有关Deployment资源对象的核心信息，告诉Kubernetes期望的资源状态、副本数量、环境变量、卷等信息。
- status ：包含有关正在运行的Deployment资源对象的信息

每一个Kubernetes资源对象都包含两个嵌套字段，即spec字段和status字段. 其中spec字段是必需的，它描述了资源对象的“期望状态”（Desired State），而status字段用于描述资源对象的“实际状态”（Actual State），它是由Kubernetes系统提供和更新的. 在任何时刻，Kubernetes控制器一直努力地管理着对象的实际状态以与期望状态相匹配.

## Kubernetes内置资源
Kubernetes系统内置了众多“资源组、资源版本、资源”，这才有了现在功能强大的资源管理系统, 可通过如下方式获得当前Kubernetes系统所支持的内置资源:
- kubectl api-versions ：列出当前Kubernetes系统支持的资源组和资源版本，其表现形式为<group>/<version>
- kubectl api-resources ：列出当前Kubernetes系统支持的Resource资源列表

```bash
kubectl api-resources -o wide [--namespaced=true] # 查看所有api resource, `--namespaced`表示该资源是否属于namespace
kubectl explain configmap [--api-version apps/v1] # 查看resource信息
kubectl api-versions # 查看所有api version
kubectl get deployments.v1.apps -n kube-system # 按照resource获取deployment
```

## runtime.Object类型基石
Runtime被称为“运行时”，在很多其他程序或语言中见过它，它一般指程序或语言核心库的实现. Kubernetes Runtime在`vendor/k8s.io/apimachinery/pkg/runtime`中实现，它提供了通用资源类型runtime.Object.

[runtime.Object](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/interfaces.go#L299)是Kubernetes类型系统的基石. Kubernetes上的所有资源对象（Resource Object）实际上就是一种Go语言的Struct类型，相当于一种数据结构，它们都有一个共同的结构叫runtime.Object. runtime.Object被设计为Interface接口类型，作为资源对象的通用资源对象.

以资源对象Pod为例，该资源对象可以转换成runtime.Object通用资源对象，也可以从runtime.Object通用资源对象转换成Pod资源对象.

runtime.Object提供了两个方法，分别是GetObjectKind和DeepCopyObject:
- GetObjectKind ：用于设置并返回GroupVersionKind
- DeepCopyObject ：用于深复制当前资源对象并返回

深复制相当于将数据结构克隆一份，因此它不与原始对象共享任何内容. 它使代码在不修改原始对象的情况下可以改变克隆对象的任何属性.

那么，如何确认一个资源对象是否可以转换成runtime.Object通用资源对象呢？这时需要确认该资源对象是否拥有GetObjectKind和DeepCopyObject方法. Kubernetes的每一个资源对象都嵌入了metav1.TypeMeta类型，metav1.TypeMeta类型实现了GetObjectKind方法，所以资源对象拥有该方法. 另外，Kubernetes的每一个资源对象都实现了DeepCopyObject方法，该方法一般被定义在zz_generated.deepcopy.go文件中. 因此，可以认为该资源对象能够转换成runtime.Object通用资源对象. 
所以，Kubernetes的任意资源对象都可以通过runtime.Object存储它的类型并允许深复制操作. 

比如实例化Pod资源，得到Pod资源对象，通过runtime.Object将Pod资源对象转换成通用资源对象（得到obj）, 然后通过断言的方式，将obj通用资源对象转换成Pod资源对象（得到pod2）. 最终可通过reflect（反射）来验证转换之前和转换之后的资源对象是否相等.

## Unstructured数据
数据可以分为结构化数据（Structured Data）和非结构化数据（Unstructured Data）. Kubernetes内部会经常处理这两种数据.

预先知道数据结构的数据类型是结构化数据.

无法预知数据结构的数据类型或属性名称不确定的数据类型是非结构化数据，其无法通过构建预定的struct数据结构来序列化或反序列化数据.

Kubernetes非结构化数据通过map[string]interface{}表达，并提供[Unstructured接口](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/interfaces.go). 在client-go编程式交互的DynamicClient内部，实现了Unstructured类型，用于处理非结构化数据.

## Scheme资源注册表
Kubernetes Scheme资源注册表类似于Windows操作系统上的注册表，只不过注册的是资源类型.

Kubernetes系统拥有众多资源，每一种资源就是一个资源类型，这些资源类型需要有统一的注册、存储、查询、管理等机制. 目前Kubernetes系统中的所有资源类型都已注册到Scheme资源注册表中，其是一个内存型的资源注册表，拥有如下特点:
- 支持注册多种资源类型，包括内部版本和外部版本
- 支持多种版本转换机制
- 支持不同资源的序列化/反序列化机制

Scheme资源注册表支持两种资源类型（Type）的注册，分别是UnversionedType和KnownType资源类型，分别介绍如下:
- UnversionedType ：无版本资源类型，这是一个早期Kubernetes系统中的概念，它主要应用于某些没有版本的资源类型，该类型的资源对象并不需要进行转换。在目前的Kubernetes发行版本中，**无版本类型已被弱化**，几乎所有的资源对象都拥有版本，但在metav1元数据中还有部分类型，它们既属于meta.k8s.io/v1又属于UnversionedType无版本资源类型，例如metav1.Status、metav1.APIVersions、metav1.APIGroupList、metav1.APIGroup、metav1.APIResourceList
- KnownType ：是目前Kubernetes最常用的资源类型，也可称其为“拥有版本的资源类型”

通过runtime.NewScheme可实例化一个新的Scheme资源注册表. 注册资源类型到Scheme资源注册表有两种方式: UnversionedType资源类型的对象通过[scheme.AddUnversionedTypes](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go#L144)方法进行注册，KnownType资源类型的对象通过[scheme.AddKnownTypes](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go#L162)方法进行注册.

在Scheme资源注册表中，不同的资源类型使用的注册方法不同，分别介绍如下:
- scheme.AddUnversionedTypes ：注册UnversionedType资源类型
- scheme.AddKnownTypes ：注册KnownType资源类型
    
    与scheme.AddKnownTypeWithName区别: 在注册资源类型时，无须指定Kind名称，而是通过reflect机制获取资源类型的名称作为资源种类名称
- scheme.AddKnownTypeWithName ：注册KnownType资源类型，须指定资源的Kind资源种类名称

### Scheme资源注册表数据结构
[Scheme](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go#L46)资源注册表数据结构主要由4个map结构组成，它们分别是gvkToType、typeToGVK、unversionedTypes、unversionedKinds.

Scheme资源注册表结构字段说明如下:
- gvkToType ：存储GVK与Type的映射关系
- typeToGVK ：存储Type与GVK的映射关系，一个Type会对应一个或多个GVK
- unversionedTypes ：存储UnversionedType与GVK的映射关系
- unversionedKinds ：存储Kind（资源种类）名称与UnversionedType的映射关系

Scheme资源注册表通过Go语言的map结构实现映射关系，这些映射关系可以实现高效的正向和反向检索，从Scheme资源注册表中检索某个GVK的Type，它的时间复杂度为O(1).

Scheme资源注册表在Kubernetes系统体系中属于非常核心的数据结构.

参考[TestScheme](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme_test.go#L67)和[TestUnversionedTypes](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme_test.go#L399)代码.

![资源注册表映射关系](/misc/img/container/k8s/scheme.jpg)

GVK（资源组、资源版本、资源种类）在Scheme资源注册表中以<group>/<version>，Kind=<kind>的形式存在，其中对于Kind（资源种类）字段，在注册时如果不指定该字段的名称，那么默认使用类型的名称，例如corev1.Pod类型，通过reflect机制获取资源类型的名称，那么它的资源种类Kind=Pod.

资源类型在Scheme资源注册表中以Go Type（通过reflect机制获取）形式存在.

另外，需要注意的是，UnversionedType类型的对象在通过scheme.AddUnversionedTypes方法注册时，会同时存在于4个map结构中.

在运行过程中，kube-apiserver组件常对Scheme资源注册表进行查询，它提供了如下方法:
- scheme.KnownTypes ：查询注册表中指定GV下的资源类型
- scheme.AllKnownTypes ：查询注册表中所有GVK下的资源类型
- scheme.ObjectKinds ：查询资源对象所对应的GVK，一个资源对象可能存在多个GVK
- scheme.New ：查询GVK所对应的资源对象
- scheme.IsGroupRegistered ：判断指定的资源组是否已经注册
- scheme.IsVersionRegistered ：判断指定的GV是否已经注册
- scheme.Recognizes ：判断指定的GVK是否已经注册
- scheme.IsUnversioned ：判断指定的资源对象是否属于UnversionedType类型

## Codec编解码器
Codec编解码器与Serializer序列化器之间的差异:
- Serializer ：序列化器，包含序列化操作与反序列化操作。序列化操作是将数据（例如数组、对象或结构体等）转换为字符串的过程，反序列化操作是将字符串转换为数据的过程，因此可以轻松地维护数据结构并存储或传输数据
- Codec ：编解码器，包含编码器与解码器。编解码器是一个通用术语，指的是可以表示数据的任何格式，或者将数据转换为特定格式的过程。所以，可以将Serializer序列化器也理解为Codec编解码器的一种

k8s Codec编解码器通用接口定义在[`vendor/k8s.io/apimachinery/pkg/runtime/interfaces.go`](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/interfaces.go)

从Codec编解码器通用接口的定义可以看出，Serializer序列化器属于Codec编解码器的一种，这是因为每种序列化器都实现了Encoder与Decoder方法. 只要实现了Encoder与Decoder方法的数据结构，就是序列化器. Kubernetes目前支持3种主要的序列化器: json, yaml, protobuf.

在进行编解码操作时，每一种序列化器都对资源对象的metav1.TypeMeta（即APIVersion和Kind字段）进行验证，如果资源对象未提供这些字段，就会返回错误. 每种序列化器分别实现了Encode序列化方法与Decode反序列化方法，分别介绍如下:
- jsonSerializer ：JSON格式序列化/反序列化器
    
    通过json.NewSerializerWithOptions函数进行实例化, 使用application/json的ContentType作为标识, 文件扩展名为json
- yamlSerializer ：YAML格式序列化/反序列化器

    通过json.NewSerializerWithOptions函数进行实例化, 使用application/yaml的ContentType作为标识, 文件扩展名为yaml
- protobufSerializer ：Protobuf格式序列化/反序列化器

    protobufSerializer通过protobuf.NewSerializer函数进行实例化，使用application/vnd.kubernetes.protobuf的ContentType标识，文件扩展名为pb.

    [Encode](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/serializer/protobuf/protobuf.go#L163)函数首先验证资源对象是否为proto.Marshaler类型，proto.Marshaler是一个interface接口类型，该接口专门留给对象自定义实现的序列化操作。如果资源对象为proto.Marshaler类型，则通过t.Marshal序列化函数进行编码.

    而且，通过unk.MarshalTo函数在编码后的数据前加上protoEncodingPrefix前缀，前缀为magic-number特殊标识，其用于标识一个包的完整性。所有通过protobufSerializer序列化器编码的数据都会有前缀。前缀数据共4字节，分别是0x6b、0x38、0x73、0x00，其中第4个字节是为编码样式保留的

    [Decode](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/serializer/protobuf/protobuf.go#L97)函数首先验证protoEncodingPrefix前缀，前缀为magic-number特殊标识，其用于标识一个包的完整性，然后验证资源对象是否为proto.Message类型，最后通过proto.Unmarshal反序列化函数进行解码.

Codec编解码器将Etcd集群中的数据进行编解码操作.

Codec编解码器通过[NewCodecFactory→newSerializersForScheme](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/serializer/codec_factory.go#L51)函数实例化，在实例化的过程中会将jsonSerializer、yamlSerializer、protobufSerializer序列化器全部实例化.

Kubernetes在jsonSerializer序列化器上做了一些优化，caseSensitiveJsonIterator函数实际封装了github.com/json-iterator/go第三方库，json-iterator有如下几个好处:
- json-iterator支持区分大小写。Go语言标准库encoding/json在默认情况下不区分大小写
- json-iterator性能更优
- json-iterator 100%兼容Go语言标准库encoding/json，可随时切换两种编解码方式

## Converter资源版本转换器
在Kubernetes系统中，同一资源拥有多个资源版本，Kubernetes系统允许同一资源的不同资源版本进行转换，例如Deployment资源对象，当前运行的是v1beta1资源版本，但v1beta1资源版本的某些功能或字段不如v1资源版本完善，则可以将Deployment资源对象的v1beta1资源版本转换为v1版本. 可通过kubectl convert命令进行资源版本转换: `kubectl convert -f v1beta1Deployment.yaml --output-version=apps/v1`

首先，定义一个YAML Manifest File资源描述文件，该文件中定义Deployment资源版本为v1beta1. 通过执行kubect convert命令，--output-version将资源版本转换为指定的资源版本v1. 如果指定的资源版本不在Scheme资源注册表中，则会报错. 如果不指定资源版本，则默认转换为资源的首选版本.

Converter资源版本转换器主要**用于解决多资源版本转换问题**，Kubernetes系统中的一个资源支持多个资源版本，如果要在每个资源版本之间转换，最直接的方式是，每个资源版本都支持其他资源版本的转换，但这样处理起来非常麻烦. 例如，某个资源对象支持3个资源版本，那么就需要提前定义一个资源版本转换到其他两个资源版本（v1→v1alpha1，v1→v1beta1）、（v1alpha1→v1，v1alpha1→v1beta1）及（v1beta1→v1，v1beta1→v1alpha1）.

随着资源版本的增加，资源版本转换的定义会越来越多. 为了解决这个问题，Kubernetes通过内部版本（Internal Version）机制实现资源版本转换. 当需要在两个资源版本之间转换时，例如v1alpha1→v1beta1或v1alpha1→v1。Converter资源版本转换器先将第一个资源版本转换为__internal内部版本，再转换为相应的资源版本。每个资源只要能支持内部版本，就能与其他任何资源版本进行间接的资源版本转换.

### Converter转换器数据结构
Converter转换器数据结构主要存放转换函数（即Conversion Funcs）. [Converter转换器](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/conversion/converter.go#L40)数据结构如下:
- conversionFuncs ：默认转换函数。这些转换函数一般定义在资源目录下的conversion.go代码文件中
- generatedConversionFuncs ：自动生成的转换函数。这些转换函数一般定义在资源目录下的zz_generated.conversion.go代码文件中，是由代码生成器自动生成的转换函数。
- ignoredConversions ：若资源对象注册到此字段，则忽略此资源对象的转换操作。
- nameFunc ：在转换过程中其用于获取资源种类的名称，该函数被定义在vendor/k8s.io/apimachinery/pkg/runtime/scheme.go代码文件中。

Converter转换器数据结构中存放的转换函数（即Conversion Funcs）可以分为两类，分别为默认的转换函数（即conversionFuncs字段）和自动生成的转换函数（即generatedConversionFuncs字段）. 它们都通过[ConversionFuncs](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/conversion/converter.go#L40)来管理转换函数.

ConversionFunc类型函数（即Type Function）定义了转换函数实现的结构，将资源对象a转换为资源对象b. a参数定义了转换源（即source）的资源类型，b参数定义了转换目标（即dest）的资源类型。scope定义了多次转换机制（即递归调用转换函数）.

### Converter注册转换函数
Converter转换函数需要通过注册才能在Kubernetes内部使用，目前Kubernetes支持5个注册转换函数，分别介绍如下:
- scheme.AddIgnoredConversionType ：注册忽略的资源类型，不会执行转换操作，忽略资源对象的转换操作
- [scheme.AddConversionFuncs](https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/apimachinery/pkg/runtime/scheme.go) ：注册多个Conversion Func转换函数
- scheme.AddConversionFunc ：注册单个Conversion Func转换函数
- scheme.AddGeneratedConversionFunc ：注册自动生成的转换函数
- scheme.AddFieldLabelConversionFunc ：注册字段标签（FieldLabel）的转换函数

以[apps/v1](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/v1/conversion.go)资源组、资源版本为例，通过scheme.AddConversionFunc函数注册所有资源的转换函数.

### Converter资源版本转换原理
原理: 通过"_internal"桥梁的转换

例如Deployment资源对象，起初使用v1beta1资源版本，而v1资源版本更稳定，则会将v1beta1资源版本转换为v1资源版本. 在将Deployment v1beta1资源版本转换为内部版本（即__internal版本），得到转换后资源对象的GVK为“/，Kind=”。在这里，会产生疑问，为什么v1beta1资源版本转换为内部版本以后得到的GVK为“/，Kind=”而不是“apps/__internal，Kind=Deployment”。这就需要看Kubernetes源码实现了.

Scheme资源注册表可以通过两种方式进行版本转换:
- scheme.ConvertToVersion ：将传入的（in）资源对象转换成目标（target）资源版本，在版本转换之前，会将资源对象深复制一份后再执行转换操作，相当于安全的内存对象转换操作
- scheme.UnsafeConvertToVersion ：与scheme.ConvertToVersion功能相同，但在转换过程中不会深复制资源对象，而是直接对原资源对象进行转换操作，尽可能高效地实现转换。但该操作是非安全的内存对象转换操作

scheme.ConvertToVersion与scheme.UnsafeConvertToVersion资源版本转换功能都依赖于s.convertToVersion函数来实现.

![](/misc/img/container/k8s/convertion.jpg)

Converter转换器转换流程:
1. 获取传入的资源对象的反射类型
    
    资源版本转换的类型可以是runtime.Object或runtime.Unstructured，它们都属于Go语言里的Struct数据结构，通过Go语言标准库reflect机制获取该资源类型的反射类型，因为在Scheme资源注册表中是以反射类型注册资源的。获取传入的资源对象的反射类型
1. 从资源注册表中查找到传入的资源对象的GVK

    从Scheme资源注册表中查找到传入的资源对象的所有GVK，验证传入的资源对象是否已经注册，如果未曾注册，则返回错误

1. 从多个GVK中选出与目标资源对象相匹配的GVK

    target.KindForGroupVersionKinds函数从多个可转换的GVK中选出与目标资源对象相匹配的GVK. 这里有一个优化点，转换过程是相对耗时的，大量的相同资源之间进行版本转换的耗时会比较长。在Kubernetes源码中判断，如果目标资源对象的GVK在可转换的GVK列表中，则直接将传入的资源对象的GVK设置为目标资源对象的GVK，而无须执行转换操作，缩短部分耗时
1. 判断传入的资源对象是否属于Unversioned类型

    对于UnversionedType, 属于该类型的资源对象并不需要进行转换操作，而是直接将传入的资源对象的GVK设置为目标资源对象的GVK即可
1. 执行转换操作

    在执行转换操作之前，先判断是否需要对传入的资源对象执行深复制操作，然后通过s.converter.Convert转换函数执行转换操作.

    实际的转换函数是通过doConversion函数执行的，执行过程如下:
    - 从默认转换函数列表（即c.conversionFuncs）中查找出pair对应的转换函数，如果存在则执行该转换函数（即fn）并返回
    - 从自动生成的转换函数列表（即generatedConversionFuncs）中查找出pair对应的转换函数，如果存在则执行该转换函数（即fn）并返回
    - 如果默认转换函数列表和自动生成的转换函数列表中都不存在当前资源对象的转换函数，则使用[`(*Converter) Convert()`](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/conversion/converter.go#L281)函数传入的转换函数（即f）。调用f之前，需要将src与dest资源对象通过EnforcePtr函数取指针的值，因为`(*Converter) Convert()`函数传入的转换函数接收的是非指针资源对象

1. 设置转换后资源对象的GVK

    将v1beta1资源版本转换为内部版本（即__internal版本），得到转换后资源对象的GVK为“/，Kind=”。原因在于setTargetKind函数，转换操作执行完成以后，通过setTargetKind函数设置转换后资源对象的GVK，判断当前资源对象是否为内部版本（即APIVersionInternal），是内部版本则设置GVK为[`schema.GroupVersionKind{}`](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go#L577)

# kubectl
kubectl工具是Kubernetes API Server的客户端. Kubernetes是一个完全以资源为中心的系统，而kubectl会通过向Kubernetes API Server发起HTTP请求来操纵这些资源（即对资源进行CRUD操作），以完全控制Kubernetes系统集群.

Kubernetes官方提供了命令行工具（CLI），用户可以通过kubectl以命令行交互的方式与Kubernetes API Server进行通信，通信协议使用HTTP/JSON, kubectl的命令主要分为8个种类，分别如下:
- Basic Commands （Beginner ）：基础命令（初级）
- Basic Commands （Intermediate ）：基础命令（中级）
- Deploy Commands ：部署命令
- Cluster Management Commands ：集群管理命令
- Troubleshooting and Debugging Commands ：故障排查和调试命令
- Advanced Commands ：高级命令
- Settings Commands ：设置命令
- Other Commands ：其他命令

## Cobra命令行参数解析

kubectl基于Cobra, 它是一个创建强大的现代化CLI命令行应用程序的Go语言库，也可以用来生成应用程序的文件. 很多知名的开源软件都使用Cobra实现其CLI部分，例如Istio、Docker、Etcd等. Cobra提供了如下功能:
- 支持子命令行（Subcommand）模式，如app server，其中server是app命令的子命令参数
- 完全兼容posix命令行模式
- 支持全局、局部、串联的命令行参数（Flag）
- 轻松生成应用程序和命令
- 如果命令输入错误，将提供智能建议，例如输入app srver，当srver参数不存在时，Cobra会智能提示用户是否应输入app server
- 自动生成命令（Command）和参数（Flag）的帮助信息
- 自动生成详细的命令行帮助（Help）信息，如app help
- 自动识别-h、--help flag
- 提供bash环境下的命令自动完成功能
- 自动生成应用程序的帮助手册
- 支持命令行别名
- 自定义帮助和使用信息
- 可与viper配置库紧密结合

Cobra基本应用步骤分为如下3步:
1. 创建rootCmd主命令，并定义Run执行函数（注意，此处是定义Run函数而非直接执行该函数）, 也可以通过rootCmd.AddCommand方法添加子命令
1. 为命令添加命令行参数（Flag）
1. 执行rootCmd命令调用的函数，rootCmd.Execute会在内部回调Run执行函数

在Kubernetes系统中，Cobra被广泛使用，Kubernetes核心组件（kube-apiserver、kube-controller-manager、kube-scheduler、kubelet等）都通过Cobra来管理CLI交互方式. Kubernetes组件使用Cobra的方式类似.

kubectl CLI命令行结构分别为Command、TYPE、NAME及Flag，分别介绍如下
- Command ：指定命令操作，例如create、get、describe、delete等。命令后面也可以加子命令，例如kubectl config view
- TYPE ：指定资源类型，例如pod、pods、rc等。**资源类型不区分大小写**
- NAME ：指定资源名称，可指定多个，例如name1 name2. **资源名称需要区分大小写**
- Flag ：指定可选命令行参数，例如-n命令行参数用于指定不同的命名空间

同样，在Kubernetes中，Cobra的应用步骤也分为3步：
1. 创建Command

    实例化cobra.Command对象，并通过cmds.AddCommand方法添加命令或子命令。每个cobra.Command对象都可设置Run执行函数.

    [NewKubectlCommand](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/cmd.go#L469)函数实例化了cobra.Command对象，templates.CommandGroups定义了kubectl的8种命令类别，即基础命令（初级）、基础命令（中级）、部署命令、集群管理命令、故障排查和调试命令、高级命令及设置命令，最后通过cmds.AddCommand函数添加第8种命令类别——其他命令.

    以[get命令的Command定义(`get.NewCmdGet()`)](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/cmd.go#L555)为例.

    在cobra.Command对象中，Use、Short、Long和Example包含描述命令的信息，其中最重要的是定义了Run执行函数. Run执行函数中定义了get命令的实现. Cobra中的Run函数家族成员有很多，在Run函数之前调用（PreRun）或之后调用（PostRun）. 它们的执行顺序为`PersistentPreRun→PreRun→Run→PostRun→PersistentPostRun.`

1. 为get命令添加命令行参数

    get命令下支持的命令行参数较多，[以--all-namespaces参数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/get/get.go#L182)为例:
    ```go
    cmd.Flags().BoolVarP(&o.AllNamespaces, "all-namespaces", "A", o.AllNamespaces, "If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.")
    ```

    cmd.Flags实现了命令行参数的解析：第1个参数，接收命令行参数的变量；第2个参数，指定命令行参数的名称；第3个参数，指定命令行参数的名称简写；第4个参数，设置命令行参数的默认值；第5个参数，设置命令行参数的提示信息.

1. 执行命令

    kubectl的main函数中定义了执行函数[command.Execute](https://github.com/kubernetes/kubernetes/blob/master/cmd/kubectl/kubectl.go#L49)，原理是对命令行中的所有参数解析出Command和Flag，把Flag作为参数传递给Command并执行.

## 创建资源对象的过程
在Kubernetes系统中创建资源对象有很多种方法, 这里以kubectl create命令创建Deployment资源对象的过程进行分析.

![](/misc/img/container/k8s/kubectl-crreate-deployment.jpg)

使用kubectl创建资源对象是Kubernetes中最常见的操作之一，内部运行原理是客户端与服务端进行一次HTTP请求的交互. Kubernetes整个系统架构的设计方向是通用和具有高扩展性，所以以上功能在代码实现上略微复杂.

创建资源对象的流程可分为：实例化Factory接口、通过Builder和Visitor将资源对象描述文件（deployment.yaml）文本格式转换成资源对象。将资源对象以HTTP请求的方式发送给kube-apiserver，并得到响应结果。最终根据Visitor匿名函数集的errors判断是否成功创建了资源对象.

### 1. 编写资源对象描述文件
Kubernetes系统的资源对象可以使用JSON或YAML文件来描述，一般使用YAML文件居多, 个人认为它在可读性上比yaml清晰.

```yaml
# from https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

通过kubectl create命令与kube-apiserver交互并创建资源对象, 命令是`kubectl create -f deployment.yaml`

### 2. 实例化Factory接口
在执行每一个kubectl命令之前，都需要[执行实例化cmdutil Factory接口对象的操作](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/cmd.go#L527). Factory是一个通用对象，它提供了与kube-apiserver的交互方式，以及验证资源对象等方法.

cmdutil Factory接口说明:
- DynamicClient ：动态客户端
- KubernetesClientSet ：ClientSet客户端
- RESTClient ：RESTClient客户端
- NewBuilder ：实例化Builder，Builder用于将命令行获取的参数转换成资源对象
- Validator ：验证资源对象

cmdutil Factory接口封装了3种client-go客户端与kube-apiserver交互的方式, 它们各有不同的应用场景，分别是DynamicClient、KubernetesClientSet（简称ClientSet）及RESTClient.

### 3. Builder构建资源对象

Builder用于将命令行获取的参数转换成资源对象（Resource Object）. 它实现了一种通用的资源对象转换功能. Builder结构体保存了命令行获取的各种参数，并通过不同函数处理不同参数，将其转换成资源对象. Builder的实现类似于Builder建造者设计模式，提供了一种实例化对象的最佳方式.

首先通过[f.NewBuilder](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/create/create.go#L252)实例化Builder对象，通过函数Unstructured、Schema、ContinueOnError、NamespaceParam、FilenameParam、LabelSelectorParam、Flatten对参数赋值和初始化，将参数保存到Builder对象中。最后通过Do函数完成对资源的创建

其中，FilenameParam函数用于识别kubectl create命令行参数是通过哪种方式传入资源对象描述文件的.

    kubectl目前支持3种方式:
    1. 标准输入Stdin（即cat deployment.yaml|kubectl create-f-）
    1. 本地文件（即kubectl create-f deployment.yaml）
    1. 网络文件（即kubectl create-f http://<host>/deployment.yaml）

Do函数返回Result对象，Result对象的info字段保存了RESTClient与kube-apiserver交互产生的结果, 可以通过Result对象的Infos或Object方法来获取执行结果。而Result对象中的结果，是由Visitor执行产生的.

### 4. Visitor多层匿名函数嵌套

在Builder Do函数中，Result对象中的结果由Visitor执行并产生，Visitor的设计模式类似于Visitor访问者模式.

[Visitor接口](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/interfaces.go#L94)包含Visit方法，实现了Visit（VisitorFunc） error的结构体都可以成为Visitor. 其中，VisitorFunc是一个匿名函数，它接收Info与error信息，Info结构用于存储RESTClient请求的返回结果，而VisitorFunc匿名函数则生成或处理Info结构.

Visitor的设计较为复杂，并非单纯实现了访问者模式，它相当于一个匿名函数集. 在Kubernetes源码中，Visitor被设计为可以多层嵌套（即多层匿名函数嵌套，使用一个Visitor嵌套另一个Visitor）.
![](/misc/img/container/k8s/kubectl_create_visitor.png)

Visitor中的VisitorList（存放Visitor的集合）有两种，定义在vendor/k8s.io/cli-runtime/pkg/resource/visitor.go中:
- EagerVisitorList ：当遍历执行Visitor时，如果遇到错误，则保留错误信息，继续遍历执行下一个Visitor. 最后一起返回所有错误
- VisitorList ：当遍历执行Visitor时，如果遇到错误，则立刻返回

Kubernetes Visitor中[存在多种实现方法](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/visitor.go)，不同实现方法的作用不同:
1. URLVisitor

    资源对象描述文件是网络形式, 该visitor会下载该文件并对内容进行检查, 再通过Streamvisitor将其转成Info对象.
1. FileVisitor

    资源对象描述文件是本地文件, 该visitor会读取该文件并对内容进行检查, 再通过Streamvisitor将其转成Info对象.
1. Streamvisitor

    从io.reader中读取数据, 并将其转成json, 通过schema进行检查, 最后将其转成Info对象.
1. DecoratedVisitor

    提供多种装饰器(decorator)函数, 通过遍历自身的装饰器函数对Info和error进行处理, 如果任意一个装饰器报错, 则终止并返回.

    装饰器函数通过NewDecoratedVisitor进行注册.

    DecoratedVisitor会执行注册过的VisitorFunc，分别介绍如下:
    - resource.SetNamespace ：设置命名空间（Namespace），确保每个Info对象都有命名空间
    - resource.RequireNamespace ：设置命名空间，并检查资源对象描述文件中提供的命名空间与命令行参数（--namespace）提供的命名空间是否相符，如果不相符则返回错误
    - resource.FilterNamespace ：如果Info对象不在命名空间范围内，会忽略命名空间
    - resource.RetrieveLazy ：如果info.Object为空，则根据info的Namepsace和Name等字段调用Helper获取obj，并更新info的Object字段

1. ContinueOnErrorVisitor

    在执行多层Visitor匿名函数时, 如果一个错误或多个错误, 则不会返回和退出, 而是将执行过程中所产生的错误收集到error数组中并聚合成一条error信息返回
1. FlattenListVisitor

    将通用资源类型(runtime.Object)转成Info对象
1. KustomizeVisitor

    从kustomize中获取资源对象描述文件, 然后将其交给StreamVisitor, 并转成Info对象
1. FilteredVisitor

    通过filters函数检查Info是否满足某些条件. 如果满足则继续执行; 否则返回error信息. filters通过NewFilteredVisitor进行注册.


回到上面`kubectl create`操作上. 由result.Visit执行createAndRefresh：
1. 通过Helper.Create向kube-apiserver发送创建资源的请求，Helper对client-go的RESTClient进行了封装，在此基础上实现了Get、List、Watch、Delete、Create、Patch、Replace等方法，实现了与kube-apiserver的交互功能
1. 将与kube-apiserver交互后得到的结果通过info.Refresh函数更新到info.Object中
1. 最后逐个退出Visitor，其过程为DecoratedVisitor→ContinueOnErrorVisitor → FlattenListVisitor → FlattenListVisitor → StreamVisitor →FileVisitor→EagerVisitorList

最终根据Visitor的error信息为空判断创建资源请求执行成功

# client-go
参考:
- [client-go 源码学习总结](https://cloudnative.to/blog/client-go-study/)

Kubernetes系统使用client-go作为Go语言的官方编程式交互客户端库，提供对Kubernetes API Server服务的交互访问, 开发者常使用client-go基于Kubernetes做二次开发. Kubernetes的源码中已经集成了client-go的源码，路径为vendor/k8s.io/client-go.

client-go源码目录结构说明:
- discovery: 提供 DiscoveryClient 发现客户端
- dynamic: 提供 DynamicClient 动态客户端
- informers: 每种 K8S 资源的 Informer 实现
- kubernetes: 提供 ClientSet 客户端
- listers: 为每一个 K8S 资源提供 Lister 功能，该功能对 Get 和 List 请求提供只读的缓存数据
- plugin: 提供 OpenStack，GCP 和 Azure 等云服务商授权插件
- rest: 提供 RESTClient 客户端，对 K8S API Server 执行 RESTful 操作
- scale: 提供 ScaleClient 客户端，用于扩容或缩容 Deployment, Replicaset, Replication Controller 等资源对象
- tools: 提供常用工具，例如 SharedInformer, Reflector, DeltaFIFO 及 Indexers。 提供 Client 查询和缓存机制，以减少向 kube-apiserver 发起的请求数等. 主要子目录为/tools/cache.
- transport: 提供安全的 TCP 连接，支持 HTTP Stream，某些操作需要在客户端和容器之间传输二进制流，例如 exec，attach 等操作。该功能由内部的 SPDY 包提供支持
- util: 提供常用方法, 例如 WorkQueue 工作队列，Certificate 证书管理等

client-go支持4种Client客户端对象, 都可以通过kubeconfig配置信息连接到指定的Kubernetes API Server进行交互:
1. RESTClient是最基础的客户端

    对HTTP Request进行了封装，实现了RESTful风格的API. ClientSet、DynamicClient及DiscoveryClient客户端都是基于RESTClient实现的.

1. ClientSet在RESTClient的基础上封装了对Resource和Version的管理方法

    每一个Resource可以理解为一个客户端，而ClientSet则是多个客户端的集合，每一个Resource和Version都以函数的方式暴露给开发者. ClientSet只能够处理Kubernetes内置资源，它是通过client-gen代码生成器自动生成的.
1. DynamicClient与ClientSet最大的不同之处是，ClientSet仅能访问Kubernetes自带的资源（即Client集合内的资源），不能直接访问CRD自定义资源. 

    DynamicClient能够处理Kubernetes中的所有资源对象，包括Kubernetes内置资源与CRD自定义资源, 请求的返回结果是`map[string]interface{}`

1. DiscoveryClient发现客户端，用于发现kube-apiserver所支持的资源组、资源版本、资源信息（即Group、Versions、Resources）

### kubeconfig配置管理
kubeconfig用于管理访问kube-apiserver的配置信息，同时也支持访问多kube-apiserver的配置管理，可以在不同的环境下管理不同的kube-apiserver集群配置，不同的业务线也可以拥有不同的集群. Kubernetes的其他组件都使用kubeconfig配置信息来连接kube-apiserver组件，例如当kubectl访问kube-apiserver时，会默认加载kubeconfig配置信息.

kubeconfig中存储了集群、用户、命名空间和身份验证等信息，在默认的情况下，kubeconfig存放在$HOME/.kube/config路径下.

kubeconfig配置信息通常包含3个部分:
- clusters ：定义Kubernetes集群信息，例如kube-apiserver的服务地址及集群的证书信息等
- users ：定义Kubernetes集群用户身份验证的客户端凭据，例如client-certificate、client-key、token及username/password等
- contexts ：定义Kubernetes集群用户信息和命名空间等，用于将请求发送到指定的集群

client-go会读取kubeconfig配置信息并生成config对象，用于与kube-apiserver通信.

clientcmd.BuildConfigFromFlags函数会读取kubeconfig配置信息并实例化rest.Config对象. 其中kubeconfig最核心的功能是管理多个访问kube-apiserver集群的配置信息，将多个配置信息合并（merge）成一份，在合并的过程中会解决多个配置文件字段冲突的问题, 该过程由[Load函数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/clientcmd/loader.go#L174)完成，可分为两步：
1. 加载kubeconfig配置信息
    
    有两种方式可以获取kubeconfig配置信息路径：
    1. 文件路径（即rules.ExplicitPath）
    1. 环境变量（通过KUBECONFIG变量，即rules.Precedence，可指定多个路径）

    最后将配置信息汇总到kubeConfigFiles中. 这两种方式都通过[LoadFromFile](https://github.com/kubernetes/kubernetes/blob/27c89b9aec73f66529a497910c460af2b25ab6dd/staging/src/k8s.io/client-go/tools/clientcmd/loader.go#L363)函数读取数据并把读取到的数据反序列化到Config对象中
1. 合并多个kubeconfig配置信息

    [mergo.Merge](https://github.com/kubernetes/kubernetes/blob/master/vendor/github.com/imdario/mergo/merge.go#L198)函数将src字段填充到dst结构中，私有字段除外，非空的dst字段将被覆盖。另外，dst和src必须拥有有效的相同类型结构.

### RESTClient客户端
RESTClient是最基础的客户端. 其他的ClientSet、DynamicClient及DiscoveryClient都是基于RESTClient实现的. RESTClient对HTTP Request进行了封装，实现了RESTful风格的API. 它具有很高的灵活性，数据不依赖于方法和资源，因此RESTClient能够处理多种类型的调用，返回不同的数据格式.

rest.RESTClientFor函数通过kubeconfig配置信息实例化RESTClient对象，RESTClient对象构建HTTP请求参数，例如Get函数设置请求方法为get操作，它还支持Post、Put、Delete、Patch等请求方法, Namespace函数设置请求的命名空间, Resource函数设置请求的资源名称, VersionedParams函数将一些查询选项（如limit、TimeoutSeconds等）添加到请求参数中. 通过Do函数执行该请求，并将kube-apiserver返回的结果（Result对象）解析到目标对象中, 最终格式化输出结果.

RESTClient发送请求的过程对Go语言标准库net/http进行了封装，由Do→request函数实现.

请求发送之前需要根据请求参数生成请求的RESTful URL，由r.URL.String函数完成。例如，在RESTClient Example代码示例中，根据请求参数生成请求的RESTful URL为http://127.0.01：8080/api/v1/namespaces/default/pods？limit=500，其中api参数为v1，namespace参数为default，请求的资源为pods，limit参数表示最多检索出500条信息.

最后通过Go语言标准库net/http向RESTful URL（即kube-apiserver）发送请求，请求得到的结果存放在http.Response的Body对象中，fn函数（即transformResponse）将结果转换为资源对象. 当函数退出时，会通过resp.Body.Close命令进行关闭，防止内存溢出.

其他例子:
```go
package main

import (
    "fmt"

    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/kubernetes/scheme"
    "k8s.io/client-go/rest"
    "k8s.io/client-go/tools/clientcmd"
)

func main() {
    config, err := clientcmd.BuildConfigFromFlags("", "/root/.kube/config")
    if err != nil {
        panic(err.Error())
    }

    config.APIPath = "api"
    config.GroupVersion = &corev1.SchemeGroupVersion
    config.NegotiatedSerializer = scheme.Codecs

    restClient, err := rest.RESTClientFor(config)
    if err != nil {
        panic(err.Error())
    }

    result := &corev1.NodeList{}
    err = restClient.Get().Namespace("").Resource("nodes").VersionedParams(&metav1.ListOptions{Limit: 100}, scheme.ParameterCodec).Do().Into(result)
    if err != nil {
        panic(err)
    }

    for _, d := range result.Items {
        fmt.Printf("Node Name %v \n", d.Name)
    }
}
```
上例将会打印K8S集群中的node.

### ClientSet客户端
RESTClient是一种最基础的客户端，使用时需要指定Resource和Version等信息，编写代码时需要提前知道Resource所在的Group和对应的Version信息. 相比RESTClient，ClientSet使用起来更加便捷，一般情况下，开发者对Kubernetes进行二次开发时通常使用ClientSet.

ClientSet在RESTClient的基础上封装了对Resource和Version的管理方法。每一个Resource可以理解为一个客户端，而ClientSet则是多个客户端的集合，每一个Resource和Version都以函数的方式暴露给开发者，例如，ClientSet提供的RbacV1、CoreV1、NetworkingV1等接口函数.

注意 ：ClientSet仅能访问Kubernetes自身内置的资源（即客户端集合内的资源），不能直接访问CRD自定义资源。如果需要ClientSet访问CRD自定义资源，可以通过client-gen代码生成器重新生成ClientSet，在ClientSet集合中自动生成与CRD操作相关的接口.

通过ClientSet列出所有运行中的Pod资源对象的example见[这里](https://github.com/kubernetes/client-go/blob/master/examples/out-of-cluster-client-configuration/main.go).

上例中, 首先加载kubeconfig配置信息，kubernetes.NewForConfig通过kubeconfig配置信息实例化clientset对象，该对象用于管理所有Resource的客户端.

其次, `clientset.CoreV1().Pods`函数表示请求core核心资源组的v1资源版本下的Pod资源对象，其内部设置了APIPath请求的HTTP路径，GroupVersion请求的资源组、资源版本，NegotiatedSerializer数据的编解码器. 其中，Pods函数是一个资源接口对象，用于Pod资源对象的管理，例如，对Pod资源执行Create、Update、Delete、Get、List、Watch、Patch等操作，这些操作实际上是对RESTClient进行了封装，可以设置选项（如Limit、TimeoutSeconds等）. `clientset.CoreV1().Pods().List`函数通过RESTClient获得Pod列表.

其他例子:
```go
package main

import (
    apiv1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/kubernetes"
    "k8s.io/client-go/tools/clientcmd"
)

func main() {
    config, err := clientcmd.BuildConfigFromFlags("", "/root/.kube/config")
    if err != nil {
        panic(err)
    }
    clientset, err := kubernetes.NewForConfig(config)
    if err != nil {
        panic(err)
    }

    podClient := clientset.CoreV1().Pods(apiv1.NamespaceDefault)

    list, err := podClient.List(metav1.ListOptions{Limit: 500})
    if err != nil {
        panic(err)
    }
    for _, d := range list.Items {
        if d.Name == "" {
        }
        // fmt.Printf("NAME:%v \t NAME:%v \t STATUS: %+v\n ", d.Namespace, d.Name, d.Status)
    }

    //请求namespace为default下的deploy
    deploymentClient := clientset.AppsV1().Deployments(apiv1.NamespaceDefault)
    deployList, err2 := deploymentClient.List(metav1.ListOptions{Limit: 500})
    if err2 != nil {
        panic(err2)
    }
    for _, d := range deployList.Items {
        if d.Name == "" {

        }
        // fmt.Printf("NAME:%v \t NAME:%v \t STATUS: %+v\n ", d.Namespace, d.Name, d.Status)
    }

    // 请求ds资源 todo  有兴趣可以尝试下
    // clientset.AppsV1().DaemonSets()

}
```

代码中分别打印了获取到K8S集群中的500个Pod和500个deploy.

### DynamicClient客户端

DynamicClient是一种动态客户端，它可以对任意Kubernetes资源进行RESTful操作，包括CRD自定义资源. DynamicClient与ClientSet操作类似，同样封装了RESTClient，同样提供了Create、Update、Delete、Get、List、Watch、Patch等方法.

DynamicClient与ClientSet最大的不同之处是，ClientSet仅能访问Kubernetes自带的资源（即客户端集合内的资源），不能直接访问CRD自定义资源. ClientSet需要预先实现每种Resource和Version的操作，其内部的数据都是结构化数据（即已知数据结构）. 而DynamicClient内部实现了Unstructured，用于处理非结构化数据结构（即无法提前预知数据结构），这也是DynamicClient能够处理CRD自定义资源的关键.

> 注意 ：DynamicClient不是类型安全的，因此在访问CRD自定义资源时需要特别注意, 例如，在操作指针不当的情况下可能会导致程序崩溃.

DynamicClient的处理过程将Resource（例如PodList）转换成Unstructured结构类型，Kubernetes的所有Resource都可以转换为该结构类型. 处理完成后，再将Unstructured转换成PodList. 整个过程类似于Go语言的interface{}断言转换过程. 另外，Unstructured结构类型是通过map[string]interface{}转换的.

通过DynamicClient列出所有deployment资源对象的example见[这里](https://github.com/kubernetes/client-go/blob/master/examples/dynamic-create-update-delete-deployment/main.go).

它首先加载kubeconfig配置信息，dynamic.NewForConfig通过kubeconfig配置信息实例化dynamicClient对象，该对象用于管理Kubernetes的所有Resource的客户端，例如对Resource执行Create、Update、Delete、Get、List、Watch、Patch等操作.

`dynamicClient.Resource(gvr)`函数用于设置请求的资源组、资源版本、资源名称, Namespace函数用于设置请求的命名空间, List函数用于获取Pod列表, 得到的Deployment列表为unstructured.UnstructuredList指针类型. 其实该列表然后通过`runtime.DefaultUnstructuredConverter.FromUnstructured(unstructured.UnstructuredList.UnstructedContent(), &v1.DeploymentList{})`函数将unstructured.UnstructuredList转换成DeploymentList类型.


其他例子:
```go
package main

import (
    "fmt"

    apiv1 "k8s.io/api/core/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/runtime"
    "k8s.io/apimachinery/pkg/runtime/schema"
    "k8s.io/client-go/dynamic"
    "k8s.io/client-go/tools/clientcmd"
)

func main() {
    config, err := clientcmd.BuildConfigFromFlags("", "/root/.kube/config")
    if err != nil {
        panic(err)
    }

    dymaicClient, err := dynamic.NewForConfig(config)
    checkErr(err)
    //map[string]interface{}

         //TODO 获取CRD资源 这里是获取了TIDB的CRD资源
    // gvr := schema.GroupVersionResource{Version: "v1alpha1", Resource: "tidbclusters", Group: "pingcap.com"}
    // unstructObj, err := dymaicClient.Resource(gvr).Namespace("tidb-cluster").List(metav1.ListOptions{Limit: 500})
    // checkErr(err)
    // fmt.Println(unstructObj)

    gvr := schema.GroupVersionResource{Version: "v1", Resource: "pods"}
    unstructObj, err := dymaicClient.Resource(gvr).Namespace(apiv1.NamespaceDefault).List(metav1.ListOptions{Limit: 500})
    checkErr(err)
    // fmt.Println(unstructObj)
    podList := &corev1.PodList{}
    err = runtime.DefaultUnstructuredConverter.FromUnstructured(unstructObj.UnstructuredContent(), podList)
    checkErr(err)
    for _, d := range podList.Items {
        fmt.Printf("NAME:%v \t NAME:%v \t STATUS: %+v\n ", d.Namespace, d.Name, d.Status)
    }

}

func checkErr(err error) {
    if err != nil {
        panic(err)
    }
}
```

上案是打印了namespace为default下的500个pod，同样的，在案例中也有一个todo，获取CRD资源，如果K8S集群中没有TIDB的资源可以自行换成自己想要的CRD资源.

代码中已经有获取v1alpha1版本的tidbclusters资源, 如果不知道CRD相关的信息，可以按照下面的步骤来找出对应的信息：
- 通过kubectl api-resources 获取到资源的Group和Resource

    源码: `pkg/kubectl/cmd/apiresources/apiresources.go`
- 通过kubectl api-versions 找到对应Group的版本

    源码: `pkg/kubectl/cmd/apiresources/apiversions.go`

这样 资源的GVR(Group、Version、Resource)都有了, api-resources和api-versions都是通过discoveryClient客户端实现的.

### DiscoveryClient客户端
DiscoveryClient是发现客户端，它主要用于发现Kubernetes API Server所支持的资源组、资源版本、资源信息. Kubernetes API Server支持很多资源组、资源版本、资源信息，开发者在开发过程中很难记住所有信息，此时可以通过DiscoveryClient查看所支持的资源组、资源版本、资源信息.

kubectl的api-versions和api-resources命令输出也是通过DiscoveryClient实现的. 另外，DiscoveryClient同样在RESTClient的基础上进行了封装.

DiscoveryClient除了可以发现Kubernetes API Server所支持的资源组、资源版本、资源信息，还可以将这些信息存储到本地，用于本地缓存（Cache），以减轻对Kubernetes API Server访问的压力。在运行Kubernetes组件的机器上，缓存信息默认存储位置是~/.kube/cache和~/.kube/http-cache下,默认是每10分钟会和API Server同步一次.

DiscoveryClient Example代码示例如下：
```go
package main

import (
    "fmt"
    "k8s.io/apimachinery/pkg/runtime/schema"
    "k8s.io/client-go/discovery"
    "k8s.io/client-go/tools/clientcmd"
)

func main()  {
    config, err := clientcmd.BuildConfigFromFlags("","/root/.kube/config")
    if err != nil {
        panic(err.Error())
    }

    discoveryClient, err := discovery.NewDiscoveryClientForConfig(config) # 通过kubeconfig配置信息实例化discoveryClient对象，该对象是用于发现Kubernetes API Server所支持的资源组、资源版本、资源信息的客户端
    if err != nil {
        panic(err.Error())
    }

    _, APIResourceList, err := discoveryClient.ServerGroupsAndResources() # 返回Kubernetes API Server所支持的资源组、资源版本、资源信息（即APIResourceList）
    if err != nil {
        panic(err.Error())
    }
    for _, list := range APIResourceList {
        gv, err := schema.ParseGroupVersion(list.GroupVersion)
        if err != nil {
            panic(err.Error())
        }
        for _, resource := range list.APIResources {
            fmt.Printf("name: %v, group: %v, version %v\n", resource.Name, gv.Group, gv.Version)
        }
    }
}
```
上例打印了集群中的GVR, 具体细节:
1. 获取Kubernetes API Server所支持的资源组、资源版本、资源信息

    Kubernetes API Server暴露出/api和/apis接口. DiscoveryClient通过RESTClient分别请求/api和/apis接口，从而获取Kubernetes API Server所支持的资源组、资源版本、资源信息. 其核心实现位于ServerGroupsAndResources→[`(*DiscoveryClient).ServerGroups`](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/discovery/discovery_client.go)中.

    首先，DiscoveryClient通过RESTClient请求/api接口，将请求结果存放于metav1.APIVersions结构体中. 然后，再次通过RESTClient请求/apis接口，将请求结果存放于metav1.APIGroupList结构体中. 最后，将/api接口中检索到的资源组信息合并到apiGroupList列表中并返回.
1. [本地缓存的DiscoveryClient](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/discovery/cached/disk/cached_discovery.go#L64)

    DiscoveryClient可以将资源相关信息存储于本地，默认存储位置为～/.kube/cache和～/.kube/http-cache, 缓存可以减轻client-go对Kubernetes API Server的访问压力. 默认每10分钟与Kubernetes API Server同步一次，同步周期较长，因为资源组、源版本、资源信息一般很少变动.

    DiscoveryClient第一次获取资源组、资源版本、资源信息时，首先会查询本地缓存，如果数据不存在（没有命中）则请求Kubernetes API Server接口（回源），Cache将Kubernetes API Server响应的数据存储在本地一份并返回给DiscoveryClient. 当下一次DiscoveryClient再次获取资源信息时，会将数据直接从本地缓存返回（命中）给DiscoveryClient. 本地缓存的默认存储周期为10分钟.

## Informer机制
参考:
- [Kubernetes informer 原理分析](https://segmentfault.com/a/1190000022643082)
- [深入了解 Kubernetes Informer](https://cloudnative.to/blog/client-go-informer-source-code/)

在Kubernetes系统中，Kubernetes的其他组件都是通过client-go的Informer机制以HTTP协议与Kubernetes API Server进行通信的, 可在不依赖任何中间件的情况下需要保证消息的实时性、可靠性、顺序性等.

![arch](https://github.com/kubernetes/sample-controller/blob/master/docs/images/client-go-controller-interaction.jpeg)

在Informer架构设计中，有多个核心组件:
1. Reflector

    Reflector用于监控（Watch）指定的Kubernetes资源，当监控的资源发生变化时，触发相应的变更事件，例如Added（资源添加）事件、Updated（资源更新）事件、Deleted（资源删除）事件，并将其资源对象存放到本地缓存DeltaFIFO中.

2. DeltaFIFO

    DeltaFIFO可以分开理解，FIFO是一个先进先出的队列，它拥有队列操作的基本方法，例如Add、Update、Delete、List、Pop、Close等，而Delta是一个资源对象存储，它可以保存资源对象的操作类型，例如Added（添加）操作类型、Updated（更新）操作类型、Deleted（删除）操作类型、Sync（同步）操作类型等.

3. Indexer

    Indexer是client-go用来存储资源对象并自带索引功能的本地存储，Reflector从DeltaFIFO中将消费出来的资源对象存储至Indexer. Indexer与Etcd集群中的数据完全保持一致. client-go可以很方便地从本地存储中读取相应的资源对象数据，而无须每次从远程Etcd集群中读取，以减轻Kubernetes API Server和Etcd集群的压力.

Informers Example代码示例:
```go
package main

import (
    "log"
    "os"

    "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/client-go/informers"
    "k8s.io/client-go/kubernetes"
    "k8s.io/client-go/tools/cache"
    "k8s.io/client-go/tools/clientcmd"
)

func main() {
    config, err := clientcmd.BuildConfigFromFlags("", "~/.kube/config")
    if err != nil {
        panic(err.Error())
    }

    clientset, err := kubernetes.NewForConfig(config)
    if err != nil {
        panic(err.Error())
    }

    factory := informers.NewSharedInformerFactory(clientset, 0)
    informer := factory.Core().V1().Pods().Informer()

    stopCh := make(chan struct{})
    defer close(stopCh)
    
    informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        AddFunc: func(obj interface{}) {
            // "k8s.io/apimachinery/pkg/apis/meta/v1" provides an Object
            // interface that allows us to get metadata easily
            mObj := obj.(v1.Object)
            log.Printf("New Pod Added to Store: %s", mObj.GetName())
        },
        DeleteFunc: func(obj interface{}) {
            mObj := obj.(v1.Object)
            log.Printf("Pod Deleted from Store: %s", mObj.GetName())
        },
        UpdateFunc: func(oldObj, newObj interface{}) {
            oObj := oldObj.(v1.Object)
            nObj := newObj.(v1.Object)
            log.Printf("%s Pod Updated to %s", oObj.GetName(), mObj.GetName())
        },
    })

    informer.Run(stopCh)
}
```

上例首先通过kubernetes.NewForConfig创建clientset对象，Informer需要通过ClientSet与Kubernetes API Server进行交互.

另外，创建stopCh对象，该对象用于在程序进程退出之前通知Informer提前退出，因为Informer是一个持久运行的goroutine.

informers.NewSharedInformerFactory函数实例化了SharedInformer对象，它接收两个参数：第1个参数clientset是用于与Kubernetes API Server交互的客户端，第2个参数time.Minute用于设置多久进行一次resync（重新同步），resync会周期性地执行List操作，将所有的资源存放在Informer Store中，如果该参数为0，则禁用resync功能.

在Informers Example代码示例中，通过`factory.Core().V1().Pods().Informer()`可以得到具体Pod资源的informer对象. 通过informer.AddEventHandler函数可以为Pod资源添加资源事件回调方法，支持3种资源事件回调方法:
1. AddFunc ：当创建Pod资源对象时触发的事件回调方法
1. UpdateFunc ：当更新Pod资源对象时触发的事件回调方法
1. DeleteFunc ：当删除Pod资源对象时触发的事件回调方法

在正常的情况下，Kubernetes的其他组件在使用Informer机制时触发资源事件回调方法，将资源对象推送到WorkQueue或其他队列中，在Informers Example代码示例中，我们直接输出触发的资源事件。最后通过informer.Run函数运行当前的Informer，内部为Pod资源类型创建Informer.

通过Informer机制可以很容易地监控我们所关心的资源事件，例如，当监控Kubernetes Pod资源时，如果Pod资源发生了Added（资源添加）事件、Updated（资源更新）事件、Deleted（资源删除）事件，就通知client-go，告知Kubernetes资源事件变更了并且需要进行相应的处理.

1. 资源Informer
每一个Kubernetes资源上都实现了Informer机制. 每一个Informer上都会实现Informer和Lister方法，例如PodInformer的在[这](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/core/v1/pod.go#PodInformer).

定义不同资源的Informer，允许监控不同资源的资源事件，例如，监听Node资源对象，当Kubernetes集群中有新的节点（Node）加入时，client-go能够及时收到资源对象的变更信息.

2. Shared Informer共享机制

Informer也被称为Shared Informer，它是可以共享使用的. 在用client-go编写代码程序时，若同一资源的Informer被实例化了多次，每个Informer使用一个Reflector，那么会运行过多相同的ListAndWatch，太多重复的序列化和反序列化操作会导致Kubernetes API Server负载过重.

Shared Informer可以使同一类资源Informer共享一个Reflector，这样可以节约很多资源. 通过map数据结构实现共享的Informer机制. Shared Informer定义了一个map数据结构，用于存放所有Informer的字段.

[informers字段](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go#L63)中存储了资源类型和对应于SharedIndexInformer的映射关系. InformerFor函数添加了不同资源的Informer，在添加过程中如果已经存在同类型的资源Informer，则返回当前Informer，不再继续添加.

最后通过Shared Informer的Start方法使f.informers中的每个informer通过goroutine持久运行.

### Reflector
Informer可以对Kubernetes API Server的资源执行监控（Watch）操作，资源类型可以是Kubernetes内置资源，也可以是CRD自定义资源，其中最核心的功能是Reflector. Reflector用于监控指定资源的Kubernetes资源，当监控的资源发生变化时，触发相应的变更事件，例如Added（资源添加）事件、Updated（资源更新）事件、Deleted（资源删除）事件，并将其资源对象存放到本地缓存DeltaFIFO中.

通过NewReflector实例化Reflector对象，实例化过程中须传入ListerWatcher数据接口对象，它拥有List和Watch方法，用于获取及监控资源列表. 只要实现了List和Watch方法的对象都可以称为ListerWatcher。Reflector对象通过Run函数启动监控并处理监控事件. 而在Reflector源码实现中，其中最主要的是ListAndWatch函数，它负责获取资源列表（List）和监控（Watch）指定的Kubernetes API Server资源.

[ListAndWatch](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/reflector.go#L254)函数实现可分为两部分：
1. 获取资源列表数据

    ListAndWatch List在程序第一次运行时获取该资源下所有的对象数据并将其存储至DeltaFIFO中. 以Informers Example代码示例为例，在其中，获取的是所有Pod的资源数据. ListAndWatch List流程图:

    1. r.listerWatcher.List用于获取资源下的所有对象的数据，例如，获取所有Pod的资源数据。获取资源数据是由options的ResourceVersion（资源版本1. 参数控制的，如果ResourceVersion为0，则表示获取所有Pod的资源数据；如果ResourceVersion非0，则表示根据资源版本号继续获取，功能有些类似于文件传输过程中的“断点续传”，当传输过程中遇到网络故障导致中断，下次再连接时，会根据资源版本号继续传输未完成的部分。可以使本地缓存中的数据与Etcd集群中的数据保持一致

        [r.listerWatcher.List函数实际调用了Pod Informer下的ListFunc函数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/core/v1/pod.go#L65)，它通过ClientSet客户端与Kubernetes API Server交互并获取Pod资源列表数据.
    1. listMetaInterface.GetResourceVersion用于获取资源版本号，ResourceVersion （资源版本号）非常重要，Kubernetes中所有的资源都拥有该字段，它标识当前资源对象的版本号。每次修改当前资源对象时，Kubernetes API Server都会更改ResourceVersion，使得client-go执行Watch操作时可以根据ResourceVersion来确定当前资源对象是否发生变化。更多关于ResourceVersion资源版本号的内容，请参考6.5.2节“ResourceVersion资源版本号”
    1. meta.ExtractList用于将资源数据转换成资源对象列表，将runtime.Object对象转换成[]runtime.Object对象。因为r.listerWatcher.List获取的是资源下的所有对象的数据，例如所有的Pod资源数据，所以它是一个资源列表
    1. r.syncWith用于将资源对象列表中的资源对象和资源版本号存储至DeltaFIFO中，并会替换已存在的对象
    1. r.setLastSyncResourceVersion用于设置最新的资源版本号

1. 监控资源对象

    Watch（监控）操作通过HTTP协议与Kubernetes API Server建立长连接，接收Kubernetes API Server发来的资源变更事件. Watch操作的实现机制使用HTTP协议的分块传输编码（Chunked Transfer Encoding）. 当client-go调用Kubernetes API Server时，Kubernetes API Server在Response的HTTP Header中设置Transfer-Encoding的值为chunked，表示采用分块传输编码，客户端收到该信息后，便与服务端进行连接，并等待下一个数据块（即资源的事件信息）.

    [r.listerWatcher.Watch](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/reflector.go#L414)函数实际调用了[Pod Informer下的WatchFunc函数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/core/v1/pod.go#L71)，它通过ClientSet客户端与Kubernetes API Server建立长连接，监控指定资源的变更事件.

    [r.watchHandler](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/reflector.go#L454)用于处理资源的变更事件。当触发Added（资源添加）事件、Updated （资源更新）事件、Deleted（资源删除）事件时，将对应的资源对象更新到本地缓存DeltaFIFO中并更新ResourceVersion资源版本号.

### DeltaFIFO
[DeltaFIFO](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/delta_fifo.go#L159)可以分开理解，FIFO是一个先进先出的队列，它拥有队列操作的基本方法，例如Add、Update、Delete、List、Pop、Close等，而Delta是一个资源对象存储，它可以保存资源对象的操作类型，例如Added（添加）操作类型、Updated（更新）操作类型、Deleted（删除）操作类型、Sync（同步）操作类型等.

DeltaFIFO与其他队列最大的不同之处是，它会保留所有关于资源对象（obj）的操作类型，队列中会存在拥有不同操作类型的同一个资源对象，消费者在处理该资源对象时能够了解该资源对象所发生的事情. queue字段存储资源对象的key，该key通过KeyOf函数计算得到. items字段通过map数据结构的方式存储，value存储的是对象的Deltas数组.

DeltaFIFO本质上是一个先进先出的队列，有数据的生产者和消费者，其中生产者是Reflector调用的Add方法，消费者是Controller调用的Pop方法. 下面分析DeltaFIFO的核心功能：
- 生产者方法

    DeltaFIFO队列中的资源对象在Added（资源添加）事件、Updated（资源更新）事件、Deleted（资源删除）事件中都调用了[queueActionLocked函数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/delta_fifo.go#L412)，它是DeltaFIFO实现的关键.

    queueActionLocked代码执行流程如下:
    1. 通过f.KeyOf函数计算出资源对象的key
    1. 如果操作类型为Sync，则标识该数据来源于Indexer（本地存储）。如果Indexer中的资源对象已经被删除，则直接返回
    1. 将actionType和资源对象构造成Delta，添加到items中，并通过dedupDeltas函数进行去重操作
    1. 更新构造后的Delta并通过cond.Broadcast通知所有消费者解除阻塞

- 消费者方法

    [Pop方法](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/delta_fifo.go#L518)作为消费者方法使用，从DeltaFIFO的头部取出最早进入队列中的资源对象数据。Pop方法须传入process函数，用于接收并处理对象的回调方法.

    当队列中没有数据时，通过f.cond.wait阻塞等待数据，只有收到cond.Broadcast时才说明有数据被添加，解除当前阻塞状态. 如果队列中不为空，取出f.queue的头部数据，将该对象传入process回调函数，由上层消费者进行处理. 如果process回调函数处理出错，则将该对象重新存入队列. 

    Controller的processLoop方法负责从DeltaFIFO队列中取出数据传递给[process回调函数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/shared_informer.go#L527).
- Resync机制

    Resync机制会将Indexer本地存储中的资源对象同步到DeltaFIFO中，并将这些资源对象设置为Sync的操作类型. Resync函数在Reflector中定时执行，它的执行周期由NewReflector函数传入的resyncPeriod参数设定. Resync→[syncKeyLocked](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/delta_fifo.go#L668).

    f.knownObjects是Indexer本地存储对象，通过该对象可以获取client-go目前存储的所有资源对象，Indexer对象在NewDeltaFIFO函数实例化DeltaFIFO对象时传入.

### Indexer
Indexer是client-go用来存储资源对象并自带索引功能的本地存储，Reflector从DeltaFIFO中将消费出来的资源对象存储至Indexer. Indexer中的数据与Etcd集群中的数据保持完全一致. client-go可以很方便地从本地存储中读取相应的资源对象数据，而无须每次都从远程Etcd集群中读取，这样可以减轻Kubernetes API Server和Etcd集群的压力.

在介绍Indexer之前，先介绍一下ThreadSafeMap. ThreadSafeMap是实现并发安全的存储. 作为存储，它拥有存储相关的增、删、改、查操作方法，例如Add、Update、Delete、List、Get、Replace、Resync等. Indexer在ThreadSafeMap的基础上进行了封装，它继承了与ThreadSafeMap相关的操作方法并实现了Indexer Func等功能，例如Index、IndexKeys、GetIndexers等方法，这些方法为ThreadSafeMap提供了索引功能.

1. ThreadSafeMap并发安全存储

    [ThreadSafeMap]()是一个内存中的存储，其中的数据并不会写入本地磁盘中，每次的增、删、改、查操作都会加锁，以保证数据的一致性. ThreadSafeMap将资源对象数据存储于一个名为items的map中.

    [items字段](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go#L65)中存储的是资源对象数据，其中items的key通过keyFunc函数计算得到，计算默认使用MetaNamespaceKeyFunc函数，该函数根据资源对象计算出<namespace>/<name>格式的key，如果资源对象的<namespace>为空，则<name>作为key，而items的value用于存储资源对象.
2. Indexer索引器

    在每次增、删、改ThreadSafeMap数据时，都会通过updateIndices或deleteFromIndices函数变更Indexer. Indexer被设计为可以自定义索引函数，这符合Kubernetes高扩展性的特点。Indexer有4个非常重要的数据结构，分别是Indices、Index、Indexers及IndexFunc.


    Indexer Example代码示例:
    ```go
    package main

    import (
        "fmt"
        "strings"

        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/tools/cache"
    )

    func UsersIndexFunc(obj interface{})[[]string, error]{
        pod := obj.(*v1.Pod)
        usersString := pod.Annotations["users"]

        return strings.Split(usersString, ","), nil
    }

    func main() {
        index := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{"byUser", UsersIndexFunc}

        pod1 := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "one", Annotations: map[string]string{"users": "ernie,bert"}}}
        pod2 := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "two", Annotations: map[string]string{"users": "bert,oscar"}}}
        pod3 := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "tre", Annotations: map[string]string{"users": "ernie,elmo"}}}

        index.Add(pod1)
        index.Add(pod2)
        index.Add(pod3)

        erniePods, err := index.ByIndex("byUser", "ernie")
        if err != nil {
            panic(err)
        }

        for _, erniePod := range erniePods {
            fmt.Println(erniePod.(*v1.Pod).Name)
        }

        // output:
        // one
        // tre
    }
    ```

    首先定义一个索引器函数UsersIndexFunc，在该函数中，我们定义查询出所有Pod资源下Annotations字段的key为users的Pod.

    cache.NewIndexer函数实例化了Indexer对象，该函数接收两个参数：第1个参数是KeyFunc，它用于计算资源对象的key，计算默认使用cache.MetaNamespaceKeyFunc函数；第2个参数是cache.Indexers，用于定义索引器，其中key为索引器的名称（即byUser），value为索引器。通过index.Add函数添加3个Pod资源对象。最后通过index.ByIndex函数查询byUser索引器下匹配ernie字段的Pod列表。Indexer Example代码示例最终检索出名称为one和tre的Pod.

    根据上例理解Indexer的4个重要的数据结构就非常容易了，它们分别是[Indexers、IndexFunc、Indices、Index](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/index.go#L65).

    Indexer数据结构说明如下:
    - Indexers ：存储索引器，key为索引器名称，value为索引器的实现函数
    - IndexFunc ：索引器函数，定义为接收一个资源对象，返回检索结果列表
    - Indices ：存储缓存器，key为缓存器名称（在Indexer Example代码示例中，缓存器命名与索引器命名相对应），value为缓存数据
    - Index ：存储缓存数据，其结构为K/V
3. Indexer索引器核心实现

    [index.ByIndex函数](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go#L180)通过执行索引器函数得到索引结果.

    ByIndex接收两个参数：IndexName（索引器名称）和indexKey（需要检索的key）。首先从c.indexers中查找指定的索引器函数，从c.indices中查找指定的缓存器函数，然后根据需要检索的indexKey从缓存数据中查到并返回数据

    提示： Index中的缓存数据为Set集合数据结构，Set本质与Slice相同，但Set中不存在相同元素。由于Go语言标准库没有提供Set数据结构，Go语言中的map结构类型是不能存在相同key的，所以Kubernetes将map结构类型的key作为Set数据结构，实现Set去重特性.

## WorkQueue

WorkQueue称为工作队列，Kubernetes的WorkQueue队列与普通FIFO（先进先出，First-In，First-Out）队列相比，实现略显复杂，它的主要功能在于标记和去重，并支持如下特性:
- 有序 ：按照添加顺序处理元素（item）
- 去重 ：相同元素在同一时间不会被重复处理，例如一个元素在处理之前被添加了多次，它只会被处理一次
- 并发性 ：多生产者和多消费者
- 标记机制 ：支持标记功能，标记一个元素是否被处理，也允许元素在处理时重新排队
- 通知机制 ：ShutDown方法通过信号量通知队列不再接收新的元素，并通知metric goroutine退出
- 延迟 ：支持延迟队列，延迟一段时间后再将元素存入队列
- 限速 ：支持限速队列，元素存入队列时进行速率限制。限制一个元素被重新排队（Reenqueued）的次数
- Metric ：支持metric监控指标，可用于Prometheus监控
WorkQueue支持3种队列，并提供了3种接口，不同队列实现可应对不同的使用场景，分别介绍如下
- Interface ：FIFO队列接口，先进先出队列，并支持去重机制
- DelayingInterface ：延迟队列接口，基于Interface接口封装，延迟一段时间后再将元素存入队列
- RateLimitingInterface ：限速队列接口，基于DelayingInterface接口封装，支持元素存入队列时进行速率限制

### FIFO队列
FIFO队列支持最基本的队列方法，例如插入元素、获取元素、获取队列长度等. 另外，WorkQueue中的限速及延迟队列都基于[Interface接口](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/util/workqueue/queue.go#L26)实现.

FIFO队列Interface方法说明如下:
- Add ：给队列添加元素（item），可以是任意类型元素
- Len ：返回当前队列的长度
- Get ：获取队列头部的一个元素
- Done ：标记队列中该元素已被处理
- ShutDown ：关闭队列
- ShuttingDown ：查询队列是否正在关闭

FIFO队列数据结构在[这](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/util/workqueue/queue.go#L71).

FIFO队列数据结构中最主要的字段有queue、dirty和processing。其中queue字段是实际存储元素的地方，它是slice结构的，用于保证元素有序；dirty字段非常关键，除了能保证去重，还能保证在处理一个元素之前哪怕其被添加了多次（并发情况下），但也只会被处理一次；processing字段用于标记机制，标记一个元素是否正在被处理。应根据WorkQueue的特性理解源码的实现.

FIFO存储过程示例:
通过Add方法往FIFO队列中分别插入1、2、3这3个元素，此时队列中的queue和dirty字段分别存有1、2、3元素，processing字段为空。然后通过Get方法获取最先进入的元素（也就是1元素），此时队列中的queue和dirty字段分别存有2、3元素，而1元素会被放入processing字段中，表示该元素正在被处理。最后，当处理完1元素时，通过Done方法标记该元素已经被处理完成，此时队列中的processing字段中的1元素会被删除.

在正常的情况下，FIFO队列运行在并发场景下. 高并发下FIFO会保证在处理一个元素之前哪怕其被添加了多次，但也只会被处理一次. 下面是说明.

在并发场景下，假设goroutine A通过Get方法获取1元素，1元素被添加到processing字段中，同一时间，goroutine B通过Add方法插入另一个1元素，此时在processing字段中已经存在相同的元素，所以后面的1元素并不会被直接添加到queue字段中，当前FIFO队列中的dirty字段中存有1、2、3元素，processing字段存有1元素。在goroutine A通过Done方法标记处理完成后，如果dirty字段中存有1元素，则将1元素追加到queue字段中的尾部。需要注意的是，dirty和processing字段都是用Hash Map数据结构实现的，所以不需要考虑无序，只保证去重即可.