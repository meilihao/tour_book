# rpc
rpc(remote procedure call, 远程调用过程)可像调用本地函数一样通过网络调用远端服务.

组成:
1. client code

    发起rpc调用
1. serialization/deserialization
    
    rpc请求/响应内容的编解码, 分两类
    - 文本

        xml/json
    - 二进制

        probuf, thrift等. 常用的是probuf.
1. stub proxy

    代理对象, 用于屏蔽rpc调用过程中的复杂网络处理逻辑, 使得rpc调用透明化, 保持与本地调用的一致风格.
1. transport

    rpc框架底层通信的传输层, 一般通过socket在client和server间传递req和resp.
1. server code

    服务端业务逻辑的实现

## 序列化协议的需求
参考:
- [序列化和反序列化](https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html)

1. 通用性
通用性有两个层面的意义：

    1. 技术层面: 序列化协议是否支持跨平台、跨语言. 如果不支持，在技术层面上的通用性就大大降低了
    1. 流行程度: 序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包

1. 强健性/鲁棒性

    以下两个方面的原因会导致协议不够强健：
    1. 成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。
    1. 语言/平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定–支持更多人使用的语言/平台，亦或支持更多的语言/平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。

1. 可调试性/可读性

    序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台–这比较费时；另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战–难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。对于跨公司间的调试，由于以下原因，问题会显得更严重：

    1. 支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。
    1. 访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。

    如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点. [XML所产生序列化之后文件的大小接近JSON的两倍](https://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity), 与XML相比，其协议比较简单，解析速度比较快.

1. 性能
    性能包括两个方面，时间复杂度和空间复杂度：
    1. 空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本
    1. 时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈

1. 可扩展性/兼容性

    移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。

1. 安全性/访问限制

    在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于HTTP/HTTPS的80和443端口。如果使用的序列化协议没有兼容而成熟的HTTP传输层框架支持，可能会导致以下三种结果之一：

    1. 因为访问限制而降低服务可用性
    1. 被迫重新实现安全协议而导致实施成本大大提高
    1. 开放更多的防火墙端口和协议访问，而牺牲安全性

### 序列化和反序列化的组件
典型的序列化和反序列化过程往往需要如下组件：

- IDL（Interface description language）文件

    参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）

    为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件
- IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库
- Stub/Skeleton Lib：负责序列化和反序列化的工作代码

    Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。
- Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct
- 底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递

# 分布式服务框架
## 组成
1. 服务提供方

    将自身信息注册到服务注册中心, 其发布的信息一般包括主机地址, 端口, 接口信息等.
1. 服务消费方
    
    从服务注册中心获取必要信息, 再根据某种软负载策略选择一个服务提供分发起rpc调用. 同时它也会将其自身信息上报到服务注册中心
1. 服务注册中心

    存储服务信息
1. 服务治理

    管理大规模的服务依赖关系, 降级和权重调整, 链路追踪, 分组, 负载均衡, 监控

## 设计原则
1. 标准化服务契约 : 服务遵循相同的契约设计标准
1. 服务松散耦合 : 服务契约对服务消费者松耦合, 服务间松耦合
1. 服务抽象: 服务契约只包含必要信息, 并且关于服务的信息局限为服务契约中发布的信息
1. 服务可重用性 : 服务可作为可重用资源
1. 服务自治: 服务对其底层运行时执行环境有很大的控制权
1. 服务无状态: 服务无状态保证了服务部署的横向扩展性
1. 服务可发现性 : 服务可通过描述性元数据发现并解释服务
1. 服务可组合性: 通过组合原子服务实现复杂的上层业务

## 服务拆分原则
合适即可.

## FAQ
### 为什么rpc需要stream
通过模拟业务场景，可得知在使用 Simple RPC 模拟stream时，有如下问题：
- 数据包过大造成的瞬时压力
- 接收数据包时，需要所有数据包都接受成功且正确后，才能够回调响应，进行业务处理（无法客户端边发送，服务端边处理）
### thrift/probuf
Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求. 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架.

于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）.

Protobuf具有广泛的用户基础，空间开销小以及高解析性能是其亮点，非常适合于公司内部的对性能要求高的RPC调用。由于Protobuf提供了标准的IDL以及对应的编译器，其IDL文件是参与各方的非常强的业务约束，另外，Protobuf与传输层无关，采用HTTP具有良好的跨防火墙的访问属性，所以Protobuf也适用于公司间对性能要求比较高的场景。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景.