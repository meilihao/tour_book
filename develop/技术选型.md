# 技术选型
## 压缩 
参考:
- [Benchmarks](https://github.com/facebook/zstd)


  lz4. 依据: zfs压缩数据集/Ubuntu 19.10最终选择LZ4
  Zstd, 一种新的无损压缩算法，旨在提供快速压缩，并实现高压缩比, Fedora 31 RPMs采用它.

  当传输速度高于 50MB/s 时，LZ4 是更好的选择；而当传输速度介于 0.5MB/s 和 50MB/s 时，Zstd 在速度上领先于其它算法.

## 可观察性

[OpenTelemetry](https://juejin.im/post/5d3572c1e51d45776147620f): 兼容OpenTracing和OpenSensus, 最终是实现Metrics、Tracing、Logging的融合.

OpenTelemetry的终态就是实现Metrics、Tracing、Logging的融合，作为CNCF可观察性的终极解决方案.

Tracing：提供了一个请求从接收到处理完毕整个生命周期的跟踪路径，通常请求都是在分布式的系统中处理，所以也叫做分布式链路追踪.
Metrics：提供量化的系统内/外部各个维度的指标，一般包括Counter、Gauge、Histogram等.
Logging：提供系统/进程最精细化的信息，例如某个关键变量、事件、访问记录等.

![Logging，Metrics 和 Tracing的关系](/misc/img/develop/92806aa2426813a4f47e6ba9b01f76f7.png)

这三者在可观察性上缺一不可：基于Metrics的告警发现异常，通过Tracing定位问题（可疑）模块，根据模块具体的日志详情定位到错误根源，最后再基于这次问题调查经验调整Metrics（增加或者调整报警阈值等）以便下次可以更早发现/预防此类问题.

## websocket

  github.com/gobwas/ws by [如何在Go语言中使用Websockets：最佳工具与行动指南](https://tonybai.com/2019/09/28/how-to-build-websockets-in-go/)

## im
- [goim](https://github.com/Terry-Mao/goim)

## code style

  - go
    
    - [Uber Go语言编码规范](https://github.com/xxjwxc/uber_go_guide_cn)

## email
- [go-gomail](https://github.com/go-gomail/gomail)
- [sendcloud](https://github.com/smartwalle/sendcloud)

## rpc
- [Cap’n Proto](https://capnproto.org/index.html)
- rpcx是Go语言生态圈的Dubbo， 比Dubbo更轻量，实现了Dubbo的许多特性，借助于Go语言优秀的并发特性和简洁语法，可以使用较少的代码实现分布式的RPC服务。
- gRPC是Google开发的高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发
- dubbo-go : Dubbo的go版本

## 文件服务器
- [MinIO](https://www.tuicool.com/articles/jiqAB33)

## quic
参考:
- [网易新闻 QUIC 敏捷实践：响应速度提升 45%，请求错误率降低 50%](https://www.infoq.cn/article/FyHfrAfWtwgPW4q1oRF1)

在流量入口设计上，选择用 Nginx + Caddy 方案(由 Nginx 负责处理 HTTP 请求，Caddy 负责处理 UDP 请求)实现；在客户端网络库上，选择了 Chromium 的网络库 Cronet，原因如下：
- Google 对 Chromium 开源多年，已经过众多软件团队的验证，基础功能稳定良好
- 作为 Chromium 的网络库，Cronet 的跨平台性良好，在 Android 和 iOS 双端可直接接入
- gQUIC 相比 iQUIC，在各方面支持都更成熟，Cronet 也可以直接支持 gQUIC

> 相较 iQUIC 而言，gQUIC 目前的应用较为普遍、成熟 in 2020

