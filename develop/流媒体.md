# 流媒体

## 压缩基础
1. 空间冗余 : 图像的相邻像素之间有较强的相关性,一张图片相邻像素往往是渐变的,不是突变的,没必要每个像素都完整地保存,可以隔几个保存一个,中间的用算法计算出来
1. 时间冗余 : 视频序列的相邻图像之间内容相似。一个视频中连续出现的图片也不是突变的,可以根据已有的图片进行预测和推断
1. 视觉冗余 : 人的视觉系统对某些细节不敏感,因此不会每一个细节都注意到,可以允许丢失一些数据
1. 编码冗余 : 不同像素值出现的概率不同,概率高的用的字节少,概率低的用的字节多,类似霍夫曼编码(Huffman Coding)的思路.

## 接流/转码/拉流
接流: 通过网络协议将编码好的视频流,从主播端推送到服务器,在服务器上有个运行了同样协议的服务端来接收这些网络包,从而得到里面的视频流的过程.

转码: 服务端接到视频流之后,可以对视频流进行一定的处理, 即从一个编码格式,转成另一种格式. 因为观众使用的客户端千差万别,要保证他们都能看到直播.

拉流: 流处理完毕之后,观众的客户端来请求这些视频流的过程.

分发: 将视频预先加载到就近的边缘节点(部署在全国各地及横跨各大运营商里,和用户距离很近),这样大部分观众看的视频,是从边缘节点拉取的,就能降低服务器的压力.

典型案例: 直播.
![](/misc/img/a9596d05a47e940eaab229c15f13e724.png)

## 视频帧
视频序列分成三种帧:
- I 帧,也称关键帧. 里面是完整的图片,只需要本帧数据,就可以完成解码.
- P 帧,前向预测编码帧. P 帧表示的是这一帧跟之前的一个关键帧(或 P 帧)的差别,解码时需要用
之前缓存的画面,叠加上和本帧定义的差别,生成最终画面.
- B 帧,双向预测内插编码帧. B 帧记录的是本帧与前后帧的差别. 要解码 B 帧,不仅要取得之前的缓存画面,还要解码之后的画面,通过前后画面的数据与本帧数据的叠加,取得最终的画面.

I 帧最完整,B 帧压缩率最高,而压缩后帧的序列,应该是在 IBBP 的间隔出现的. 这就是**通过时序进行编码**

帧结构:
![](/misc/img/1f950c8b30fe6992437242c368f0f8b1.png)

在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，可以方便进行**空间上的编码**.

视频流的二进制流格式: 网络提取层单元（NALU，Network Abstraction Layer Unit）, 变成这种格式就是为了传输.

> 排列好的 NALU,在网络传输的时候,要按照 RTMP 包的格式进行包装,RTMP 的包会拆分成Chunk 进行传输.

NALU:
![](/misc/img/700a12a5961e079cb3c2a6a2db06827d.png)

每一个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔；然后是 NALU 的头，里面主要配置了 NALU 的类型；最终 Payload 里面是 NALU 承载的数据.

在 NALU 头里面，主要的内容是类型NAL Type:
- 0x07 表示 SPS，是序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等.
- 0x08 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等.

在传输视频流之前，必须要传输这两类参数，不然无法解码. **为了保证容错性，每一个 I 帧前面，都会传一遍这两个参数集合**.

如果 NALU Header 里面的表示类型是 SPS 或者 PPS，则 Payload 中就是真正的参数集的内容。

如果类型是帧，则 Payload 中才是正的视频数据，当然也是一帧一帧存放的，前面说了，一帧的内容还是挺多的，因而每一个 NALU 里面保存的是一片。对于每一片，到底是 I 帧，还是 P 帧，还是 B 帧，在片结构里面也有个 Header，这里面有个类型，然后是片的内容.

这样，整个格式就出来了，一个视频，可以拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个 NALU 里面，NALU 之间都是通过特殊的起始标识符分隔，在每一个 I 帧的第一片前面，要插入单独保存 SPS 和 PPS 的 NALU，最终形成一个长长的 NALU 序列.