# crypto
Go密码学包的目标是帮助Go开发人员构建安全应用,因此它的演进设计原则如下:
1. 实现安全(secure):以提供一个没有安全漏洞的安全实现为第一原则
2. 使用安全(safe):密码学包应该易于安全使用,因为密码学包滥用与使用存在安全漏洞的密码学包对应用的危害是一样大的
3. 简单实用(practical):聚焦于常见的、通用的应用场景
4. 与时俱进(modern):与密码学工程的最新进展保持同步

密码算法可以分为分组密码(block cipher)和流密码(stream cipher)两种. 流密码是对数据流进行连续处理的一类算法,而日常使用最多的AES加密算法则归于分组密码算法范畴.

分组密码是一种一次仅能处理固定长度数据块的算法。而这个数据块的固定长度(比特数量)则称为该分组密码算法的分组长度(block length).

分组密码算法的关键:
1. 明文(plaintext)按照分组密码算法的分组长度进行分组。如果明文总长度超过分组长度且不是分组长度的整数倍,那么最后一个明文分组需通过填充(padding)使其满足分组长度要求

    填充是为了保证每个明文分组长度都满足算法分组长度要求, 常见填充方法:
    1. PKCS#7:填充字符串由一个字节序列组成,该序列中每字节的值都是该填充字节序列的长度。**该方案适合分组长度为1~255字节的情况**。
    1. PKCS#5:该填充方案和PKCS#7方案原理上没有实质区别, 只是**它仅适合分组长度为8字节的情况。(该方案不适合AES算法,因为该算法的分组长度至少为16字节)**. 也就是说,当分组长度为8字节时,采用PKCS#5方案和采用PKCS#7方案得到的填充字节序列是一样的.
1. 分组密码算法每次仅加密一个明文分组。如果明文因总长度超过分组长度而存在多个分组,那么分组密码算法会被迭代调用以逐个处理明文分组
1. 迭代的方法称为分组密码算法的模式

    常见的模式包括
    1. ECB模式(电子密码本模式)
    2. CBC模式(密码分组链接模式)
    3. CFB模式(密文反馈模式)
    4. OFB模式(输出反馈模式)
    5. CTR模式(计数器模式)

    CBC模式的第一个明文分组由于不存在前一个密文分组,因此使用了一个被称为“初始向量”(initialization vector, IV)的随机数据。这个初始向量在解密时也会被用到,因此加密方和解密方需事先就初始向量的生成方式达成一致。比如:一种惯用法是将初始向量字符串包含在密文的头部,长度为分组长度.

    从安全性考虑,ECB模式(电子密码本)虽然简单、快速,但不应在生产中使用,因为它对攻击的抵御能力是这些模式中最弱的.

## AES
key长度 = 16字节(即128比特) = AES-128
key长度 = 24字节(即192比特) = AES-192
key长度 = 32字节(即256比特) = AES-256

## RSA
RSA的公钥可以看成数对(E, N),而私钥可以看出数对(D, N), N= modulus 模数, E=public exponent 指数, D=私钥组件

RSA加密:RSA密文就是对代表明文的数字的E次方求mod结果.
RSA解密:明文就是对代表RSA密文的数字的D次方求mod结果.

RSA加解密默认使用PKCS#1 v1.5填充方案,但该方案在面对Chosen Ciphertext Attacks(选择密文攻击)时强度不足(虽然无法破译RSA,但攻击者可能获取到密文对应的明文的少量信息),而RSA-
OAEP(Optimal Asymmetric Encryption Padding,最优非对称加密填充)则被认为是一种可信赖、满足强度要求的填充方案.

RSA-OAEP会通过随机数使每次生成的密文呈现不同的排列方式.

RSA算法对待处理的数据长度是有要求的,采用RSA-OAEP填充时,加密函数EncryptOAEP支持的最大明文长度为`RSA密钥长度(字节数)-单向散列结果长度×2-2`

## hash
除了输出长度固定、计算快速之外,密码学级别的单向散列函数还具有如下性质:
1. 强抗碰撞性:要找到散列值(摘要值)相同的两条不同的消息是非常困难的
1. 单向性:无法通过散列值(摘要值)反算出输入的消息原文

由于具有上述性质,密码学级别单向散列函数被广泛用于检测下载文件是否被篡改、基于口令的身份验证、数字签名、消息认证码以及随机数生成器当中.

## hac
消息认证码是一种不仅能确认数据完整性,还能保证消息来自期望来源的密码技术。消息认证码技术是以通信双方共享密钥为前提的.

消息认证码有多种实现方式,包括使用单向散列函数实现、使用分组密码实现、公钥密码实现等, 常用的是单向散列函数的实现.

在实际使用中,对数据进行对称加密且携带MAC值的方式被称为“认证加密”(Authenticated Encryption with Associated Data,AEAD)。认证加密同时满足了机密性(对称加密)、完整性(MAC中
的单向散列)以及认证(MAC)的特性,在生产中有着广泛的应用.

认证加密主要有以下三种方式:
- Encrypt-then-MAC:先用对称密码对明文进行加密,然后计算密文的MAC值
- Encrypt-and-MAC:将明文用对称密码加密,并计算明文的MAC值
- MAC-then-Encrypt:先计算明文的MAC值,然后将明文和MAC值一起用对称密码加密

分组密码中的GCM(Galois Counter Mode)就是一种认证加密模式,它使用CTR(计数器)分组模式和128比特分组长度的AES加密算法进行加密,并使用Carter-Wegman MAC算法实现MAC值计算.

## 数字签名
单凭消息认证码无法防止否认(non-repudiation), 而数字签名可以.

数字签名就是通过将公钥密码反过来用而实现的, 即是公钥密码系统的逆过程.

RSA签名默认使用PKCS#1 v1.5方案,但该方案存在潜在伪造签名的可能。为了应对潜在伪造,RSA-PSS算法(Probabilistic Signature Scheme)被设计出来。RSA-PSS算法通过采用
对消息摘要进行签名,并在计算散列值时对消息加盐(salt)的方式来提高安全性(这样对同一条消息进行多次签名,每次得到的签名都不同).

## 随机数
Go密码学包crypto/rand提供了密码学级别的随机数生成器实现rand.Reader,在不同平台上rand.Reader使用的数据源有所不同。在类Unix操作系统上,它使用的是该平台上密码学应用的首选随机数源`/dev/urandom`

crypto下相关密码包大多依赖rand.Reader这个随机数生成器.