# ip

## 子网掩码
实际的 IPv4 地址是一串32 比特的数字， 按照 8 比特（ 1 字节）为一组分成 4 组， 常用圆点隔开的十进制表示, 但仅凭这一
串数字我们无法区分哪部分是网络号， 哪部分是主机号, 因此才有了子网掩码,即子网掩码表示网络号与主机号之间的边界.

网络号(网段) = ip & 子网掩码

主机号:
1. 主机号部分全部为 0 代表**整个子网**而不是子网中的某台设备
1. 主机号部分全部为 1 代表向子网上所有设备发送包， 即广播

## dns
让人来使用名称， 让路由器来使用 IP 地址进行通信的机制即dns.

## ICMP和 ARP
IP 中包括 ICMP 协议和 ARP 协议.

ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息; ARP 用
于根据 IP 地址查询相应的以太网 MAC 地址.

## 协议栈
协议栈即网络控制软件.
协议栈是根据套接字中记录的控制信息来工作的.

协议栈发送数据的时机选择:
1. 每个网络包能容纳的数据长度， 协议栈会根据MTU来进行判断. 长度优先,可能产生延迟
2. 协议栈的内部计时器的时间. 时间优先, 可能降低网络效率

实际如何判断发送时机是由协议栈的实现决定的. 而且仅靠协议栈来判断发送的时机可能会带来一些问
题， 因此协议栈也给应用程序保留了控制发送时机的余地.

## socket
socket.connect() 是通信双方交换控制信息.

通信操作中使用的控制信息分为两类:
1. 头部(以太网头部, IP头部, TCP头部等)中记录的信息
2. 套接字（协议栈中的内存空间）中记录的信息

## MTU
MTU(Maximum Transmission Unit) 表示一个网络包的最大长度， 在以太网中一般是 1500 字节。 MTU 是**包含头部的总长度**， 因此需要从MTU 减去头部的长度， 然后得到的长度就是一个网络包中所能容纳的最大数据长度， 这一长度叫作 MSS(Maximum Segment Size).

## tcp
网络出现错误时, tcp协议栈会负责重传, 因此网卡、 集线器、 路由器, 应用程序都没有错误补偿机制， 一旦检测到错误就直接丢弃相应的包; TCP 会在尝试几次重传无效之后强制结束通信， 并向应用程序报错.

> 通过“序号”和“ACK 号”可以确认接收方是否收到了网络包.

网络的错误检测和补偿机制:
1. 返回 ACK 号的等待时间（这个等待时间叫超时时间）.tcp会根据网络包平均往返时间调整 ACK 号等待时间.
2. 使用窗口有效管理 ACK 号. TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。 所谓滑动窗口， 就是在发送一个包之后， 不等待 ACK 号返回， 而是直接发送后续的一系列包. 窗口大小一般和接收方的缓冲区大小一致.