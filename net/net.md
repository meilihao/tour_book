# ip

## 网络设备
集线器是按照以太网规则传输包的设备， 而路由器是按照 IP规则传输包的设备.

## 子网掩码
实际的 IPv4 地址是一串32 比特的数字， 按照 8 比特（ 1 字节）为一组分成 4 组， 常用圆点隔开的十进制表示, 但仅凭这一
串数字我们无法区分哪部分是网络号， 哪部分是主机号, 因此才有了子网掩码,即子网掩码表示网络号与主机号之间的边界.

网络号(网段) = ip & 子网掩码

主机号:
1. 主机号部分全部为 0 代表**整个子网**而不是子网中的某台设备
1. 主机号部分全部为 1 代表向子网上所有设备发送包， 即广播

## dns
让人来使用名称， 让路由器来使用 IP 地址进行通信的机制即dns.

## ICMP和 ARP
IP 中包括 ICMP 协议和 ARP 协议.

ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息; ARP 用
于根据 IP 地址查询相应的以太网 MAC 地址; RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射.

## 协议栈
协议栈即网络控制软件.
协议栈是根据套接字中记录的控制信息来工作的.

协议栈发送数据的时机选择:
1. 每个网络包能容纳的数据长度， 协议栈会根据MTU来进行判断. 长度优先,可能产生延迟
2. 协议栈的内部计时器的时间. 时间优先, 可能降低网络效率

实际如何判断发送时机是由协议栈的实现决定的. 而且仅靠协议栈来判断发送的时机可能会带来一些问
题， 因此协议栈也给应用程序保留了控制发送时机的余地.

包收发操作: 应用数据 <-> tcp模块 <-> ip模块 <-> 网络硬件.

IP 模块会添加**IP 头部和 MAC 头部这两种头部**. IP 头部中包含 IP 协议规定的、 根据 IP 地址将包发往目的地所需
的控制信息； MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息.

TCP 模块在收发数据时会分为好几个阶段， 并为各个阶段设计了实现相应功能的网络包， 但 IP 的包收发操作
都是相同的， 并不会因包本身而有所区别,即它将TCP 头部和数据块看作一整块二进制数据， 在执行收发操作时并不关心其中的内容.
IP 模块也不关心 TCP 的操作阶段， 对于包的乱序和丢失也一概不知.
总之， IP 的职责就是将委托的东西打包送到对方手里， 或者是将对方送来的包接收下来, 仅此而已.

IP 头部包含目的地的ip地址,由tcp模块提供(实际最初来源是应用程序), IP模块不负责判断目的地ip地址的可用性.

IP 头部格式见<<网络是怎样连接的>>表2.2

> MAC 头部很容易被误解为是由网卡来处理的，实际上它是由 TCP/IP 软件来负责的.
> 分片的包会在 IP 头部的标志字段中进行标记,同一个包的所有分片在IP头部都具有相同的 ID, 此外， IP 头部还有一个分片偏移量（ fragment offset）字段， 它
表示当前分片在整个包中所处的位置. 分片重组: 根据IP头部的ID和分片偏移量, 在所有分片全部收到之后， 就可以将它们还原成原始的包的操作.

IP 头部中的 TTL（ Time to Live， 生存时间）字段表示包的有效期.

## socket
socket.connect() 是通信双方交换控制信息.

通信操作中使用的控制信息分为两类:
1. 头部(以太网头部, IP头部, TCP头部等)中记录的信息
2. 套接字（协议栈中的内存空间）中记录的信息

## MTU
MTU(Maximum Transmission Unit) 表示一个网络包的最大长度， 在以太网中一般是 1500 字节。 MTU 是**包含头部的总长度**， 因此需要从MTU 减去头部的长度， 然后得到的长度就是一个网络包中所能容纳的最大数据长度， 这一长度叫作 MSS(Maximum Segment Size).

## frame
- [frame](/misc/img/frame.png)

每个包的前面都有报头和起始帧分界符（SFD），报头用来测定时机，SFD 用来确定帧的起始位置.

> 制定以太网标准的组织 IEEE 出于历史原因使用了“帧”而不是“包”，因此在以太网术语中都是说“帧”,可以认为两者等价.

## TCP/IP 协议
TCP/IP协议族是一组协议的集合, 用来实现互联网上主机之间的相互通信.

参考:
- [TCP/IP 知识点整理](http://strawhatfy.github.io/2015/07/30/TCP-IP-Protocol/)
- [TCP](http://liuxiang.github.io/2017/07/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%EF%BC%88tcp%E6%8F%A1%E6%89%8B%E9%87%8D%E4%BC%A0,http%E9%95%BF%E7%9F%AD%E9%93%BE%E6%8E%A5,Header%E5%88%86%E7%B1%BB%EF%BC%89/)

### tcp握手/分手/状态
[tcp握手/挥手/状态](/misc/img/tcp_status.jpg)
[tcp状态转换](/misc/img/tcp_status_change.jpg)

实验环境:
```bash
$ nc -l -p 9000
$ nc localhost 9000
```
使用wireshare或tcpdump截包.

#### 三次握手
![TCP连接的建立](https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
完成了三次握手，客户端和服务器端就可以开始传送数据.

> tcp每个package均带有win.
> TCP Windows Update: 发送者传输数据比接收者读取快, 因此接收者需告诉发送者应以多大的速度发送数据, 从而使得数据传输与接受恢复正常.
> TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号
> TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号

为什么是三次: 防止了服务器端的一直等待而浪费资源. 假设握手是两次, 客户端发送连接请求因某些原因滞留, 客户端在等待超时后重新发送,服务端收到并响应,最后关闭连接通信(比如短请求像http请求之类的). 之后那个失效的连接请求抵达了服务端，由于只有两次握手，服务端会认为是新请求, 收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据. 但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源.

#### 四次分手
![TCP连接的释放](https://img-blog.csdn.net/20170606084851272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，再向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1, 之后进入CLOSE_WAIT状态；主机1收到ACK进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL(Double Maximun Segment Life, 两倍的报文段的最大生存时间)后依然没有收到回复，则证明主机2端已正常关闭，那好，主机1也可以关闭连接了.
至此，TCP的四次分手就这么愉快的完成了

> 在Linux上报文段的最大生存时间通常是30秒，两倍的MSL就是一分钟
> TCP规定，FIN报文段即使不携带数据，也要消耗一个序号

为什么建立连接协议是三次握手，而关闭连接却是四次握手呢? **tcp是全双工, 双方都要相互确认终止发送数据**, 这也是主机2的FIN和响应主机1的FIN的ACK不能同时发送的原因.
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的.

为什么要有一个 TIME_WAIT 状态？为什么不能直接到达 CLOSED 状态？
1. 可靠地实现TCP全双工连接的终止
假设没有 TIME_WAIT 这种状态。现实中，网络环境不是理想的。在数据包传输的过程中，难免会有一些延时、丢包的情况发生。如果，在主机1最后一个ACK报文段发出去之后，由于某种原因，没有到达主机2，这样，主机2在超时后，就会向主机1重新发一个 FIN 报文段，请求重传。由于在主机1端，连接实际上已经断开，端口已经关闭。那么在主机1收到这个报文段后，会向主机2发送一个 RST 报文(RST表示复位，用来异常的关闭连接). 而主机2收到该报文段后，会认为是错误的，它所期望收到的是ACK报文.

2. 保证让迟来的报文段有足够的时间被处理
同样在不理想的网络环境中，有些包会在网络中有所延迟。假如没有 TIME_WAIT 这种状态，在关闭连接后并且建立新的连接后，可能会收到该数据包。由于序号不同，客户端会要求服务端重传数据包，这样，连接就会混乱出错. 而 TIME_WAIT 状态的时间，一般是 2MSL 时间，并且端口没有释放. 这样，前一个连接的报文段有足够的时间被识别或者丢弃，也就不会出现这个问题

为什么A(主机1)要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 为了保证B(主机2)能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭.

> 双方可能同时发送FIN+ACK进行关闭.

## tcp
网络出现错误时, tcp协议栈会负责重传, 因此网卡、 集线器、 路由器, 应用程序都没有错误补偿机制， 一旦检测到错误就直接丢弃相应的包; TCP 会在尝试几次重传无效之后强制结束通信， 并向应用程序报错.

> 通过“序号”和“ACK 号”可以确认接收方是否收到了网络包.

网络的错误检测和补偿机制:
1. 返回 ACK 号的等待时间（这个等待时间叫超时时间）.tcp会根据网络包平均往返时间调整 ACK 号等待时间.
2. 使用窗口有效管理 ACK 号. TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作。 所谓滑动窗口， 就是在发送一个包之后， 不等待 ACK 号返回， 而是直接发送后续的一系列包. 窗口大小一般和接收方的缓冲区大小一致.

通信结束之后,套接字并不会立即被删除， 而是会等待一段时间(通常是几分钟)之后再被删除,等待这段时间是为了防止误操作, 具体时长与包重传的操作方式有关.

> Gateway（网关）在 TCP/IP 的世界里就是路由器的意思.

## udp

## FAQ
### TCP与UDP的区别
1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
1. TCP提供可靠全双功的通信服务。UDP是半双功，只能单向传播。
1. 通过TCP连接可靠传送的数据，可靠的、无差错，不丢失，不重复，且按序到达;UDP则是不可靠信道，尽最大努力交付，即不保证可靠交付.
1. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流,即没有数据边界, 可能出现粘包;UDP是面向报文的．
1. TCP具有拥塞控制，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
1. 每一条TCP连接只能是点到点的;UDP比较灵活，支持一对一，一对多，多对一和多对多的交互通信
1. TCP首部开销20字节;UDP的首部开销小，只有8个字节.

### TCP/UDP应用场景
- tcp : 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高.举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录. NSQ底层通讯就采用TCP. 对应的协议有http,imap,smtp,ssh,telnet等
- udp : 效率要求相对高，对准确性要求相对低的场景. 举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）. 对应的协议有DNS等.