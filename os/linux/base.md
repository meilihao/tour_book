## 用户

用户列表:`/etc/passwd`
格式:`name(用户名):password(口令):id(用户标识号):group id(组标识号):comment(注释性描述):主目录:login shell`

`password`部分被`x`替代表示密码实际存储在`/etc/shadow`.

`login shell`中的`/usr/sbin/nologin`和`/bin/false`:

- `/usr/sbin/nologin`,礼貌地拒绝登录(会显示一条提示信息),但可以使用其他服务,比如ftp.
- `/bin/false`,什么也不做只是返回一个错误状态,然后立即退出.即用户会无法登录,并且不会有任何提示,是最严格的禁止login选项，一切服务都不能用.

> 如果存在`/etc/nologin`文件,则系统**只允许root用户**登录,其他用户全部被拒绝登录,并向他们显示`/etc/nologin`文件的内容

## 用户组

用户列表:`/etc/group`
格式:`group name:password:group id:user list`

`password`部分被`x`替代表示没有密码.

### 命令

- groups : 一个用户属于哪些组.

## 权限

### SUID

SUID权限**仅对二进制可执行文件有效**,让用户在执行时具有文件所有者的权限,且该权限仅在执行该文件的过程中有效.

```
chmod u+s xxx
```

举例: passwd命令

### SGID

#### SGID对目录

- 用户在此目录下的有效用户组将会变成该目录的用户组
- 如果用户在该目录下具有 w 的权限,则其所创建的新文件的用户组与此目录的用户组相同

#### SGID对文件

- SGID 对二进制可执行文件有效
- 用户对该文件具备 x 的权限
- 在执行的过程中将会获得该文件群组的支持

举例: locate命令

### sticky bit

是在other用户的权限上设置,可以理解为防删除位,**仅对目录有效**.
如果具有可执行权限，设置sticky bit后是t；如果没有可执行权限的话，设置sticky bit后是T.

```
chmod o+t xxx
```

- 对一个目录设置了sticky-bit之后,比如`rwxrwxrwt`，存放在该目录的文件仅准许其属主(或root)执行删除、 移动等操作.

举例: /tmp目录

## 调度器
参考:
- [如何更改 Linux I/O 调度器来调整性能](https://linux.cn/article-8179-1.html)
- [Linux进程和线程的调度与优先级](https://vaqeteart.github.io/categories/study/os/linux_schedule_priority.html)
- [深入 Linux 的进程优先级](https://linux.cn/article-7325-1.html)
- [linux进程调度](https://peterpan980927.cn/2017/12/18/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/)

###　IO
Linux I/O 调度器Linux I/O scheduler控制内核提交读写请求给磁盘的方式. 自从 2.6 内核以来，管理员已经能够更改这个调度器，所以他们可以自定义他们的平台以完全适合他们的需要.

这些调度器是：
1. CFQ （Completely Fair Scheduler完全公平调度器）（cfq） : 它是许多 Linux 发行版的默认调度器；它将由进程提交的同步请求放到多个进程队列中，然后为每个队列分配时间片以访问磁盘
1. Noop 调度器（noop） ： 基于先入先出（FIFO）队列概念的 Linux 内核里最简单的 I/O 调度器. 此调度程序**最适合于 SSD**
1. 截止时间调度器（deadline） ： 尝试保证请求的开始服务时间

### 进程
进程可以分为CPU密集型和I/O密集型两种. I/O密集型的进程大部分时间都在用来提交I/O请求和等待I/O请求; CPU密集型进程大部分时间都花在执行代码上.

调度策略主要在两个矛盾之间寻找平衡：进程响应时间短和最大的系统利用率.

> 为了保证交互式应用和桌面系统的性能，一般Linux更倾向于优先调度I/O消耗型进程

#### 进程优先级
1. nice值
nice值得优先级范围是从-20到+19，**nice值越大，优先级越小**. Linux系统的nice值代表的是时间片的比例，因此越小的nice值，占有CPU的时间也就会越长，其默认值为0.
1. 实时优先级
优先级变化范围：0~MAX_RT_PRIO-1间, 默认MAX_RT_PRIO配置为100. **值越大，优先级越高**. Linux下查看实时优先级命令： `ps -eo state,uid,pid,rtprio`

因为任何实时进程的优先级都高于普通进程. 因此实时优先级和nice优先级处于两个不相交的范畴.

> `ps -el`的`NI`列包含 `-` 这个符号，该符号的含义是指：该进程是实时进程.Linux中可以通过renice命令调整进程的优先级
> `ps -eo state,uid,pid,rtprio`的`RTPRIO`列包含`-` 这个符号，该符号的含义是指：该进程不是实时进程

#### 调度类型
每个Linux进程都按照以下调度类型被调度：
- SCHED_FIFO
  先进先出的实时进程, 不使用时间片. 如果没有优先级更高的可运行的实时进程，则当前运行的实时进程想运行多久便运行多久，即使还有其他优先级相同的可运行实时进程
- SCHED_RR
  时间片轮转的实时进程. 保证对所有相同优先级的实时进程公平地分配CPU时间即只有当它的时间片用完，内核会把它放到进程队列的末尾
- SCHED_NORMAL
  普通的分时进程

SCHED_NORMAL是普通进程调度策略,其他两者都是实时进程调度策略. 它们的主要区别就是通过优先级来区分的: 所有优先级值在0-99范围内的，都是实时进程，所以这个优先级范围也可以叫做实时进程优先级，而100-139范围内的是非实时进程.

系统的整体优先级策略是：如果系统中存在需要执行的实时进程，则优先执行实时进程. 直到实时进程退出或者主动让出CPU时，才会调度执行非实时进程. 即 **任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占，同级实时进程之间是按照FIFO（一次机会做完）或者RR（多次轮转）规则调度的**.

SCHED_FIFO 与 SCHED_RR 的区别是:当进程的调度策略为前者时,当前实时进程将一直占用 CPU 直至自动退出, **除非有更紧迫的、优先级更高的实时进程**需要运行时,它才会被抢占 CPU;当进程的调度策略为后者时,它与其它实时进程以实时轮流算法去共同使用 CPU，用完时间片放到运行队列尾部.

![Linux 进程优先级与 nice 值及实时进程优先级的关系](https://pic2.zhimg.com/80/v2-488659493625064c6227293720c117c9_hd.jpg)

> 默认情况下，进程的nice是从父进程继承来的
> priority就是ps命令中看到的PRI值或者top命令中看到的PR值, 越小说明优先级越高.
> nice值虽然不是priority，但是它确实可以影响进程的优先级
> 实时进程, 只有静态优先级;普通进程根据动态优先级进行调度
> 动态优先级(`dynamic_prio=max(100, min(static_prio-bonus+5, 139))`)是由静态优先级（`static_prio=MAX_RT_PRIO +nice+ 20`, 静态优先级范围在100~139之间）调整而来.
> 在系统中可以使用chrt命令来查看、设置一个进程的实时优先级状态
> 进程的平均睡眠时间也即bonus

1. 完全公平调度算法，简称CFS. 它是linux 默认进程调度器, 且CFS是一个普通进程的调度器. CFS的做法是：在所有可运行进程的总数上计算出一个进程应该运行的时间，nice值不再作为时间片分配的标准，而是用于处理计算获得的处理器使用权重.

### 进程间通信
进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息. IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、信号、 共享内存、Socket.

1. 管道: 是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用.进程的亲缘关系通常是指父子进程关系. 由于没有名字，只能用于亲缘关系的进程间通信, 为了克服这个缺点，提出了有名管道(FIFO).
1. 信号量: 是一个计数器, 用于实现进程间的互斥与同步，而不是用于存储进程间通信数据(若要在进程间传递数据需要结合共享内存)
1. 信号: 用于通知接收进程某个事件已经发生, 主要作为进程间以及同一进程不同线程之间的同步手段
1. 消息队列: 是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.消息队列是UNIX下不同进程之间可实现共享资源的一种机制
1. 共享内存: 是最快的一种 IPC，因为进程是直接对内存进行存取.信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问
1. socket: 普通socket + unix socket

#### Linux系统中常用信号
1. SIGHUP：用户从终端注销，所有已启动进程都将收到该进程. 系统缺省状态下对该信号的处理是终止进程
1. SIGINT：程序终止信号. 程序运行过程中，按Ctrl+C键将产生该信号
1. SIGQUIT：程序退出信号. 程序运行过程中，按`Ctrl+\`键将产生该信号
1. SIGBUS和SIGSEGV：进程访问非法地址
1. SIGFPE：运算中出现致命错误，如除零操作、数据溢出等
1. SIGKILL：用户终止进程执行信号. shell下执行kill -9发送该信号
1. SIGTERM：结束进程信号. shell下执行kill 进程pid发送该信号
1. SIGALRM：定时器信号
1. SIGCLD：子进程退出信号. 如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程