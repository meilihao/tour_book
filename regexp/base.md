# 正则表达式

[正则表达式](https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.100).aspx)是一种文本模式，包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为"元字符").

> 正则表达式语言由两种基本字符类型组成：原义（正常）文本字符和元字符。元字符使正则表达式具有处理能力。所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式.

正则表达式有几个用途：用于验证输入、通过grep查看日志、匹配HTML里面的标签.

正则表达式验证工具Kodos http://kodos.sourceforge.net/

注意:
1. **js不存在命名分组(即命名捕获组)**
1. [re2](github.com/google/re2)这样的非回溯引擎可彻底关闭回溯操作,而使用原子分组可以关闭正则表达式的部分回溯操作,因此原子分组主要与性能相关.

> 回溯(backtracking)是指量词首次尝试匹配整个字符串,如果失败则回退一个字符后再次尝试的过程.
> 正则表达式处理过程缓慢的一个因素就是回溯操作,其原因就是回溯操作会尝试每一种可能性,这会消耗时间和计算资源.
> 原子分组(atomic group)可以将回溯操作关闭,但它只针对原子分组内的部分.

## 元字符

- `^` : 开始位置,字符`^`之后的实体(entity),必须在被匹配的字符串开头部分找到(如果标记 m=true 则匹配行首，否则匹配整个文本的开头(m 默认为 false));但将`^`用作括号表达式中的第一个字符，则表示对字符集求反
- `$` : 结束位置,在字符`$`前的实体,必须在匹配的字符串尾找到(如果标记 m=true 则匹配行尾，否则匹配整个文本的结尾(m 默认为 false))
- `.` : 匹配任意的单个字符,除换行符(类unix:`[^\n]`或windows:`[^\r\n]`)外
- `[]` : 字符组(set),匹配指定字符集内的任何字符
- `[^]` : 否定组,匹配任何不包括在指定字符集内的字符串
- `|` : 或,`|`左右两边的一到多个字符当成一个整体对待,满足其中任意一种规则都应该当成匹配
- `{}` : 标记限定符表达式的开始和结尾
- `()` : 分组,组成一组用于匹配的实体,常于`|`协同使用,即标记子表达式的开始和结尾
- `\` : 转义,允许对一个特殊字符进行转义(即将具有特殊意义的字符转为普通的字符)
- `/` : 表示 JavaScript 中的文本正则表达式模式的开始或结尾.在第二个“/”后添加单字符标志可以指定搜索行为(`g`表示返回匹配到模式的所有项，`i`表示不区分大小写,`m`表示多行匹配)

- `\A` : 匹配整个文本的开头，忽略 m 标记
- `\z` : 匹配整个文本的结尾，忽略 m 标记
- `\b` : 匹配某个单词边界(匹配位置而非字符)，因此其不消耗任何字符,是零长度匹配.
- `\B` : 非边界字匹配
- `\d` : 匹配一个数字,等于`[0-9]`
- `\D` : 非数字字符匹配,等于`[^0-9]`
- `\w` : 与以下任意字符匹配：A-Z、a-z、0-9 和下划线,等效于`[A-Za-z0-9_]`
- `\W` : 与除A-Z、a-z、0-9 和下划线意外的任意字符匹配,等效于`[^A-Za-z0-9_]`
- `[xyz]` : 字符集,与其中任意一个指定字符匹配
- `[^xyz]` : 反向字符集,与除字符集外的任何字符匹配
- `[a-z]` : 字符范围,匹配指定范围内的任何字符
- `[^a-z]` : 反向字符范围,与不在指定范围内的任何字符匹配
- `\Qxxx\E` : 匹配字符串字面值`xxx`

- `(pattern)` : 与模式 匹配并保存匹配项
- `(?<name>pattern)` : 匹配pattern并且捕获到组`name`
- `(?:pattern)` : 与模式 匹配，但不保存匹配项；即不会存储匹配项以备将来使用
- `(?=pattern)` : 正预测先行(要匹配的字符串，后面必须紧跟着pattern)。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来使用.比如`ancyent (?=marinere)`,匹配紧跟`marinere`的字符串`ancyent `.
- `(?!pattern)` : 负预测先行(要求字符串的后面不能紧跟着某个pattern)。 匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来使用.比如`ancyent (?!marinere)`匹配不跟`marinere`的字符串`ancyent `

- `\cx` : 匹配 x 指示的控制字符。 x 的值必须在 A-Z 或 a-z 范围内。 如果不是这样，则假定 c 就是文本“c”字符本身
- `\xn` : 匹配 n，此处的 n 是一个十六进制转义码。 十六进制转义码必须正好是两位数长。 允许在正则表达式中使用 ASCII 代码
- `\num` : 匹配 num，此处的 num 是一个正整数。 这是对已保存的匹配项的引用
- `\n` : 标识一个八进制转义码或反向引用.如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。 否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。
- `\nm` : 标识一个八进制转义码或反向引用.如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。 如果 \nm 前面至少有 n 个捕获子表达式，则 n 是反向引用，后面跟有文本 m。 如果上述情况都不存在，当 n 和 m 是八进制数字 (0-7) 时，\nm 匹配八进制转义码 nm
- `\nml` : 当 n 是八进制数字 (0-3)，m 和 l 是八进制数字 (0-7) 时，匹配八进制转义码 nml,比如`\351`=`\u00e9`
- `\un` : 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符,比如`\u00e9`

- `\pUnicode普通类名` : 匹配“Unicode类”中的一个字符(仅普通类),比如`\pL`匹配属性为字母(L)的字符
- `\PUnicode普通类名` : 匹配“Unicode类”外的一个字符(仅普通类)
- `\p{Unicode类名}` : 匹配“Unicode类”中的一个字符,比如`\p{Ll}`匹配属性为小写字母
- `\P{Unicode类名}` : 匹配“Unicode类”外的一个字符

> Unicode类名(属性)见<学习正则表达式>的表`6-2`.
> 非捕获分组(Non-Capturing Group)不会将其内容存储在内存中,因此其会带来(比捕获分组)稍高的性能,但可忽略不计.

## flag

- i : 不区分大小写
- m : 多行模式,让`^`和`$`匹配行首和行尾,而非整个文本的开头和结尾
- g : 全局(global match)也就是尝试所有可能的匹配

## 量词(重复限定符)

定制匹配的次数.

- `*` : 0或多次,等于`{0,}`
- `+` : 至少1次,等于`{1,}`
- `?` : 0或1次,等于`{0,1}`,匹配模式是非贪婪的
- `{n}` : n次,n 是非负整数
- `{n,}` : 至少n次,n 是非负整数
- `{n,m}` : n到m次;n,m 是非负整数,且n<=m

> 量词自身是贪心的.

## 非打印字符

- `\f` : 换页符
- `\n` : 换行符
- `\r` : 回车符
- `\s` : 任何空白字符,其中包括空格、制表符和换页符,等同于`[ \f\n\r\t\v]`;
- `\S` : 任何非空白字符
- `\t` : Tab 字符
- `\v` : 垂直制表符

## 贪心与非贪心

所谓“贪心”(greedy),指量词会匹配所有能匹配的字符.因此只要在合法的情况下，正则会尽量多去匹配字符，这就叫做贪心模式.

如果我们希望正则尽量少地匹配字符，那么就可以在表示数字的符号后面加上一个?（即：问号加在量词的后边，则表示非贪婪匹配）,比如：

```
{n,}?, *?, +?, ??, {m,n}?
```

比如`??`,第一个`?`表示可以匹配0-1次,第二个`?`表示尽量少匹配,因此优先选择了匹配0次,即**`??`不会匹配任何内容**.

## 反向引用

pattern在匹配时，正则引擎会将小括号 "()" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取.

其实，"小括号包含的表达式所匹配到的**字符串**(而不是pattern)" 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "\" 加上一个数字。"\1" 引用第1对括号内匹配到的字符串，"\2" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号.

## 优先级顺序

正则表达式的计算方式与算术表达式非常类似；即从左到右进行计算，并遵循优先级顺序.

| 运算符                     |说明          |
| --------------------------|:-----------:|
| `\`                       | 转义符       |
| `(), (?:), (?=), []`      | 括号和中括号  |
| `*,+,?,{n},{n,},{n,m}`    | 限定符       |
| `^,$,\任何元字符`           | 定位点和序列  |
| `|`                       | 替换         |

## 补充

### 断言

断言,即标记边界,但是并不耗用字符,即不匹配字符,而是匹配字符串中的位置. 因此断言也被称做零宽度断言(zero-width assertion). 其中的一些,比如 `^` 和 `$` ,也叫做锚位符(anchor)。

### 单词边界

共有三种不同的位置作为单词边界：

- 在字符串中的第一个字符之前，如果第一个字符是`\w`
- 在字符串中的最后一个字符之后，如果最后一个字符是`\w`
- 在字符串中的两个字符之间，其中一个是`\w`，另一个不是`\w`

### [Posix Character Sets](http://www.troubleshooters.com/linux/presentations/leap_regex/13.html)

> [POSIX Bracket Expressions](http://www.regular-expressions.info/posixbrackets.html)

- [[:alnum:]]	 	letters and digits
- [[:alpha:]]		letters
- [[:blank:]]		space and tab characters
- [[:cntrl:]]		control characters
- [[:digit:]]		decimal digits
- [[:graph:]]		printable characters excluding space
- [[:lower:]]		lowercase letters (all letters when 'ignorecase' is used)
- [[:print:]]		printable characters including space
- [[:punct:]]		punctuation characters
- [[:space:]]		whitespace characters, 即`[:space:]` = ` \t\r\n\v\f` = `\s`
- [[:upper:]]		uppercase letters (all letters when 'ignorecase' is used)
- [[:xdigit:]]		hexadecimal digits
- [[:return:]]		the <CR> character
- [[:tab:]]		the <Tab> character
- [[:escape:]]		the <Esc> character
- [[:backspace:]]		the <BS> character
