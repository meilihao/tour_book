# rust
参考:
- [Rust 程序设计语言（第二版 & 2018 edition）](https://kaisery.github.io/trpl-zh-cn/)

程序的三大定律:
1. 程序必须正确
1. 程序必须可维护, 但不能违反第一定律
1. 程序必须高效, 但不能违反前两条定律

rust无疑是迈向这个目标的更近一步.

编程两大难题(本质是使用类型不安全的语言, 它们的内存管理机制不完善):
1. 编写内存安全的代码
1. 编写线程安全的代码

> 在之前的年代, 计算资源匮乏, 为追求性能, 牺牲了部分安全性.

rust是一门同时追求安全,并发和性能的现代系统级编程语言.
rust三大设计哲学:
1. 内存安全

    类型安全即类型系统可以保证程序的行为是意义明确, 不出错的. c/c++的类型系统不是类型安全的, 比如它们不检查数组越界.

    > 类型安全: 类型系统给内存中的plain data赋予了类型信息，如果不按照类型信息来解释内存中的数据，应该产生编译错误或者 产生well-specified的运行时错误.

    类型安全是内存安全的前提.

    内存安全: 不会出现内存访问错误, 只有当程序访问未定义内存时才会产生内存错误. 常见的场景有:
    1. 引用空指针
    1. 使用未初始化内存
    1. 释放后再次使用, 即虚悬指针
    1. 缓冲区溢出, 比如数组越界
    1. 非法释放已释放过的指针或未分配的指针, 即重复释放

    rust为了保证内存安全, 建立了严格的安全内存管理模型:
    - 所有权系统: 每个被分配的内存都有一个独占其所有权的指针. 只有当该指针被销毁时, 其对应的内存该会被随之释放.
    - 借用和生命周期: 每个变量都有其生命周期, 一旦超出生命周期, 变量就会被自动释放. 如果是借用, 则可以通过标记生命周期参数供编译器检查的方式, 防止出现虚悬指向即释放后使用的情况.

    > rust所有权系统还包括了从现代c++借鉴的RAII机制, 这是rust无gc但是可以安全管理内存的基石. 在 C++ 中，这种 item 在生命周期结束时释放资源的模式被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）.
    > 悬垂指针（dangling pointer, 也叫虚悬指针）是其指向的内存可能已经被分配给其它持有者.

    为了实现内存安全, rust还具备具有的特性:
    1. 仿射类型(Affine Type), 该类型可用来表达rust所有权中的Move语义.

    借助类型, rust可在编译阶段对类型进行检查是否满足安全内存模型, 有效地阻止未定义行为的发生.

    内存安全bug和并发安全的bug的产生内在原因均是内存的不正当访问造成的. 借助装备了所有权的强大类型系统, rust还解决了并发安全问题. 它通过静态检查分析, 在编译期就能检查出多线程并发代码中所有的数据竞争问题.
1. 零成本抽象即如果不使用某个抽象, 就不用为它付出开销.

    rust的绝大多数抽象并不存在运行时的开销, 其一切都是在编译期完成的.

    rust的零成本抽象的基石是泛型和trait.
1. 实用性

    为了保证支持硬实时, rust借鉴了c++的确定性析构, RAII和智能指针, 用于自动地, 确定地管理内存, 从而避免了gc的引入.

    为了保证程序的鲁棒性, rust重新审视了错误处理机制. rust针对三类非正常情况: 失败, 错误和异常, 提供了专门的处理方式:
    - 失败: 使用断言工具
    - 错误: 基于返回值的分层处理 
    - 异常: rust将其看作无法被合理解决的问题, 提供了线程恐慌机制, 发生异常时, 线程可以安全地退出.

    为了兼容现有生态, rust支持方便且零成本的FFI机制, 兼容C-ABI, 在语言架构层面上将rust分为safe rust和unsafe rust两部分. unsafe专门和外部生态打交道, 因为rust编译器检查和跟踪的范围有限, 不能检查到与其链接的其他生态接口, 因此这些生态由自身来保证安全性. 总结就是, safe rust由rust编译器在编译时保证安全, unsafe rust开发者让编译器信任自身有能力保证安全.

rust编程的哲学和golang相同: 组合优于继承. rust不提供类型层面上的继承, 所有的类型都是独立存在的.

### 编译
rust编译器是LLVM编译器的前端, 它将代码编译成LLVM IR, 然后通过LLVM编译成对应架构的机器码.

rust源码经过分词和解析生成AST(抽象语法树), 再进一步简化处理为HIR(High-level IR, 方便编译器做类型检查), 再进一步编译为MIR(middle IR, 在rust 1.12引入), 最后MIR被翻译为LLVM IR, 之后由LLVM编译成目标机器码.

引入MIR原因:
1. 缩短编译时间

    实现了增量编译, 仅重新编译更改过的部分.
1. 缩短执行时间

    进入llvm前实现更细颗粒度的优化, 单纯依赖llvm的优化颗粒度太粗, 增加了更多的优化空间
1. 更精确的类型检查

    实现更灵活的借用检查

rust语言组成:
- 语言规范
- 编译器
- 核心库

    定义了rust语言的核心, 不依赖于操作系统和网络等相关的库, 不负责堆分配,不提供并发和I/O.
    通过在模块顶部引入`#![no_std]`来使用核心库.
    组成:
    1. 基础trait, 如Copy, Debug, Display,Option等
    1. 基本原始类型, 如 bool, char,i8/u8,..i64/u64, isize/usize, f32/f64, str, array, slic, tuple, pointer等
    1. 常用功能型数据类型, 比如String, Vec, HashMap, Rc, Arc,Box等
    1. 常用的宏定义, 如println()!, assert!, panic!, vec!

        Rust 中的宏(`!`)与C/C＋＋ 中的宏是完全不一样的东西. 简单点说，可以把它理解为一种安全版的编译期语法扩展, 这里之所以使用宏，而不是函数，是因为标准输出宏可以完成编译期格式检查. 更加安全.

    做嵌入式应用开发时, 核心库是必需的.
- 标准库

    提供应用程序开发所需的基础和跨平台支持.

    组成:
    1. 与核心库一样的基本trait, 原始数据类型, 功能型数据类型和常用的宏等, 以及与核心库几乎完全一致的API.
    1. 并发, I/O和运行时.
    
        如线程模块,  用于消息传递的通道类型, Sync trait等并发模块; 文件, tcp, udp, 管道, socket等常见I/O.
    1. 平台抽象.
        - os模块提供了许多与操作环境交互的基本功能, 包括程序参数, 环境变量, 目录导航
        - 路径模块封装了处理文件路径的平台特定规则.
    1. 底层操作接口

        如std::mem,std::ptr, std::intrinsic等, 操作内存,指针, 调用编译器固有函数.
    1. 可选和错误处理类型Option和Result, 以及各种迭代器.

    Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举, 这个枚举是 Option<T>，而且它定义于标准库中.

### 代码组织
Rust 的代码从逻辑上是分 crate 和 mod 管理的. 所谓 crate 大家可以理解为"项目". 每个 crate 是一个完整的编译单元，它可以生成为一个 lib 或者 exe 可执行文件. 而在 crate 内
部， 则是由 mod 这个概念管理的，所谓 mod 大家可以理解为 namespace. 可以使用 use 语句把其他模块中的内容引入到当前模块中来.

Rust 有一个极简标准库， 叫作 std ，除了极少数嵌入式系统下无法使用标准库之外，绝大部分情况下，我们都需要用到标准库里面的东西. 为了给大家减少麻烦， Rust 编译器对标准库有特殊处理. 默认情况下，用户不需要手动添加对标准库的依赖 ，编译器会自动引人对标准库的依赖. 除此之外 ，标准库中的某些 type 、 trait、 function 、 macro 等实在是太常用了, 每次都写 use 语句确实非常无聊，因此标准库提供了一个[`std::prelude`'](https://github.com/rust-lang/rust/blob/master/library/std/src/prelude/mod.rs)模块，在这个模块中导出了一些最常见的类型 、 trait 等东西, 编译器会为用户写的每个 crate 自动插入一句话：`use std: :prelude::*;`, 这样，标准库里面的这些最重要的类型、 trait 等名字就可以直接使用，而无须每次都写全称或者 use 语句.

> [std::prelude](https://doc.rust-lang.org/std/prelude/)目前的mod.rs 中, 直接导出了 vl 模块中的内容 ， 而 v1.rs 中， 则是编译器为我们自动导人的相关trait和类型.
    
### 语句和表达式
> Rust 源代码的后缀名使用`.rs`表示, 且必须使用 utf-8 编码.

rust语法分语句(statement, 要执行的一些操作和产生副作用的表达式)和表达式(expression, 主要用于计算求值).

语句又分:
- 声明语句(Declaration statement) : 用于声明各种语言项(item), 比如变量, 静态变量, 常量, 结构体, 函数等, 以及通过extern和use关键词引入的包和模块等.
- 表达式语句(expression statement) : 特指以分号结尾的表达式. 此类表达式求值结果会被舍弃, 并总是返回单元类型`()`.

rust编译器解析代码时, 如果遇到分号, 就会继续往后面执行; 如果碰到语句, 则执行语句; 如果碰到表达式, 则会对表达式求值, 如果分号后面什么都没有, 就会补上单元值;  当
遇到函数时, 会将函数体的花括号识别为块表达式(block expression, 由一对花括号和一系列表达式组成, 它总是返回块中最后一个表达式的值)

let创建的变量一般称为绑定(bingding).

rust的表达式可分为位置表达式(place expression)和值表达式(value expression), 即其他语言中的左值和右值.

位置表达式就是表示内存位置的表达式, 分别有如下几类:
1. 本地变量
1. 静态变量
1. 解引用(*expr)
1. 数组索引(expr[expr])
1. 字段引用(expr.field)
1. 位置表达式组合

通过位置表达式可对某个数据单元的内存进行读写.
值表达式一般只引用了某个存储单元地址中的数据, 它相当于数据值, 只能进行读操作.

**从语法角度讲, 位置表达式代表了持久化数据, 值表达式代表了临时数据.**

表达式的求值过程可分为位置上下文(place context)和值上下文(value context).

let关键字声明位置表达式默认不可变, 即**不可变绑定**, 只能对对应的存储单元进行读取.
let mut声明的**可变绑定**可以对相应的存储单元进行写入.

> rust支持定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量.
> const可以在任意作用域进行定义，而定义的常量贯穿整个程序的生命周期. 在编译的时候，常量就能确定其值, 同时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址；对于变量出现重复的定义(绑定)会发生变量遮盖，而对于常量则是不允许出现重复的定义的.
> 全局(static)变量和常量类似，但static变量不会被内联，在整个程序中，全局变量只有一个实例，也就是说所有的引用都会指向一个相同的地址. 因为全局变量可变，就会出被多个线程同时访问的情况，因而引发内存不安全的问题，所以对于全局可变(static mut)变量的访问和修改代码就必须在unsafe块中进行定义.

所有权转移: 当位置表达式出现在值上下文中, 表示将会把内存地址转移给另一个位置表达式.

**在语义上, 每个变量绑定实际上都拥有该存储单元的所有权, 这种转移内存地址的行为就是所有权(ownership)的转移, 在rust中称为移动(move)语义, 那种不转移的情况实际上是一种复制(copy)语义. **rust没有gc, 所以完全依靠所有权来进行内存管理.

rust提供引用操作符(&), 此时不转移所有权, 可直接获取表达式的存储单元地址(即内存位置), 可通过该地址对存储进行读取. 因此引用已被称为借用.

rust的作用域是静态作用域, 即词法作用域(lexical scope), 由一对花括号来开辟作用域, 该作用域在词法分析阶段就已确定, 不会动态改变.

连续用let定义同名变量的做法被称为变量遮蔽(variable shadow).

变量绑定的生命周期(lifetime): 从使用let声明创建变量绑定开始, 到超出词法作用域的范围时结束.

rust中函数是一等公民, 其自身可作为函数的参数和返回值使用.

rust编译器像C++或D语言一些, 支持编译时函数执行(compile-time function execution, CTFE), 该功能由miri(mir解析器, 已集成入rustc)来执行.

rust中固定长度的数组必须在编译期就知道长度, 否知会报错, 这就用了CTFE的能力.

`const fn`强制编译器在编译期执行函数, 其中const一般用于定义全局常量.

当前rust支持的常量有: 字面量, 元组, 数组, 字段结构体, 枚举, 只包含单行代码的块表达式, 范围等.

闭包与函数的区别: 闭包可捕获外部变量, 而函数不可以.

rust闭包实际上由一个匿名结构体和trait来组合实现的, 语法是`|params| {expr}`.

```rust
// 一般情况下, 闭包默认会按引用捕获变量, 如果将此闭包返回, 则引用也会跟着返回, 但这里随着函数调用结束, 本地变量i会被销毁, 随闭包返回的i的引用就变成了虚悬指针.
// 因此需要使用move来将被引用的变量的所有权转移到闭包中, 不再按引用捕获变量, 这样闭包才可以安全地返回.
pub fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    move |j| j * i
}
```

#### 格式化输出

打印操作由 std::fmt 里面所定义的一系列宏来处理，包括：
- format!：将格式化文本写到字符串（String）
- print!：与 format! 类似，但将文本输出到控制台（io::stdout）
- println!: 与 print! 类似，但输出结果追加一个换行符
- eprint!：与 format! 类似，但将文本输出到标准错误（io::stderr）
- eprintln!：与 eprint! 类似，但输出结果追加一个换行符

[println! format](https://doc.rust-lang.org/std/fmt/#formatting-traits):
- nothing ⇒ Display : `println!("{}",2)`
- ? ⇒ Debug : `println!("{:?}",2)`
- x? ⇒ Debug with lower-case hexadecimal integers
- X? ⇒ Debug with upper-case hexadecimal integers
- o ⇒ Octal : `println!("{:x}",2)`
- x ⇒ LowerHex : `println!("{:x}",2)`
- X ⇒ UpperHex : `println!("{:X}",2)`
- p ⇒ Pointer : `println!("{:p}",2)`
- b ⇒ Binary :  : `println!("{:b}",2)`
- e ⇒ LowerExp : `println!("{:e}",2)`
- E ⇒ UpperExp : `println!("{:E}",2)`

### 流程控制
变量绑定支持if表达式. `if ... else if ... else`: `if n <  30 {} else if n > 50 else {}`, `let x = if condition {} else {}`
rust循环支持while, loop, for...in, break/continue; 无限循环需使用loop.
rust支持match, 其使用了模式匹配(pattern matching)技术, 支持绑定模式(bingding mode, 即使用操作符@将模式中的值绑定给一个变量, 供分支右侧的代码使用). match使用`_`来兜底.
match表达式要求所有的分支都必须返回相同的类型.
rust提供if let和while let表达式, 分别在某些场合代替match表达式.

### 操作符
rust操作符优先级与类C语言(c/c++)类似.

### 基本数据类型
rust不支持将数值转为bool类型.
对于原始固定长度的数组, 只有实现了Copy trait的类型可作为其元素, 即只有在栈上存放的元素才可以存放在该类型的数组中.
slice是对一个数组(包括固定大小数组和动态数组)的引用片段.
处于内存安全考虑, rust将字符串分为两种: str字符串(也叫字符串切片), 固定长度的字符串, 通常以不可变借用的形式存在(`&str`); String字符串, 长度可变的字符串.
`& 'static str`是静态生命周期字符串. 静态生命周期即程序生命周期.
str字符串类型由两部分组成: 执行字符串序列的指针和记录长度的值.
rust字符串的本质是一段有效的utf8字节序列.

unsafe块: rust编译器将内存安全交由开发者自行负责.

rust指针包括 引用(reference), 原生指针(raw pointer), 函数指针(fn pointer)和智能指针(smart pointer).
引用的本质是非空指针.
原生指针主要用于unsafe rust中, 有两种类型: 不可变原生指针 `*const T`和可变原生指针`*mut T`.
`Box::new(20)`表示在堆内存上存储数值20.
never类型: 表示永远不可能有返回值的计算类型. panic!宏会返回never类型`!`. never类型可以强制转换为其他任何类型.

#### 智能指针
智能指针来自c++.
**rust中的值默认被分配到栈**, 可通过`Box<T>`将值装箱(在堆中分配).`Box<T>`是指向T类型堆内存变量的智能指针, 当它超出作用域时, 将调用其析构函数销毁内部对象, 并自动释放堆内存.
可通过解引用来获取`Box<T>`中的T. 因为`Box<T>`的行为像引用, 并且可以自动释放内存, 因此将其称为智能指针.

### 泛型和trait
泛型允许开发者编写一些在使用时才制定类型的代码. rust编译器会在编译期间自动为具体类型生成实现代码.
trait借鉴了Haskell的Typeclass, 是rust实现零成本抽象的基石, 其机制如下:
- trait是rust唯一的接口抽象方法
- 可以静态生成 也可以动态调用
- 可以当做标记类型拥有某些特定行为的"标签"来使用

```rust
// `<T: Debug>`表示有trait限定(trait bound)的泛型, 即只有实现了Debug trait的类型才适用. 只有实现了Debug trait的类型才拥有使用`{:?}`格式化打印的行为
fn match_opton<T: Debug>(o: Option<T>) {
    match o {
        ...
    }
}

struct Duck;
trait Fly {
    fn fly(&self) -> bool;
}
impl Fly for Duck{
    fn fly(&self) -> bool {
        return true;
    }
}
fn fly_static<T: Fly>(s: T) -> bool {
    s.fly()
}

fn fly_static(s: &Fly) -> bool {
    s.fly()
}

fn main(){
    let duck = Duck;
    fly_static::<Duck>(duck); // 静态分发, rust编译器会为`fly_static::<Duck>(duck)`这个具体类型的调用生成特殊化的代码. 即对编译器而言,该中抽象并不存在, 它在编译阶段即可将泛型展成具体类型的代码
    fly_dyn(&Duck) // 动态分发, 它会在运行时查找对应类型的方法, 需一定的运行时开销(很小). 与golang的接口类似
}
```

rust没有传统面向对象编程语言中的继承概念. 它通过trait将类型和行为明确地进行了区分, 充分贯彻了组合优于继承和面向接口编程的编程思想.

rust的trait符合c++之父提出的零开销原则: 如果不使用某个抽象, 就不用为它付出开销(静态分发); 如果确实需要使用该抽象, 可以保证这是开销最小的使用方式(动态分发).

### 错误处理
rust中的错误处理是通过返回Result<T, E>类型的方式进行的. Result<T, E>类型是Option<T>类型的升级版本.

```rust
fn main() -> Result<(), std::io::Error> {
    let f = File::open("bar.txt")?; // ?是一个错误处理的语法糖, 它会自动在出现错误的情况下返回std::io::Error.
}
```

## 类型系统
在类型系统中, 一切皆类型. 基于类型定义的一系列组合,运算和转换等方法, 可以看做类型的行为.

类型系统优势:
1. 排查错误 : 静态语言可在编译期排查的类型错误
1. 抽象 : 抽象有利于强化编程规范和工程化系统
1. 文档 : 明确的类型可表明程序的行为
1. 优化效率 : 通过类型检查来优化部分操作, 节省运行时的时间
1. 类型安全
    - 类型安全的语言可避免类型间的无效操作. 比如`3/"hello"`
    - 类型安全的语言可保证内存安全, 避免诸如空指针, 虚悬指针和缓冲区溢出等内存安全问题
    - 类型安全的语言可避免语义上的逻辑错误.

类型系统分类:
- 静态类型: 在编译期进行类型检查的语言
- 动态类型: 在运行期进行类型检查的语言
- 强类型: 不允许类型的自动隐式转换, 在强制转换前不同类型无法操作.
- 弱类型: 与强类型相对.

静态类型的语言能在编译期对代码进行静态分析, 依靠的就是类型系统.

如果一个类型系统允许在一段代码在不同的上下文中具有不同的类型, 该类型系统就叫作多态类型系统.
现代编程语言有三种多态形式:
1. 参数化多态(parametric polymorphism)即泛型

    很多时候函数或数据类型都需要适用多种类型, 以避免大量的重复性工作. 泛型使得语言极具表达力, 同时也能保证静态类型安全.

    在编译期, 都会被单态化(monomorshization, 编译器进行静态分发的一种测量, 即将为泛型生成具体对应类型的内容).

    单态化静态分发的好处是性能好, 没有运行时开销, 缺点是容易造成编译后生成的二进制文件膨胀.
1. Ad-hoc(ad-hoc polymorphism), 也叫特定多态, 指同一种行为定义在不同的上下文中会响应不同的行为实现.

    haskell使用Typeclass来支持ad-hoc, **rust使用trait来支持ad-hoc多态**.
    函数重载是ad-hoc多态.
1. 子类型多态(subtype polymorphism)

    一般用在面向对象语言中, 比如java. 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有时也可以看作父类型的值, 反之则不然.

按多态发生的时间又可分为:
1. 静多态(static polymorphism)

    发生在编译期.
    参数化多态和ad-hoc多态一般是静多态.
    静多态牺牲灵活性获取性能.
1. 动多态(dynamic polymorphism)

    发生在运行时.
    子类型多态一般是动多态.
    动多态牺牲性能获取灵活性.
    动多态在运行时需要查表, 占用较多空间, 因此一般情况下都使用静多态.

rust同时支持静多态(参数化多态+ad-hoc多态, 即泛型和trait)和动多态, 其静多态就是一种零成本抽象.

rust中一切皆表达式, 表达式皆有值, 值皆有类型 => rust中一切皆类型.

编程语言中不同类型的本质是内存空间和编码方式的不同.

rust没有gc, 内存首先由编译器分配, rust代码被编译成llvm ir, 其中就携带了内存分配信息. 所以编译器需要事先知道类型, 才好分配合理的内存.

rust多大部分是在编译期可确定内存大小的类型(sized type), 但也支持少量的动态大小类型(Dynamic sized type, DST), 比如str类型的字符串字面量; 以及零大小类型(zero sized type, zst), 比如单元类型和单元结构体, 同时由该类型组成的数组大小也为零. ZST类型的特点是, 它们的值就是其本身, 运行时并不占用内存空间.

> `&str`是引用类型(包含指针和长度信息), 存储在栈上, str字符串是存储在堆上.

胖指针(fat pointer): 包含了动态大小类型地址信息和携带了长度信息的指针, 比如`&str`, `数组[T]`.

`&[u32;5]`为普通指针, `&mut [32]`为胖指针.

never类型(低类型), 特点:
1. 没有值
1. 是其他任意类型的子类型

如果说ZST类型表示"空", 那么底类型表示"无". rust中使用`!`表示底类型.

rust中有很多情况确实没有值, 但为了类型安全, 必须把这些情况纳入类型系统进行统一处理, 包括:
1. 发散函数(diverging function)
1. continue和break
1. loop的无限循环
1. 空枚举, 比如`enum Void{}`

发散函数是指会导致线程崩溃的panic!("....")或用于退出函数的`std::process::exit`, 这类函数永远没有返回值.

rust和go类似, 只能在局部范围内进行类型推导.

`xxx::<i32>()`该形式是泛型函数标注类型, `::<>`的形式称为turbofish操作符.

### 泛型
泛型就是把一个泛化的类型作为参数.

与枚举类型额函数一样,结构体名称旁边的`<T>`叫做泛型声明. 泛型只有被声明之后才可以实现.

```rust
struct Point<T> { x: T, y: T}
impl<T> Point<T> {
    fn new(x: T,y: T) -> Self {
        Point{x:x, y:y}
    }
}
fn main() {
    let p1 = Point::new(1,2);
    let p1 = Point::new("1","2");   
}
```

### trait
trait是在行为上对类型的约束, 有4中用法:
- 接口抽象

    接口是对类型行为的统一约束, 是trait最基础的用法, 特点:
    - 接口中定义方法, 并支持默认实现
    - 接口中不能实现另一个接口, 但是接口间可以继承
    - 同一个接口可以同时被多个类型实现, 但不能被同一个类型实现多次
    - 使用trait关键字来定义接口
    - 使用impl关键字为类型实现接口方法

    ## 关联类型
    关联类型（associated types）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型. trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型.
    **rust很多操作符都是基于trait来实现的.**, 比如加法操作符:
    ```rust
    pub trait Add<RHS = Self> { // `Add<RHS = Self>`表示参数类型RHS为Self, Self是每个trait都带有的隐式类型参数, 代表实现当前trait的具体类型.
        type Output; // 关联类型. Output是一个占位类型, trait的实现者会指定 Output的具体类型.
        fn add(self, rhs: RHS) -> Self::Output;
    }

    1+2 // =>`1.add(2)` 代码中出现`+`时, rust就会自动调用操作符左侧的操作数对应的add()方法去实现具体的操作, 即`+`操作与调用`add()`等价.
    // 可看rust源码为u32实现的Add trait(用宏完成的).
    ```

    在语义层面上, 使用关联类型增强了trait表示行为的语义, 因为它表示了和某个行为(trait)相关联的类型. 在工程上, 也体现出了高内聚的特点.

    ## trait一致性
    孤儿原则(Orphan Rule): 如果要实现某个trait, 那么该trait和要实现该trait的那个类型至少有一个要在当前crate中定义. 其可限制代码被破坏性改写, 导致出现难以预料的bug.

    ## trait继承
    rust不支持传统面向对象的继承, 但支持trait继承.

    ```rust
    trait Paginatge: Page + PerPage { // 用冒号表示继承其他trait.
        ...
    }
    impl <T: Page + PerPage>Paginate for T{

    }
    ```
    
- 泛型约束

    trait限定(trait bound) : 泛型的行为被trait限定在更有限的范围内, 多个trait限定用`+`连接.

    ```rust
    use std::ops::Add;
    // 表示sum函数的参数必须实现Add trait
    fn sum<T: Add<T, Output=T>>(a: T, b:T) -> T{
        a+b
    }
    fn foo<T, K, R>(a: T, b:K, c:R) where T: A, K:B+C, R:D {...}// where用于为泛型增加较多的trait限定, 提高代码可读性.
    ```

    trait限定给予了开发者更大的自由度, 因为不再需要类型间的继承, 也简化了编译器的检查操作. 包含trait限定的泛型属于**静态分发**, 在编译期通过单态化分别生成具体类型的实例, 所以调用trait限定中的方法也都是运行时零成本的, 因为不需要在运行时再进行方法查找.
- 抽象类型

    在运行时作为一种间接的抽象类型来使用, 动态地分发给具体的类型.
-标签trait

    对类型的约束, 即直接作为一种"标签"使用.

### 标量类型
rust有四种标量数据类型(即基本数据类型, 表示只能存储单个值的类型):
- 整型

    大小 	有符号 	无符号
    8 bit 	i8 	u8
    16 bit 	i16 	u16
    32 bit 	i32 	u32
    64 bit 	i64 	u64
    128 bit 	i128 	u128
    Arch 	isize 	usize // arch 是由 CPU 构架决定的大小的整型类型, 在 x86 机器上为 32 位，在 x64 机器上为 64 位. 即isize和usize是自适应类型.
- 浮点型

    f32, f64
- 布尔类型

    true, false
- 字符类型

    char : 单个字符, 大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value）.
    char 由单引号指定，不同于字符串使用双引号.

### 复合类型
rust提供5种复合类型:
1. 数组(array) : 与元组不同，数组中的每个元素的类型必须相同. Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小.

    定义: `let a: [type; size] = {}`
    vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型.
1. 元组(Tuple) : 一种异构有序序列, 即元素类型可能不同的固定长度的序列.

    通过`tuple_name.${N}`的形式访问.
    因为let支持模式匹配, 因此可用let解构元组.
    单元值就是空元组`()`.
1. 结构体(Struct)

    结构体名称需遵从驼峰式命名规则.
    结构体上方的`#[derive(Debug, PartialEq)]`是属性, 可让结构体自行实现Debug trait 和 PartialEq trait, 即允许对struct实例进行打印(通过`{:?}或{:#?}`)和比较.

    分三种:
    1. 具名结构体(named-field struct)

        它是rust面向对象思想的一种体现.
    1. 元组结构体(tuple-like struct)

        没有字段名称, 仅有类型. 比如`struct Color(i32, i32, i32);`
        当一个元组结构体只有一个字段时, 称为New Type模式. 因为它把一种类型封装成了新类型.
    1. 单元结构体(unit-like struct)

        没有任何字段的结构体, 比如`strcut Empty{}`.
        `std::ops::RangeFull`就是一个单元结构体.

        在Release编译模式下, 单元结构体实例会被优化为同一个对象; 而在Debug模式下, 则不会进行这样的优化.

    在rust中函数和方法是有区别的, 不在impl块中定义的函数是自由函数, 而在impl块中定义的函数是方法, 第一个参数通常是`&self/&mut self`, 表示对结构体实例自身的引用.
1. 枚举体(Enum)

    分三类:
    1. 无参数枚举体

        ```rust
        enum Number {
            Zero,
            One,
        }

        let a = Number::One;
        ```
    1. 类C枚举体

        ```rust
          enum Number {
            Zero = 1 ,
            One = 2,
        }

        let a = Number::One as i32;
        ```
    1. 带类型参数的枚举体

        ```rust
          enum IpAddr {
            V4(u8,u8,u8,u8),
            V6(String),
        }

        let a = IpAddr::V4(127,0,0,1);
        let b : fn(String) -> IpAddr = IpAddr::V6;//  IpAddr::V6是 `fn(String) -> IpAddr` 函数指针.

        enum Message {
            Quit,
            Move { x: i32, y: i32 },
            Write(String),
            ChangeColor(i32, i32, i32),
        }

        // 上面那个枚举等同于有四个含有不同类型的成员
        struct QuitMessage; // 类单元结构体
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // 元组结构体
        struct ChangeColorMessage(i32, i32, i32); // 元组结构体
        ```

        **结构体和枚举还有另一个相似点：可以使用 impl 在枚举上定义方法.
1. 联合体(Union)

### 常用集合类型
std::collections提供了4种通用集合类型:
1. 线性序列: 向量(Vec), 双端队列(VecDeque), 链表(LinkedList)

    向量也是一种数组, 但可动态增长.
    `vec!`是一个宏, 用来创建向量字面量.
    rust的VecDeque是基于可增长的RingBuffer算法实现的双端队列.
    通常最好使用Vec或VecDeque类型, 因为它们比链表更加快速, 内存访问效率更高, 并且可以更好地利用cpu缓存.
1. Key-Value映射: 无序哈希表(HashMap), 有序哈希表(BTreeMap)

    key必须是可哈希的类型
    value必须是在编译期已知大小的类型
1. 集合类型: 无序集合(HashSet), 有序集合(BTreeMap)

    集合类型实际就是把Key-Value映射的Value设置成空元组.
1. 优先队列: 基于二叉最大堆(BinaryHeap)实现.

### 宏
宏语句可以使用圆括号, 中括号, 花括号, 一般使用中括号表示数组.

### 语法
用 C 语言系列风格的`//`和`/**/`表示注释.

字符串 slice（string slice）是 String 中一部分值的引用. 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.
字符串字面值就是 slice, 是一个指向二进制程序特定位置的 slice.
通用slice跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度.

#### 函数
在函数签名中，必须 声明每个参数的类型.

rust并不对返回值命名，但要在箭头（->）后声明它的类型.
在 Rust 中，函数的返回值等同于函数体最后一个表达式的值, 因此rust允许省略return.
rust不支持多返回值, 但可以利用元组来返回多个值.

#### 所有权
所有运行的程序都必须管理其使用计算机内存的方式. 一些语言中具有垃圾回收机制(go, java等)，在程序运行时不断地寻找不再使用的内存；在另一些语言中(c, c++等)，开发者必须亲自分配和释放内存. Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在**编译时**会根据一系列的规则进行检查, 在运行时，所有权系统的任何功能都不会减慢程序.

> rust的栈中的所有数据都必须占用已知且固定的大小, 在编译时大小未知或大小可能变化的数据会分配到堆上.

所有权的规则:
- Rust 中的每一个值都有一个被称为其 所有者（owner）的变量
- 值有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃

rust 内存回收策略：内存在拥有它的变量离开作用域后就被自动释放.

Rust 有一个叫做 Copy trait(类似深拷贝)的特殊注解，可以用在类似整型这样的**存储在栈上的类型上. 如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用**. Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait.

默认支持 Copy 的类型有：
- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型，char
- 元组，当且仅当其包含的类型也都是 Copy 的时候. 比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是.

不支持Copy trait的变量的所有权总是遵循相同的模式：将值赋给另一个变量时**移动**它 . 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有.

引用(`&`)语法可创建一个 指向 值 的引用，但是**并不拥有它**, **因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃**.
获取引用作为函数参数称为`借用(borrowing)`. 

引用默认不允许修改引用的值, 允许可变引用(`&mut`), 但可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用. 这个限制的好处是 Rust 可以在编译时就避免数据竞争.数据竞争（data race）类似于竞态条件，它可由这三个行为造成：
- 两个或更多指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

引用的规则:
1. 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用, 即有了可变引用后不能再使用其原始变量的不可变引用.
2. 引用必须总是有效的.

## FAQ
### 各编程语言中的类型系统
静态类型语言：在编译阶段确定所有变量的类型.
动态类型语言：在执行阶段确定所有变量的类型.
不允许隐式转换的是强类型，允许隐式转换的是弱类型.

- 没类型： 比如汇编语言，没有类型的概念，所有都只是一个数字
- 弱静态类型： 比如C/C++语言，可以定义类型，但是不强制执行，在不同类型之间自动转换
- 强静态类型： 比如Java，定义类型，并且用虚拟机检查类型
- 强动态类型： 比如Python和Ruby，动态推断类型而不需要定义，然后解释器会强制执行.
- 弱动态类型： Perl/PHP,js

> ruby和Python在运行时通过Duck Typing来进行运行时类型检查, 以保证类型安全.

![](/misc/img/rust/9zv7ejia98.jpeg)