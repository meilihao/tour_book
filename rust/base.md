# rust
参考:
- [Rust 程序设计语言（第二版 & 2018 edition）](https://kaisery.github.io/trpl-zh-cn/)
- [Rust入门第一课](https://rust-book.junmajinlong.com/ch1/00.html)

程序的三大定律:
1. 程序必须正确
1. 程序必须可维护, 但不能违反第一定律
1. 程序必须高效, 但不能违反前两条定律

rust无疑是迈向这个目标的更近一步.

编程两大难题(本质是使用类型不安全的语言, 它们的内存管理机制不完善):
1. 编写内存安全的代码
1. 编写线程安全的代码

> 在之前的年代, 计算资源匮乏, 为追求性能, 牺牲了部分安全性.

> 类型包含了值在内存中的长度、对齐以及值可以进行的操作等信息, 值是无法脱离具体的类型讨论的. 不管是强类型的语言还是弱类型的语言，语言内部都有其类型的具体表述。一般而言，编程语言的类型可以分为原生类型和组合类型两大类.

rust是一门同时追求安全,并发和性能的现代系统级编程语言.
rust三大设计哲学:
1. 内存安全

    类型安全即类型系统可以保证程序的行为是意义明确, 不出错的. c/c++的类型系统不是类型安全的, 比如它们不检查数组越界.

    > 类型安全: 类型系统给内存中的plain data赋予了类型信息，如果不按照类型信息来解释内存中的数据，应该产生编译错误或者 产生well-specified的运行时错误.

    类型安全是内存安全的前提.

    内存安全: 不会出现内存访问错误, 只有当程序访问未定义内存时才会产生内存错误. 常见的场景有:
    1. 引用空指针
    1. 使用未初始化内存
    1. 释放后再次使用, 即虚悬指针
    1. 缓冲区溢出, 比如数组越界
    1. 非法释放已释放过的指针或未分配的指针, 即重复释放

    rust为了保证内存安全, 建立了严格的安全内存管理模型:
    - 所有权系统: 每个被分配的内存都有一个独占其所有权的指针. 只有当该指针被销毁时, 其对应的内存该会被随之释放.
    - 借用和生命周期: 每个变量都有其生命周期, 一旦超出生命周期, 变量就会被自动释放. 如果是借用, 则可以通过标记生命周期参数供编译器检查的方式, 防止出现虚悬指向即释放后使用的情况.

    > rust所有权系统还包括了从现代c++借鉴的RAII机制, 这是rust无gc但是可以安全管理内存的基石. 在 C++ 中，这种 item 在生命周期结束时释放资源的模式被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）.
    > 悬垂指针（dangling pointer, 也叫虚悬指针）是其指向的内存可能已经被分配给其它持有者.

    为了实现内存安全, rust还具备具有的特性:
    1. 仿射类型(Affine Type), 该类型可用来表达rust所有权中的Move语义.

    借助类型, rust可在编译阶段对类型进行检查是否满足安全内存模型, 有效地阻止未定义行为的发生.

    内存安全bug和并发安全的bug的产生内在原因均是内存的不正当访问造成的. 借助装备了所有权的强大类型系统, rust还解决了并发安全问题. 它通过静态检查分析, 在编译期就能检查出多线程并发代码中所有的数据竞争问题.
1. 零成本抽象即如果不使用某个抽象, 就不用为它付出开销.

    rust的绝大多数抽象并不存在运行时的开销, 其一切都是在编译期完成的.

    rust的零成本抽象的基石是泛型和trait.
1. 实用性

    为了保证支持硬实时, rust借鉴了c++的确定性析构, RAII和智能指针, 用于自动地, 确定地管理内存, 从而避免了gc的引入.

    为了保证程序的鲁棒性, rust重新审视了错误处理机制. rust针对三类非正常情况: 失败, 错误和异常, 提供了专门的处理方式:
    - 失败: 使用断言工具
    - 错误: 基于返回值的分层处理 
    - 异常: rust将其看作无法被合理解决的问题, 提供了线程恐慌机制, 发生异常时, 线程可以安全地退出.

    为了兼容现有生态, rust支持方便且零成本的FFI机制, 兼容C-ABI, 在语言架构层面上将rust分为safe rust和unsafe rust两部分. unsafe专门和外部生态打交道, 因为rust编译器检查和跟踪的范围有限, 不能检查到与其链接的其他生态接口, 因此这些生态由自身来保证安全性. 总结就是, safe rust由rust编译器在编译时保证安全, unsafe rust开发者让编译器信任自身有能力保证安全.

rust编程的哲学和golang相同: 组合优于继承. rust不提供类型层面上的继承, 所有的类型都是独立存在的.

### 编译
rust编译器是LLVM编译器的前端, 它将代码编译成LLVM IR, 然后通过LLVM编译成对应架构的机器码.

rust源码经过分词和解析生成AST(抽象语法树), 再进一步简化处理为HIR(High-level IR, 方便编译器做类型检查), 再进一步编译为[MIR](https://play.rust-lang.org/)(middle IR, 在rust 1.12引入), 最后MIR被翻译为LLVM IR, 之后由LLVM编译成目标机器码.

引入MIR原因:
1. 缩短编译时间

    实现了增量编译, 仅重新编译更改过的部分.
1. 缩短执行时间

    进入llvm前实现更细颗粒度的优化, 单纯依赖llvm的优化颗粒度太粗, 增加了更多的优化空间
1. 更精确的类型检查

    实现更灵活的借用检查

MIR是基于控制流图（Control Flow Graph，CFG）的抽象数据结构，它用有向图（DAG）形式包含了程序执行过程中所有可能的流程, 所以将基于MIR的借用检查称为非词法作用域的生命周期, 因此确实不依赖词法作用域了.

MIR由一下关键部分组成：
- 基本块（Basic block，bb），他是控制流图的基本单位，
    
    - 语句（statement）
    - 终止句（Terminator）

- 本地变量, 栈中内存的位置，比如函数参数、局部变量等. 一般用下划线和数字作为标识(比如`_1`), 其中`_0`通常表示返回地址.
- 位置（Place），在内存中标识未知的额表达式。
- 右值（RValue），产生值的表达式。


> LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time), 链接时间(link-time), 运行时间(run-time)以及空闲时间(idle-time).

> 无疑，不同编译器的中间语言IR是不一样的，而IR可以说是集中体现了这款编译器的特征：它的算法，优化方式，汇编流程等等，想要完全掌握某种编译器的工作和运行原理，分析和学习这款编译器的中间语言无疑是重要手段. 由于中间语言相当于一款编译器前端和后端的“桥梁”，如果我们想进行基于LLVM的后端移植，无疑需要开发出对应目标平台的编译器后端，想要顺利完成这一工作，透彻了解LLVM的中间语言无疑是非常必要的工作. LLVM相对于gcc的一大改进就是大大提高了中间语言的生成效率和可读性, LLVM的中间语言是一种介于c语言和汇编语言的格式, 它既有高级语言的可读性, 又能比较全面地反映计算机底层数据的运算和传输的情况, 精炼而又高效.

rust语言组成:
- 语言规范
- 编译器
- 核心库

    定义了rust语言的核心, 不依赖于操作系统和网络等相关的库, 不负责堆分配,不提供并发和I/O.
    通过在模块顶部引入`#![no_std]`来使用核心库.
    组成:
    1. 基础trait, 如Copy, Debug, Display,Option等
    1. 基本原始类型, 如 bool, char,i8/u8,..i64/u64, isize/usize, f32/f64, str, array, slic, tuple, pointer等
    1. 常用功能型数据类型, 比如String, Vec, HashMap, Rc, Arc,Box等

        String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型.

        Rust 标准库中还包含一系列其他字符串类型，比如 OsString、OsStr、CString 和 CStr, 前缀(非String/非Str)对应着它们提供的所有权和可借用的字符串变体.

        使用 to_string 方法从字符串字面值创建 String: `"...".to_string()` <=> `String::from("...")`.

        **Rust 的字符串不支持索引**.

        遍历: `for c in "नमस्ते".chars()`或`for b in "नमस्ते".bytes()`.
    1. 常用的宏定义, 如println()!, assert!, panic!, vec!

        Rust 中的宏(`!`)与C/C＋＋ 中的宏是完全不一样的东西. 简单点说，可以把它理解为一种安全版的编译期语法扩展, 这里之所以使用宏，而不是函数，是因为标准输出宏可以完成编译期格式检查. 更加安全. 这个宏最终还是调用了`std::io`模块内提供的一些函数来完成的. 如果需要更精细地控制标准输出操作, 也可以直接调用标准库来完成.

    做嵌入式应用开发时, 核心库是必需的.
- 标准库

    提供应用程序开发所需的基础和跨平台支持.

    组成:
    1. 与核心库一样的基本trait, 原始数据类型, 功能型数据类型和常用的宏等, 以及与核心库几乎完全一致的API.
    1. 并发, I/O和运行时.
    
        如线程模块,  用于消息传递的通道类型, Sync trait等并发模块; 文件, tcp, udp, 管道, socket等常见I/O.
    1. 平台抽象.
        - os模块提供了许多与操作环境交互的基本功能, 包括程序参数, 环境变量, 目录导航
        - 路径模块封装了处理文件路径的平台特定规则.
    1. 底层操作接口

        如std::mem,std::ptr, std::intrinsic等, 操作内存,指针, 调用编译器固有函数.

    1. 可选和错误处理类型Option(表示一个值要么有值要么没值)和Result, 以及各种迭代器.

    Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举, 这个枚举是 Option<T>，而且它定义于标准库中.

### Rust命令规范
> rust使用蛇形命名法(snake case)来规范函数和变量名称的风格: 只使用小写的字母进行命名, 并以`_`分割word.

- 函数： 蛇形命名法（snake_case），例如：func_name()
- 文件名： 蛇形命名法（snake_case），例如file_name.rs、main.rs
- 临时变量名：蛇形命名法（snake_case）
- 全局变量名：
- 结构体： 大驼峰命名法，例如：struct FirstName { name: String}
- enum类型: 大驼峰命名法
- 关联常量：常量名必须全部大写
- Cargo默认会把连字符`-`转换成下划线`_`
- Rust也不建议以`-rs`或`_rs`为后缀来命名包名, 而且会强制性的将此后缀去掉
  
### 语句和表达式
Rust 是一门基于表达式（expression-based）的语言. 语句（Statements）是执行一些操作但不返回值的指令. 表达式（Expressions）计算并产生一个值.

> 使用 let 关键字创建变量并绑定一个值是一个语句, 因为语句不返回值， 因此，不能把 let 语句赋值给另一个变量. 在C语言或Ruby语言中的赋值语句会返回所赋的值, 因此`x = y = 6`是正确的, 它使得x和y变量同时拥有6这个值; 而rust不能这样写.

> Rust 源代码的后缀名使用`.rs`表示, 且必须使用 utf-8 编码.
rust类型没有“默认构造函数”，变量没有“默认值” .
Rust 里面的下划线是一个特殊 的标识符，在编译器内部它是被特殊处理的.

rust语法分语句(statement, 要执行的一些操作和产生副作用的表达式)和表达式(expression, 主要用于计算求值). 它们的区别是后面带不带分号.

语句分类:
- 声明语句(Declaration statement) : 用于声明各种语言项(item), 比如变量, 静态变量, 常量, 结构体, 函数等, 以及通过extern和use关键词引入的包和模块等.
- 表达式语句(expression statement) : 特指以分号结尾的表达式. 此类表达式求值结果会被舍弃, 并总是返回单元类型`()`.

表达式分类:
- 赋值表达式

    类型是unit, 即空的`tuple()`
- 字面量表达式
- 方法调用表达式
- 数组表达式
- 索引表达式
- 单目/双目运算符表达式等

表达式的其他分类:
- 左值 : 这个表达式可以表示一个内存地址, 因此它在赋值运算符的左边
- 右值 : 除左值外的值

rust编译器解析代码时, 如果遇到分号, 就会继续往后面执行; 如果碰到语句, 则执行语句; 如果碰到表达式, 则会对表达式求值, 如果分号后面什么都没有, 就会补上单元值;  当
遇到函数时, 会将函数体的花括号识别为块表达式(block expression, 由一对花括号和一系列表达式组成, 它总是返回块中最后一个表达式的值)

> 赋值号左边的部分是一个“模式”，`let (mut a, mut b) = (1, 2);`是对 tuple 的模式解构，`let Point { x : ref a, y : ref b} = p;`是对结构体的模式解构.

> 模式匹配可能导致变量所有权转移, 使用ref可避免该情况. ref是模式的一部分, 它只能出现在赋值操作符的左边. `&`是借用运算符, 是表达式的一部分, 只能出现在赋值操作符的右边.

> mut在模式匹配中是修饰变量绑定, `&mut`是表示引用, mut的意义完全不同.

let创建的变量一般称为绑定(bingding).

rust的表达式可分为位置表达式(place expression)和值表达式(value expression), 即其他语言中的左值和右值.

位置表达式就是表示内存位置的表达式, 分别有如下几类:
1. 本地变量
1. 静态变量
1. 解引用(*expr)
1. 数组索引(expr[expr])
1. 字段引用(expr.field)
1. 位置表达式组合

通过位置表达式可对某个数据单元的内存进行读写.
值表达式一般只引用了某个存储单元地址中的数据, 它相当于数据值, 只能进行读操作.

**从语法角度讲, 位置表达式代表了持久化数据, 值表达式代表了临时数据.**

表达式的求值过程可分为位置上下文(place context)和值上下文(value context).

let关键字声明位置表达式默认不可变, 即**不可变绑定**, 只能对对应的存储单元进行读取. 引用与变量一样，默认情况下 也是不可变的.
let mut声明的**可变绑定**可以对相应的存储单元进行写入.

> 在 Rust 中，一般把声明的局部变量并初始化的语句称为`变量绑定`, 强调的是“绑定”的含义，与 C/C＋＋ 中的“赋值初始化”语句有所区别: Rust中，每个变量必须被合理初始化之后才能被使用, 使用未初始化变量这样的错误，在Rust 中是不可能出现的 （利用 unsafe 做 hack 除外）. 编译器会帮我们做一个执行路径的静态分析，确保变量在使用前一定被初始化.
> 类型一定是跟在冒号`:`后面, 这样语法歧义更少，语法分析器更容易编写.

> rust支持定义一个与之前变量同名的新变量，而新变量会隐藏(shadow)之前的变量. 隐藏区别于mut: 隐藏会创建新变量, 同时可改变其类型.
> const(常量)可以在任意作用域进行定义，而定义的常量贯穿整个程序的生命周期. 在编译的时候，常量就能确定其值, 编译器不一定会给const分配内存空间, 同时编译器**会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址**；对于变量出现重复的定义(绑定)会发生变量遮盖，而对于常量则是不允许出现重复的定义的.
> 全局(static)变量和常量类似，但static变量不会被内联，在整个程序中，全局变量只有一个实例, **必须是编译期可确定的常量**，也就是说所有的引用都会指向一个相同的地址. 因为全局变量可变，就会出被多个线程同时访问的情况，因而引发内存不安全的问题，所以对于全局可变(static mut)变量的访问和修改代码就必须在unsafe块中进行定义. 声明static变量时禁止调用普通函数, 但const fn可以, 因为const fn是编译时执行的.

在存储的数据比较大，需要引用地址或具有可变性的情况下使用静态变量. 否则，应该优先使用普通常量. 推荐使用lazy_static实现复杂的static变量初始化.

所有权转移: 当位置表达式出现在值上下文中, 表示将会把内存地址转移给另一个位置表达式.

**在语义上, 每个变量绑定实际上都拥有该存储单元的所有权, 这种转移内存地址的行为就是所有权(ownership)的转移, 在rust中称为移动(move)语义, 那种不转移的情况实际上是一种复制(copy)语义. **rust没有gc, 所以完全依靠所有权来进行内存管理.

rust提供引用操作符(&), 此时不转移所有权, 可直接获取表达式的存储单元地址(即内存位置), 可通过该地址对存储进行读取. 因此引用已被称为借用.

rust的作用域是静态作用域, 即词法作用域(lexical scope), 由一对花括号来开辟作用域, 该作用域在词法分析阶段就已确定, 不会动态改变.

Rust允许在同一个代码块中声明同样名字的变量的做法被称为变量遮蔽(variable shadow), **个人强烈不推荐使用**.

变量绑定的生命周期(lifetime): 从使用let声明创建变量绑定开始, 到超出词法作用域的范围时结束.

rust中函数是一等公民, 其自身可作为函数的参数和返回值使用.

rust编译器像C++或D语言一些, 支持编译时函数执行(compile-time function execution, CTFE), 该功能由miri(mir解析器, 已集成入rustc)来执行.

rust中固定长度的数组必须在编译期就知道长度, 否知会报错, 这就用了CTFE的能力.

`const fn`强制编译器在编译期执行函数, 其中const一般用于定义全局常量.

当前rust支持的常量有: 字面量, 元组, 数组, 字段结构体, 枚举, 只包含单行代码的块表达式, 范围等.

闭包与函数的区别: 闭包可捕获外部变量, 而函数不可以.

rust闭包实际上由一个匿名结构体和trait来组合实现的, 语法是`|params| {expr}`.

```rust
// 一般情况下, 闭包默认会按引用捕获变量, 如果将此闭包返回, 则引用也会跟着返回, 但这里随着函数调用结束, 本地变量i会被销毁, 随闭包返回的i的引用就变成了虚悬指针.
// 因此需要使用move来将被引用的变量的所有权转移到闭包中, 不再按引用捕获变量, 这样闭包才可以安全地返回.
pub fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    move |j| j * i
}
```

#### 格式化输出

打印操作由 std::fmt 里面所定义的一系列宏来处理，包括：
- format!：将格式化文本写到字符串（String）
- print!：与 format! 类似，但将文本输出到控制台（io::stdout）
- println!: 与 print! 类似，但输出结果追加一个换行符
- eprint!：与 format! 类似，但将文本输出到标准错误（io::stderr）
- eprintln!：与 eprint! 类似，但输出结果追加一个换行符

[println! format](https://doc.rust-lang.org/std/fmt/#formatting-traits):
- nothing(即默认)⇒ Display : `println!("{}",2)`
- ? ⇒ Debug : `println!("{:?}",2)`
- x? ⇒ Debug with lower-case hexadecimal integers
- X? ⇒ Debug with upper-case hexadecimal integers
- :#? ⇒ 带换行和缩进的Debug打印 : `println!("{:#?}",("t1","t2"))` 
- o ⇒ Octal : `println!("{:o}",2)`
- x ⇒ LowerHex : `println!("{:x}",2)`
- X ⇒ UpperHex : `println!("{:X}",2)`
- p ⇒ Pointer : `println!("{:p}",&2)`
- b ⇒ Binary :  : `println!("{:b}",2)`
- e ⇒ LowerExp : `println!("{:e}",2)`
- E ⇒ UpperExp : `println!("{:E}",2)`
- 命名参数       : `println!("{a} {b} {b}",a = "x", b="y")`

### 控制流
> 代码中的条件表达式必须产生一个bool类型的值，否则就会触发编译错误. 不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值.

变量绑定支持if表达式. `if ... else if ... else`: `if n <  30 {} else if n > 50 else {}`, `let x = if condition {} else {}`

rust循环支持while, loop, for...in, break/continue. 无限循环需使用loop; for常用于循环遍历集合, for 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构.

Range是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列, 例如`1..4`.

rust支持match, 其使用了模式匹配(pattern matching)技术, 支持绑定模式(bingding mode, 即使用操作符@将模式中的值绑定给一个变量, 供分支右侧的代码使用). Rust 中的匹配是 穷尽的（exhaustive）：必须穷举到最后的可能性来使代码有效. 通常match使用`_`来兜底.

一个 match 表达式由 分支（arms） 构成. 一个分支包含一个 模式（pattern）和表达式开头的值与分支模式相匹配时应该执行的代码. Rust 获取提供给 match 的值并挨个检查每个分支的模式. match 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并**确保没有遗漏处理, 否则无法通过编译**.

match表达式要求所有的分支都必须返回相同的类型,且如果是一个单独的match表达式而不是赋值给变量时，每个分支必须返回()类型.
rust提供if let和while let表达式, 分别在某些场合代替match表达式.

> if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值. 在 if let 中可包含一个 else, else 块中的代码与 match 表达式中的 `_` 分支块中的代码相同.

> 因为 if 是一个表达式，我们可以在 let 语句的右侧使用它.

### 操作符
rust操作符优先级与类C语言(c/c++)类似.

对于原始固定长度的数组, 只有实现了Copy trait的类型可作为其元素, 即只有在栈上存放的元素才可以存放在该类型的数组中.
slice是对一个数组(包括固定大小数组和动态数组)的**引用**片段. 在底层，切片代表一个指向数组起始位置的指针和数组长度. 如果用`[T]`类型表示连续序列，那么切片类型就是`&[T]`和`&mut[T]`.

unsafe块: rust编译器将内存安全交由开发者自行负责.

### 泛型和trait
泛型允许开发者编写一些在使用时才制定类型的代码. rust编译器会在编译期间自动为具体类型生成实现代码.
trait借鉴了Haskell的Typeclass, 是rust实现零成本抽象的基石, 其机制如下:
- trait是rust唯一的接口抽象方法
- 可以静态生成 也可以动态调用
- 可以当做标记类型拥有某些特定行为的"标签"来使用

```rust
// `<T: Debug>`表示有trait限定(trait bound)的泛型, 即只有实现了Debug trait的类型才适用. 只有实现了Debug trait的类型才拥有使用`{:?}`格式化打印的行为
fn match_opton<T: Debug>(o: Option<T>) {
    match o {
        ...
    }
}

struct Duck;
trait Fly {
    fn fly(&self) -> bool;
}
impl Fly for Duck{
    fn fly(&self) -> bool {
        return true;
    }
}
fn fly_static<T: Fly>(s: T) -> bool {
    s.fly()
}

fn fly_static(s: &Fly) -> bool {
    s.fly()
}

fn main(){
    let duck = Duck;
    fly_static::<Duck>(duck); // 静态分发, rust编译器会为`fly_static::<Duck>(duck)`这个具体类型的调用生成特殊化的代码. 即对编译器而言,该中抽象并不存在, 它在编译阶段即可将泛型展成具体类型的代码
    fly_dyn(&Duck) // 动态分发, 它会在运行时查找对应类型的方法, 需一定的运行时开销(很小). 与golang的接口类似
}
```

rust没有传统面向对象编程语言中的继承概念. 它通过trait将类型和行为明确地进行了区分, 充分贯彻了组合优于继承和面向接口编程的编程思想.

rust的trait符合c++之父提出的零开销原则: 如果不使用某个抽象, 就不用为它付出开销(静态分发); 如果确实需要使用该抽象, 可以保证这是开销最小的使用方式(动态分发).

### 错误处理
rust中的错误处理是通过返回Result<T, E>类型的方式进行的. Result<T, E>类型是Option<T>类型的升级版本.

```rust
fn main() -> Result<(), std::io::Error> {
    let f = File::open("bar.txt")?; // ?是一个错误处理的语法糖, 它会自动在出现错误的情况下返回std::io::Error.
}
```

## 类型系统
在类型系统中, 一切皆类型. 基于类型定义的一系列组合,运算和转换等方法, 可以看做类型的行为.

类型系统优势:
1. 排查错误 : 静态语言可在编译期排查的类型错误
1. 抽象 : 抽象有利于强化编程规范和工程化系统
1. 文档 : 明确的类型可表明程序的行为
1. 优化效率 : 通过类型检查来优化部分操作, 节省运行时的时间
1. 类型安全
    - 类型安全的语言可避免类型间的无效操作. 比如`3/"hello"`
    - 类型安全的语言可保证内存安全, 避免诸如空指针, 虚悬指针和缓冲区溢出等内存安全问题
    - 类型安全的语言可避免语义上的逻辑错误.

类型系统分类:
- 静态类型: 在编译期进行类型检查的语言
- 动态类型: 在运行期进行类型检查的语言
- 强类型: 不允许类型的自动隐式转换, 在强制转换前不同类型无法操作.
- 弱类型: 与强类型相对.

静态类型的语言能在编译期对代码进行静态分析, 依靠的就是类型系统.

如果一个类型系统允许在一段代码在不同的上下文中具有不同的类型, 该类型系统就叫作多态类型系统.
现代编程语言有三种多态形式:
1. 参数化多态(parametric polymorphism)即泛型

    很多时候函数或数据类型都需要适用多种类型, 以避免大量的重复性工作. 泛型使得语言极具表达力, 同时也能保证静态类型安全.

    在编译期, 都会被单态化(monomorshization, 编译器进行静态分发的一种测量, 即将为泛型生成具体对应类型的内容).

    单态化静态分发的好处是性能好, 没有运行时开销, 缺点是容易造成编译后生成的二进制文件膨胀.
1. Ad-hoc(ad-hoc polymorphism), 也叫特定多态, 指同一种行为定义在不同的上下文中会响应不同的行为实现.

    haskell使用Typeclass来支持ad-hoc, **rust使用trait来支持ad-hoc多态**.
    函数重载是ad-hoc多态.
1. 子类型多态(subtype polymorphism)

    一般用在面向对象语言中, 比如java. 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有时也可以看作父类型的值, 反之则不然.

按多态发生的时间又可分为:
1. 静多态(static polymorphism)

    发生在编译期.
    参数化多态和ad-hoc多态一般是静多态.
    静多态牺牲灵活性获取性能.
1. 动多态(dynamic polymorphism)

    发生在运行时.
    子类型多态一般是动多态.
    动多态牺牲性能获取灵活性.
    动多态在运行时需要查表, 占用较多空间, 因此一般情况下都使用静多态.

rust同时支持静多态(参数化多态+ad-hoc多态, 即泛型和trait)和动多态, 其静多态就是一种零成本抽象.

rust中一切皆表达式, 表达式皆有值, 值皆有类型 => rust中一切皆类型.

编程语言中不同类型的本质是内存空间和编码方式的不同.

rust没有gc, 内存首先由编译器分配, rust代码被编译成llvm ir, 其中就携带了内存分配信息. 所以编译器需要事先知道类型, 才好分配合理的内存.

rust多大部分是在编译期可确定内存大小的类型(sized type), 但也支持少量的动态大小类型(Dynamic sized type, DST), 比如str类型的字符串字面量; 以及零大小类型(zero sized type, zst), 比如单元类型和单元结构体, 同时由该类型组成的数组大小也为零. ZST类型的特点是, 它们的值就是其本身, 运行时并不占用内存空间.

> Rust 的核心语言中只有一种字符串类型：`str`, 字符串 slice(是一些储存在别处的 UTF-8 编码字符串数据的引用)，它通常以被借用的形式出现即`&str`. `&str`是引用类型(包含指针和长度信息), 存储在栈上, str字符串是存储在堆上.

胖指针(fat pointer): 比正常指针携带更多信息的指针, 比如包含了动态大小类型地址信息和携带了长度信息的指针, 比如`&str`, `数组[T]`.

`&[u32;5]`为普通指针, `&mut [32]`为胖指针.

动态大小类型(Dynamic sized type, dst)是指编译阶段无法确定占用空间的类型, 为了安全, 指向dst的指针一般是胖指针. 胖指针的设计, 避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题, 保证了类型安全.

对于 DST 类型, Rust 有如下限制:
- 只能通过指针来间接创建和操作 DST 类型, `＆[T] Box<[T]`可以, [T]不可以
- 局部变量和函数参数的类型不能是 DST 类型, 因为局部变量和函数参数必须在编译阶段知道它的大小, 因为目前unsized rvalue 功能还没有实现
- enum不能包 DST类型, struct 中只有最后一个元素 以是 DST, 其他成员不行, 如果包含有 DST 类型, 那么这个结构体也就成了 DST 类型.

never类型(低类型)表示永远不可能有返回值的类型, 特点:
1. 没有值
1. 是其他任意类型的子类型, 因此**可强制转换为其他任何类型**

如果说ZST类型表示"空", 那么底类型表示"无". rust中使用`!`表示底类型.

rust中有很多情况确实没有值, 但为了类型安全, 必须把这些情况纳入类型系统进行统一处理, 包括:
1. 发散函数(diverging function)

    返回类型是`!`, 表示该代码永远不会返回. 发散类型可转为任意一种类型.
1. continue和break
1. loop的无限循环
1. 空枚举, 比如`enum Void{}`

发散函数有:
1. 导致线程崩溃的panic!("....")以及基于它实现的各种函数/宏, 比如unimplemented!, unreachable!
1. 死循环loop{}
1. 用于退出函数的`std::process::exit`, 这类函数永远没有返回值.

rust和go类似, 只能对局部变量/全局变量进行类型推导, 而函数签名等场景下是不允许的, 这是有意为之. 同时rust使用`as`显式转换类型.

`xxx::<i32>()`该形式是泛型函数标注类型, `::<>`的形式称为turbofish操作符.

## 数据类型
很多编程语言中的数据类型是分为两类：
- 值类型

    一般是指可以将数据都保存在同一位置的类型, 例如数值、布尔值、结构体等都是值类型

    值类型有:
    - 原生类型
    - 结构体
    - 枚举体

- 引用类型

    会存在一个指向实际存储区的指针. 比如通常一些引用类型会将数据存储在堆中，而栈中只存放指向堆中数据的地址（指针）

    引用类型有：
    - 普通引用类型(裸指针), 比如go的指针
    - 原生指针类型, 比如go的slice, map, chan

随着类型越来越丰富, 值类型和引用类型难以描述全部情况, rust所以引入了：
- 值语义（Value Semantic）

    复制以后，两个数据对象拥有的存储空间是独立的，互不影响

    基本的原生类型都是值语义，这些类型也被称为 POD（Plain old data）. POD 类型都是值语义，但是值语义类型并不一定都是 POD 类型

    具有值语义的原生类型，在其作为右值进行赋值操作时，**编译器会对其进行按位复制**

- 引用语义（Reference Semantic）

    复制以后，两个数据对象互为别名. 操作其中任意一个数据对象，则会影响另外一个.

    智能指针Box<T>封装了原生指针，是典型的引用类型. Box<T>无法实现 Copy，意味着它被 rust 标记为了引用语义，禁止按位复制.

    引用语义类型不能实现 Copy，但可以实现 Clone 的 clone 方法，以实现深复制.


在 Rust 中，可以通过是否实现 Copy trait 来区分数据类型的值语义和引用语义. 但为了更加精准，Rust 也引用了新的语义：复制（Copy）语义和移动（Move）语义
- Copy语义：对应值语义, 即实现了 Copy 的类型在进行按位复制时是安全的
- Move语义：对应引用语义, 在 Rust 中不允许按位复制，只允许移动所有权

实现了 Copy trait的作用: 实现 Copy trait 的类型同时拥有复制语义，在进行赋值或者传入函数等操作时，默认会进行按位复制.

对于默认可以安全的在栈上进行按位复制的类型，就只需要按位复制，也方便管理内存.
对于默认只可在堆上存储的数据，必须进行深度复制. 深度复制需要在堆内存中重新开辟空间，这会带来更多的性能开销.

#### 哪些实现了 Copy
- 结构体 ：当成员都是复制语义类型时，不会自动实现 Copy
- 枚举体 ：当成员都是复制语义类型时，不会自动实现 Copy
- 元组类型 ：本身实现了 Copy. 如果元素均为复制语义类型，则默认是按位复制，否则执行移动语义
- 字符串字面量 &str： 支持按位复制

结构体 && 枚举体：
1. 所有成员都是复制语义类型时，需要添加属性#[derive(Debug,Copy,Clone)]来实现 Copy
1. 如果有移动语义类型的成员，则无法实现 Copy

#### 哪些未实现 Copy
String ：to_string() 可以将字符串字面量转换为String

#### 哪些实现了 Copy trait
原生整数类型

对于实现 Copy 的类型，其 clone 方法只需要简单的实现按位复制即可.

#### 哪些未实现 Copy trait
- Box<T>

### 标量(scalar)数据类型
rust有四种标量数据类型(即基本数据类型, 表示只能存储单个值的类型):
#### 整型
> 整数 是一个没有小数部分的数字. 有符号整数范围: -2^(n-1)~2^(n-1)-1; 无符号范围: 0~2^n-1

    大小  有符号     无符号
    8 bit   i8  u8
    16 bit  i16     u16
    32 bit  i32     u32
    64 bit  i64     u64
    128 bit     i128    u128
    Arch    isize   usize // arch 是由 CPU 构架决定的大小的整型类型, 在 x86 机器上为 32 位，在 x64 机器上为 64 位. 即isize和usize是自适应类型, 它们主要作为某些集合的索引.

    > 所有数值字面量支持任意位置添加`_`以方便阅读, 并且支持后缀表示类型, 比如`0x_ff_u8`

    > 整数自动推导时**默认是i32**

c中无符号算术运算永远不会overflow, 如果超出范围则自动舍弃高位数据; 有符号如果发生了overflow, 则是undefined behavior, 由编译器处理. rust在debug模式下编译器自动插入溢出检查, 一旦溢出就panic; 在release下, 不检查整数溢出, 而是自动舍弃高位即二进制补码包装（two’s complement wrapping）的操作. rustc可使用`-C overflow-checks=no/yes`决定是否开启溢出检查.


开发者可以调用标准库中的`checked_*, saturating_*, wrapping_*`系列函数更精细地自主控制整数溢出的行为:
- `checked_*`系列函数返回的类型是`Option<_>`, 当出现溢出的时候，返回None
- `saturating_`系列函数返回类型是整数, 如果溢出，则给出该类型可表示范围的`最大/最小`值
- `wrapping_*`系列函数则是直接抛弃已经溢出的最高位, 将剩下的部分返回.

在对安全性要求非常高的情况下, 强烈建议用户尽量使用这几个方法替代默认的算术运算符来做数学运算. rust 标准库中就大量使用了这几个方法. ，标准库还提供了一个叫作`std::num::Wrapping<T>`的类型, 它重载了基本的运算符， 可以被当成普通整数使用, 凡是被它包起来的整数, 任何时候出现溢出都是截断行为.

```rust
fn main() { 
    let i = 10 0 i8; 
    println! ("checked { : ?}", i.checked_add(i)); 
    println! ("saturating {:?}", i.saturating_add(i)); 
    println! ("wrapping {:?}", i. wrapping_add( i));
}

输出结果为:
checked None
saturating 127
wrapping - 56
```
#### 浮点型
rust提供基于IEEE-754-2008标准的浮点类型: f32/f64. `std::num::FpCategory`可表示浮点状态(`Nan/Infinite/Zero/Subnormal/Normal`), 默认是f64.

> 非0数除以0是inf; 0除以0是Nan; `inf * 0.0`=Nan; `inf/inf`=NaN.

#### 布尔类型

    true, false
#### 字符类型

char : 单个字符, 大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value）, 等价于go的rune. char 由单引号指定，不同于字符串使用双引号.

> Unicode 标量值包含从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF 在内的值.

ASCII字符(1B) : u8

处于内存安全考虑, rust将字符串分为两种:
- [str](https://github.com/rust-lang/rust/blob/master/library/core/src/str/mod.rs#L122)字符串(也叫字符串切片, 内置类型, 是DST类型), 固定长度的字符串, 通常以不可变借用的形式存在(`&str`)

    rust字符串因为包含长度, 因此不是以`\0`表示结束.

    `&str`字符串类型由两部分组成：
    1. 指向字符串序列的指针
    2. 记录长度的值

    `&str`存储于栈上, str字符串序列存储于程序的静态只读数据段, 栈或者堆内存中. `&str`是一种胖指针.
- String字符串, 长度可变的字符串, 与`&str`的主要区别是它有管理内存空间的能力, 而`&str`没有.

    创建方法: `let s = String::from("hello")`, 两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字.

    String类型本质是一个成员变量为`Vec<u8>`类型的结构体，所以它是直接将字符内容存放于堆中的.

    String类型由三部分组成：
    - 执行堆中字节序列的指针（as_ptr方法）
    - 记录堆中字节序列的字节长度（len方法）
    - 堆分配的容量（capacity方法）

`& 'static str`是静态生命周期字符串. 静态生命周期即程序生命周期.

rust字符串的本质是一段有效的utf8字节序列.

Rust中的字符串不能使用索引访问其中的字符，但可以通过bytes和chars两个方法来分别返回按字节和按字符迭代的迭代器.

Rust提供了另外两种方法：get和get_mut来通过指定索引范围来获取字符串切片.

#### 引用/指针
引用是用`&`和`& mut`操作符来创建, 受Rust的安全检查规则的限制.

引用是Rust提供的一种指针语义. 引用是基于指针的实现，它与指针的区别是：指针保存的是其指向内存的地址，而引用可以看做某块内存的别名（Alias）.

裸指针(原生指针):`*const T和*mut T`, 可以在unsafe块下任意使用, 不受Rust的安全检查规则的限制.

智能指针实际上是一种结构体，只是行为类似指针, 智能指针是对指针的一层封装，提供了一些额外的功能，比如自动释放堆内存.

智能指针区别于常规结构体的特性在于：它实现了Deref和Drop这两个trait:
- Deref：提供了解引用能力
- Drop：提供了自动析构的能力

智能指针拥有资源的所有权，而普通引用只是对所有权的借用.

无GC的编程语言, 如c,c++以及Rust, 对数据的组织操作有更多的自由度:
- 同一个类型, 某些时候可以指定它在栈上; 某些时候可以指定它在堆上. 内存分配方式可以取决于使用方式, 与类型本身无关
- 既可以直接访问数据, 也可以通过指针间接访问数据. 可以针对任何一个对象取得指向它的指针
- 既可以在复合数据类型中直接嵌入别的类型的实体, 也可以使用指针间接指向别的类型
- 甚至可能在复合数据类型末尾嵌入不定长数据构造出不定长的复合数据类型

Rust里面也有指针类型, 而且不止一种指针类型, 常见的几种指针类型:
- `Box<T>` : 指向类型T的, 具有所有权的指针, 有权释放内存

    Rust中的值默认被分配到栈内存, 可通过`Box<T>`将值装箱(在堆内存中分配). 可通过解引用来获取`Box<T>`中的T. 因为`Box<T>`的行为像引用, 并且可以自动释放内存, 因此将其称为智能指针.

    String类型和Vec类型的值都是被分配到堆内存并返回指针的，通过将返回的指针封装来实现Deref和Drop.

    Box<T>是指向类型为T的堆内存分配值的智能指针. 当Box<T>超出作用域范围时，将调用其析构函数，销毁内部对象，并自动释放堆中的内存.
- `&T` : 指向类型T的借用指针, 也称为引用, 无权释放内存, 无权写数据
`&mnut T` : 指向类型T的mut型借用指针, 无权释放内存, 有权写数据
`*const T` : 指向类型T的只读裸指针, 没有生命周期信息, 无权写数据
`*mut T` : 指向类型T的可读写裸指针, 没有生命周期信息, 有权写数据

此之外，在标准库中还有一种封装起来的可以当作指针使用的类型, 即智能指针(smart pointer, 来自c++):
- `Rc<T>` : 指向类型T的引用计数指针, 共享所有权, 线程不安全

    通过clone方法共享的引用所有权称为强引用，RC<T>是强引用.
- `Arc<T>` : 指向类型T的原子型引用计数指针, 共享所有权, 线程安全
- `Cow<’a, T>` : Clone-on-write, 写时复制指针. 可能是借用指针, 也可能是具有所有权的指针 

    Cow<T>的功能是：以不可变的方式访问借用内容，以及在需要可变借用或所有权的时候再克隆一份数据. Cow<T>旨在减少复制操作，提高性能，一般用于读多写少的场景. Cow<T>的另一个用处是统一实现规范.

rust指针包括 引用(reference), 原生指针(raw pointer), 函数指针(fn pointer)和智能指针(smart pointer).
引用的本质是非空指针.

解引用deref: 解引用会获得所有权, 解引用操作符是`*`.

### 复合(compound)类型
复合类型（Compound types）可以将多个值组合成一个类型. Rust 有两个原生的复合类型：元组（tuple）和数组（array）.

rust提供5种复合类型:
1. 元组(Tuple) : 一种**异构有限**序列, 即元素类型可能不同的**固定长度**的序列. 

    **如果元组中只包含一个元素，应该在后面添加一个逗号，以区分括号表达式和元组**.

    通过`tuple_name.<N>`的形式访问.
    因为let支持模式匹配(pattern destructuring), 因此可用let解构元组.
    单元值(unit)就是空元组`()`, 不占用内存空间, 可用`std::mem::size_of::<()>()`查看.
1. 数组(array) : 与元组不同，数组中的每个元素的类型必须相同. Rust 中的**数组是固定长度**的：一旦声明，它们的长度不能增长或缩小.

    定义: `let a: [T; n] = {}`
    vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型.

    将所有元素初始化为相同值的语法: `let ys: [i32;500] = [1;500]`

    在rust中, 两个元素类型和成员个数相同的数组才是同类型的.

    多维数组: `[[T;m];n]`

    Rust 中关于数组越界的行为, 定义得非常清晰. 相比于 C/C+, Rust消除的是`"未定义行为"(Undefin Behaviour)`

    > 当想要在栈（stack）而不是在堆（heap）上为数据分配空间, 或者是想要确保总是有固定数量的元素时，数组非常有用. 但是数组并不如 vector 类型灵活.
1. 结构体(Struct)

    Rust 允许 struct 类型的初始化使用一种简化的的写法: 如果有局部变量名字与成员变量名字恰好一致, 那么可以省略掉重复的冒号初始化`: `, 比如:
    ```rust
    fn build_user(email: String, username: String) -> User {
        User {
            email,
            username,
            active: true,
            sign_in_count: 1,
        }
    }
    ```

    结构体更新语法（struct update syntax）: 使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例, 比如:
    ```rust
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
    // 使用结构体更新语法为一个 User 实例设置新的 email 和 username 值，不过其余值来自 user1 变量中实例的字段
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1
    };
    ```

    结构体名称需遵从驼峰式命名规则.
    结构体上方的`#[derive(Debug, PartialEq)]`是[属性(类似于代码生成)](https://doc.rust-lang.org/reference/attributes/derive.html), 可让结构体自行实现Debug trait 和 PartialEq trait, 即允许对struct实例进行打印(通过`{:?}或{:#?}`)和比较.

    分三种:
    1. 具名结构体(named-field struct)

        它是rust面向对象思想的一种体现.
    1. 元组结构体(tuple-like struct)

        没有字段名称, 仅有类型. 比如`struct Color(i32, i32, i32);`
        当一个元组结构体只有一个字段时, 称为New Type模式. 因为它把一种类型封装成了新类型.
    1. 单元结构体(unit-like struct)

        没有任何字段的结构体, 比如`strcut Empty{}`.
        `std::ops::RangeFull`就是一个单元结构体.

        在Release编译模式下, 单元结构体实例会被优化为同一个对象; 而在Debug模式下, 则不会进行这样的优化.

        类单元结构体常常在想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用.

    在rust中函数和方法是有区别的, 不在impl块中定义的函数是自由函数, 而在impl块中定义的函数是方法, 第一个参数通常是`&self/&mut self`, 表示对结构体实例自身的引用.

    > 生命周期可确保结构体引用的数据有效性跟结构体本身保持一致, 如果尝试在结构体中存储一个引用而不指定生命周期将是无效的即会报错.
1. 枚举体(Enum)

    分三类:
    1. 无参数枚举体

        ```rust
        enum Number {
            Zero,
            One,
        }

        let a = Number::One;
        ```
    1. 类C枚举体

        ```rust
          enum Number {
            Zero = 1 ,
            One = 2,
        }

        let a = Number::One as i32;
        ```
    1. 带类型参数的枚举体

        ```rust
          enum IpAddr {
            V4(u8,u8,u8,u8),
            V6(String),
        }

        let a = IpAddr::V4(127,0,0,1);
        let b : fn(String) -> IpAddr = IpAddr::V6;//  IpAddr::V6是 `fn(String) -> IpAddr` 函数指针.

        enum Message {
            Quit,
            Move { x: i32, y: i32 },
            Write(String),
            ChangeColor(i32, i32, i32),
        }

        // 上面那个枚举等同于有四个含有不同类型的成员
        struct QuitMessage; // 类单元结构体
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // 元组结构体
        struct ChangeColorMessage(i32, i32, i32); // 元组结构体


        // 等价的c定义
        struct Message {
            int tag;
            union {
                struct {} Quit;
                struct {
                    int32_t x, y;
                } Move;
                struct {
                    char* a;
                } Write;
                struct {
                    int32_t _1, _2, _3;
                } ChangeColor;
            } cases;
        }
        ```

        **结构体和枚举还有另一个相似点：可以使用 impl 在枚举上定义方法**.

        Rust的enum与C++ 的enum和union都不同. 它是一种更安全的类型, 可以被称为["tagged union"](https://www.zhihu.com/question/452956370). 这个情况下, rust一般再加一个整型（一般是4 byte，有例外）用作tag, 然后每个case都是一个struct，最后在union起来. enum的某些情况是可以优化的, 优化方法: niche optimization.


        ```rust
        enum Number { 
            Int(i32),
            Float(f32), 
        }
        ```
        用c理解即是:
        ```c
        struct IpAddr { 
            enum {Int, Float} tag; 
            union { 
                int32_t int_value; 
                float float_value; 
            } value; 
        };

        enum Foo {
            C1(&i32, bool),
            C2,
            C3
        }

        // 可被优化成: 当_2为0或者1时Foo表示C1，为2时表示C2，为3时表示C3。 后两种情况下的_1的值未定义.
        struct Foo {
            int32_t *_1;
            uint8_t _2;
        }
        ```

        Rust enum 类型的变量需要区分它里面的数据究竟是哪种变体, 所以它包含了一个内部的`tag 标记`来描述当前变量属于哪种类型. 这个标记对用户是不可见的, 通过恰当的语法设计, 保证标记与类型始终是匹配的，以防止用户错误地使用内部数据, 可用`std::mem::size_of::<Number>()`输出大小来验证.
1. 联合体(Union) 
    rust也支持 union 类型, 这个类型与C中的 union 完全一致, 但在 Rust 里面, 读取它内部的值被认为是 unsafe 行为, 一般情况下不使用这种类型, 而它存在的主要目的是为了方便与C语言进行交互.


> tuple, struct, tuple struct 这几种类型，实质上是同样的内存布局，区别仅仅在于是否给类型及成员起了名字.

### 常用集合类型
Rust 标准库中包含一系列被称为 集合（collections）的非常有用的数据结构. 大部分其他数据类型都代表一个特定的值，不过集合可以包含多个值. 不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小.

std::collections提供了4种通用集合类型:
1. 线性序列: 向量(Vec), 双端队列(VecDeque), 链表(LinkedList)

    向量也是一种数组, 但可动态增长.
    `vec!`是一个宏, 用来创建向量字面量.
    rust的VecDeque是基于可增长的RingBuffer算法实现的双端队列.
    通常最好使用Vec或VecDeque类型, 因为它们比链表更加快速, 内存访问效率更高, 并且可以更好地利用cpu缓存.

    > 双端队列（Double-ended Queue，缩写Deque）是一种同时具有队列（先进先出）和栈（后进先出）性质的数据结构. 双端队列中的元素可以从两端弹出，插入和删除操作被限定在队列的两端进行.

    > Rust提供的链表是双向链表，允许在任意一端插入或弹出元素.

    ```rust
    let v: Vec<i32> = Vec::new();
    // let v = vec![1, 2, 3]; // 使用vec!宏, 让rust自动推导类型
    v.push(5); // 在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中

    let third: &i32 = &v[2]; // 当引用一个不存在的元素时 Rust 会造成 panic
    println!("The third element is {}", third);

    match v.get(2) { // 2 is index. 当 get 方法被传递了一个数组外的索引时，它不会 panic 而是返回 None
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }

    for i in &v {
        println!("{}", i);
    }
    ```
1. Key-Value映射: 无序哈希表(HashMap), 有序哈希表(BTreeMap)

    HashMap要求key是必须可哈希的类型，BTreeMap的key必须是可排序的
    value必须是在编译期已知大小的类型

    ```rust
    use std::collections::HashMap;
    let mut scores = HashMap::new();

    let teams  = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];

    let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect(); // 使用下划线占位是因为 Rust 能够根据 vector 中数据的类型推断出 HashMap 所包含的类型

    let team_name = String::from("Blue");
    let score = scores.get(&team_name);

    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }

    scores.insert(String::from("Blue"), 11); // 覆盖value
    scores.entry(String::from("Yellow")).or_insert(50); // entry 函数的返回值是一个枚举，Entry，它代表了可能存在也可能不存在的值. Entry 的 or_insert 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用.
    ```

    > 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者

    > 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的.

    HashMap 默认使用一种 “密码学安全的”（“cryptographically strong” ）哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击. 然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价. 如果性能监测显示此哈希函数非常慢，以致于无法接受，可以指定一个不同的 hasher 来切换为其它函数. hasher 是一个实现了 BuildHasher trait 的类型.
1. 集合类型: 无序集合(HashSet), 有序集合(BTreeMap)

    集合类型实际就是把Key-Value映射的Value设置成空元组.
1. 优先队列: 基于二叉最大堆(BinaryHeap)实现.

无论是Vec还是HashMap，使用这些集合容器类型，最重要的是理解容量（Capacity）和大小（Size/Len）:
- 容量是指为集合容器分配的内存容量
- 大小是指集合中包含的元素数量

### 方法
不过方法与函数是不同的, 因为它们在结构体的上下文中被定义(或者是枚举或 trait 对象的上下文).

impl 块的另一个有用的功能是: 允许在 impl 块中定义不以 self 作为参数的函数, 这被称为 关联函数（associated functions）, 因为它们与结构体相关联. 它们仍是函数而不是方法, 因为它们并不作用于一个结构体的实例. 比如`String::from`关联函数.

> 结构体允许拥有多个 impl 块.

### enumerations、enums枚举
> Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 代数数据类型（algebraic data types）最为相似

### 泛型
泛型就是把一个泛化的类型作为参数.

与枚举类型额函数一样,结构体名称旁边的`<T>`叫做泛型声明. 泛型只有被声明之后才可以实现.

```rust
struct Point<T> { x: T, y: T}
impl<T> Point<T> {
    fn new(x: T,y: T) -> Self {
        Point{x:x, y:y}
    }
}
fn main() {
    let p1 = Point::new(1,2);
    let p1 = Point::new("1","2");   
}
```

### trait
接口是一个软件系统开发的核心部分，它反映了系统的设计者对系统的抽象理解。作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性.

当在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力. 在运行时，一旦使用了关于接口的引用，变量原本的类型被掩藏，此时需要一个胖指针获取这个引用具备什么样的能力, 即在生成这个引用的时候，需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表, 这个列表，就是熟知的虚表（virtual table）.

trait是在行为上对类型的约束即对类型行为的抽象, 是Rust实现零成本抽象的基石，它有如下机制：
- trait是Rust唯一的接口抽象方式
- 可以静态分发，也可以动态分发
- 可以当做标记类型拥有某些特定行为的"标签"来使用

trait有4中用法:
- 接口抽象

    接口是对类型行为的统一约束, 是trait最基础的用法, 特点:
    - 接口中定义方法, 并支持默认实现
    - 接口中不能实现另一个接口, 但是接口间可以继承
    - 同一个接口可以同时被多个类型实现, 但不能被同一个类型实现多次
    - 使用trait关键字来定义接口
    - 使用impl关键字为类型实现接口方法

    ## 关联类型
    关联类型（associated types）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型. trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型.
    **rust很多操作符都是基于trait来实现的.**, 比如加法操作符:
    ```rust
    pub trait Add<RHS = Self> { // `Add<RHS = Self>`表示参数类型RHS为Self, Self是每个trait都带有的隐式类型参数, 代表实现当前trait的具体类型.
        type Output; // 关联类型. Output是一个占位类型, trait的实现者会指定 Output的具体类型.
        fn add(self, rhs: RHS) -> Self::Output;
    }

    1+2 // =>`1.add(2)` 代码中出现`+`时, rust就会自动调用操作符左侧的操作数对应的add()方法去实现具体的操作, 即`+`操作与调用`add()`等价.
    // 可看rust源码为u32实现的Add trait(用宏完成的).
    ```

    在语义层面上, 使用关联类型增强了trait表示行为的语义, 因为它表示了和某个行为(trait)相关联的类型. 在工程上, 也体现出了高内聚的特点.

    ## trait一致性
    孤儿原则(Orphan Rule): impl块要么与trait的声明在同一个crate中, 要么与类型的声明在同一个crate中. 其可限制代码被破坏性改写, 导致出现难以预料的bug.

    同理匿名impl必须与类型本身在同一个crate中.

    ## trait继承
    rust不支持传统面向对象的继承, 但支持trait继承.

    ```rust
    trait Paginatge: Page + PerPage { // 用冒号表示继承其他trait.
        ...
    }
    impl <T: Page + PerPage>Paginate for T{

    }
    ```
    
- 泛型约束

    trait限定(trait bound) : 泛型的行为被trait限定在更有限的范围内, 多个trait限定用`+`连接.

    ```rust
    use std::ops::Add;
    // 表示sum函数的参数必须实现Add trait
    fn sum<T: Add<T, Output=T>>(a: T, b:T) -> T{
        a+b
    }
    fn foo<T, K, R>(a: T, b:K, c:R) where T: A, K:B+C, R:D {...}// where用于为泛型增加较多的trait限定, 提高代码可读性.
    ```

    trait限定给予了开发者更大的自由度, 因为不再需要类型间的继承, 也简化了编译器的检查操作. 包含trait限定的泛型属于**静态分发**, 在编译期通过单态化分别生成具体类型的实例, 所以调用trait限定中的方法也都是运行时零成本的, 因为不需要在运行时再进行方法查找.
- 抽象类型

    在运行时作为一种间接的抽象类型来使用, 动态地分发给具体的类型.
-标签trait

    对类型的约束, 即直接作为一种"标签"使用.

rust规定函数在参数传递, 返回值传递中类型必须是编译阶段可确定大小的, 而trait的大小在编译时是不固定的, 因此它无法作为实例变量, 参数, 返回值, 这与go的interface不同.

### 宏
宏语句可以使用圆括号, 中括号, 花括号, 一般使用中括号表示数组.

### 语法
用 C 语言系列风格的`//`和`/**/`表示注释. Rust 还有另一种注释，称为文档注释.

字符串 slice（string slice）是 String 中一部分值的引用. 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.
字符串字面值就是 slice, 是一个指向二进制程序特定位置的 slice.
通用slice跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度.

#### 函数
在Rust中，函数定义以fn关键字开始并紧随函数名称与一对圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方. 使用函数名加圆括号的方式来调用函数.

> 函数体由一系列的语句和一个可选的结尾表达式构成.

> Rust不关心在何处定义函数，只要这些定义对于使用区域是可见的即可, 这与go相同, 与c不同.

在函数签名中，必须 声明每个参数的类型.

> **参数变量和传入的具体参数值有自己分别对应的名称parameter和argument, 即形参和实参**.

rust并不对返回值命名，但要在`箭头（->）`后声明它的类型.
**在 Rust 中，函数的返回值等同于函数体最后一个表达式的值, 因此rust允许省略return**.
rust不支持多返回值, 但可以利用元组来返回多个值.

```rust
fn main() {
    let x = plus_one(5);
}
fn plus_one(x: i32) -> i32 {
    x + 1
}
// 错误: 在包含 x + 1 的行尾加上一个分号，把它从表达式变成语句. 语句并不会返回值，使用空元组 () 表示不返回值. 因为不返回值与函数定义相矛盾，从而出现一个错误.
// fn plus_one(x: i32) -> i32 {
//     x + 1;
// }
```

函数的第一个参数如果是Self相关的类型, 且命名为`self`, 那么这个参数就是receiver. 有receiver的函数即为方法(method), 用`变量实例.方法名`来调用.
没有receiver参数的函数是静态函数(static function), 通过类型加`::`的方式调用.

#### 所有权(ownership)
所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全. **所有权的存在就是为了管理堆数据**.

所有运行的程序都必须管理其使用计算机内存的方式. 一些语言中具有垃圾回收机制(go, java等)，在程序运行时不断地寻找不再使用的内存；在另一些语言中(c, c++等)，开发者必须亲自分配和释放内存. Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在**编译时**会根据一系列的规则进行检查, 在运行时，所有权系统的任何功能都不会减慢程序.

> rust的栈中的所有数据都必须占用已知且固定的大小, 在编译时大小未知或大小可能变化的数据会分配到堆上.

Rust中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者.

在进行赋值操作时，对于可以实现Copy的复制语义类型，所有权并未改变. 对于复合类型来说，是复制还是移动，取决于其成员的类型.

所有权的规则:
- Rust 中的每一个值都有一个被称为其所有者（owner）的变量
- 值在任一时刻有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃

    内存在拥有它的变量离开作用域后就被自动释放(调用`drop`方法)

    在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）.

rust 内存回收策略：内存在拥有它的变量离开作用域后就被自动释放.

变量与数据交互的方式:
1. move

    设计选择: **Rust 永远也不会自动创建数据的 “深拷贝”. 因此，任何 自动 的复制可以被认为对运行时性能影响较小.**
1. clone

Rust 有一个叫做 Copy trait(类似深拷贝)的特殊注解，可以用在类似整型这样的**存储在栈上的类型上. 如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用**. Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait.

作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的. 默认支持 Copy 的类型有：
- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型, char
- 元组，当且仅当其包含的类型也都是 Copy 的时候. 比如 (i32, i32) 是 Copy 的，但 (i32, String) 就不是.

将值传递给函数在语义上与给变量赋值相似: 向函数传递值可能会移动或者复制，就像赋值语句一样. 返回值也可以转移所有权.

变量的所有权总是遵循相同的模式：将值赋给另一个变量时**移动**它 . 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有.

引用(`&`)语法可创建一个 指向 值 的引用，但是**并不拥有它**, **因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃**.

**获取引用作为函数参数称为`借用(borrowing)`**.

引用默认不允许修改引用的值, 允许可变引用(`&mut`), 但可变引用有一个很大的限制：**在特定作用域中的特定数据有且只有一个可变引用. 这个限制的好处是 Rust 可以在编译时就避免数据竞争.数据竞争（data race）类似于竞态条件**，它可由这三个行为造成：
- 两个或更多指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

引用的规则:
1. 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用. 即任意时刻不能在拥有不可变引用的同时拥有该变量的可变引用.
2. 引用必须总是有效的.

除了引用, 另一个没有所有权的数据类型是 slice. slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合. 字符串 slice（string slice）是 String 中一部分值的引用. 字符串字面值就是 slice.

> 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.

使用可变借用的前提是：出借所有权的绑定变量必须是一个可变绑定.

在所有权系统中，引用&x也可以称为x的借用（Borrowing）. 通过&操作符来完成所有权租借。所以引用并不会造成绑定变量所有权的转移.

引用在离开作用域之时，就是其归还所有权之时:
- 不可变借用（引用）不能再次出借为可变借用
- 不可变借用可以被出借多次
- 可变借用只能出借一次
- 不可变借用和可变借用不能同时存在，针对同一个绑定而言
- 借用的生命周期不能长于出借方的生命周期

核心原则：**共享不可变，可变不共享**

因为解引用操作会获得所有权，所以在需要对移动语义类型（如&String）进行解引用时需要特别注意.

> rust 有一个叫 自动引用和解引用（automatic referencing and dereferencing）的功能, 这与golang相同.

#### 词法作用域（生命周期）
match、for、loop、while、if let、while let、花括号、函数、闭包都会创建新的作用域，相应绑定的所有权会被转移.

函数体本身是独立的词法作用域：
- 当复制语义类型作为函数参数时，会按位复制
- 如果是移动语义作为函数参数，则会转移所有权

借用规则： 借用方的生命周期不能长于出借方的生命周期.

非词法作用域生命周期(Non-Lexical Lifetime，NLL)

#### 生命周期参数
编译器的借用检查机制无法对跨函数的借用进行检查，因为当前借用的有效性依赖于词法作用域. 所以，需要开发者显式的对借用的生命周期参数进行标注.

显式生命周期参数
- 生命周期参数必须是以单引号开头；
- 参数名通常都是小写字母，例如：'a；
- 生命周期参数位于引用符号&后面，并使用空格来分割生命周期参数和类型

标注生命周期参数是由于borrowed pointers导致的. 因为有borrowed pointers，当函数返回borrowed pointers时，为了保证内存安全，需要关注被借用的内存的生命周期(lifetime).

标注生命周期参数并不能改变任何引用的生命周期长短，它只用于编译器的借用检查，来防止悬垂指针. 即：生命周期参数的目的是帮助借用检查器验证合法的引用，消除悬垂指针.

##### 函数签名中的生命周期参数
```rust
fn foo<'a>(s: &'a str, t: &'a str) -> &'a str;
```
函数名后的<'a>为生命周期参数的声明. 函数或方法参数的生命周期叫做输入生命周期（input lifetime），而返回值的生命周期被称为输出生命周期（output lifetime）.

规则：
- 禁止在没有任何输入参数的情况下返回引用，因为会造成悬垂指针
- 从函数中返回（输出）一个引用，其生命周期参数必须与函数的参数（输入）相匹配，否则，标注生命周期参数也毫无意义.

对于多个输入参数的情况，也可以标注不同的生命周期参数.

##### 方法定义中的生命周期参数
结构体中包含引用类型成员时，需要标注生命周期参数，则在impl关键字之后也需要声明生命周期参数，并在结构体名称之后使用.

```rust
impl<'a> Foo<'a> {

         fn split_first(s: &'a str) -> &'a str {

                   …

}

}
```

在添加生命周期参数'a之后，结束了输入引用的生命周期长度要长于结构体Foo实例的生命周期长度.

##### 结构体定义中的生命周期参数
结构体在含有引用类型成员的时候也需要标注生命周期参数，否则编译失败.

```rust
struct Foo<'a> {

            part: &'a str,

}
```

struct的生命周期参数标记，实际上是和编译器约定了一个规则：结构体实例的生命周期应短于或等于任意一个成员的生命周期.

> 注：枚举体和结构体对生命周期参数的处理方式是一样的
##### 静态生命周期参数
静态生命周期 'static：是Rust内置的一种特殊的生命周期. 'static生命周期存活于整个程序运行期间. 所有的字符串字面量都有生命周期，类型为`& 'static str`

字符串字面量是全局静态类型，他的数据和程序代码一起存储在可执行文件的数据段中，其地址在编译期是已知的，并且是只读的，无法更改.

##### 省略生命周期参数
满足以下三条规则时，可以省略生命周期参数. 该场景下，是将其硬编码到Rust编译器重，以便编译期可以自动补齐函数签名中的生命周期参数

生命周期省略规则：
1. 每一个在输入位置省略的生命周期都将成为一个不同的生命周期参数。即对应一个唯一的生命周期参数
1. 如果只有一个输入的生命周期位置（无论省略还是没省略），则该生命周期都将分配给输出生命周期
1. 如果有多个输入生命周期位置，而其中包含着 &self 或者 &mut self，那么 self 的生命周期都将分配给输出生命周期

##### 生命周期限定

生命周期参数可以向trait那样作为泛型的限定，有以下两种形式：

T: 'a，表示T类型中的任何引用都要“获得”和'a一样长。
T: Trait + 'a，表示T类型必须实现Trait这个trait，并且T类型中任何引用都要“活的”和'a一样长

##### 高阶生命周期
Rust还提供了高阶生命周期（Higher-Ranked Lifetime）方案，该方案也叫高阶trait限定（Higher-Ranked Trait Bound，HRTB）。该方案提供了for<>语法.

for<>语法整体表示此生命周期参数只针对其后面所跟着的“对象”.

## 并发安全与所有权
如果类型T实现了Send： 就是告诉编译器该类型的实例可以在线程间安全传递所有权.
如果类型T实现了Sync：就是向编译器表明该类型的实例在多线程并发中不可能导致内存不安全，所以可以安全的跨线程共享.

## 函数
函数是编程语言的基本要素，它是对完成某个功能的一组相关语句和表达式的封装。函数也是对代码中重复行为的抽象.

### 函数参数
- 当函数参数按值传递时，会转移所有权或者执行复制（Copy）语义
- 当函数参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数（符合规则时不需要显示的标明）

### 函数参数模式匹配
- ref ：使用模式匹配来获取参数的不可变引用
- ref mut ：使用模式匹配来获取参数的可变引用
- 除了ref和ref mut，函数参数也可以使用通配符来忽略参数

### 泛型函数
函数参数并未指定具体的类型，而是用了泛型T，对T只有一个Mult trait限定，即只有实现了Mul的类型才可以作为参数，从而保证了类型安全.

泛型函数并未指定具体类型，而是靠编译器来进行自动推断的。如果使用的都是基本原生类型，编译器推断起来比较简单。如果编译器无法自动推断，就需要显式的指定函数调用的类型。

### 法和函数
方法代表某个实例对象的行为，函数只是一段简单的代码，它可以通过名字来进行调用。方法也是通过名字来进行调用，但它必须关联一个方法接受者。

### 高阶函数
高阶函数是指以函数作为参数或返回值的函数，它是函数式编程语言最基础的特性

## 闭包Closure
闭包通常是指词法闭包，是一个持有外部环境变量的函数.

> 闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

外部环境是指闭包定义时所在的词法作用域.

外部环境变量，在函数式编程范式中也被称为自由变量，是指并不是在闭包内定义的变量.

**将自由变量和自身绑定的函数就是闭包**.

> 闭包的大小在编译期是未知的.

### 闭包的基本语法
闭包由管道符（两个对称的竖线）和花括号（或圆括号）组成.

- 管道符里是闭包函数的参数，可以向普通函数参数那样在冒号后添加类型标注，也可以省略

    例如：let add = |a, b| -> i32 { a + b };

- 花括号里包含的是闭包函数执行体，花括号和返回值也可以省略。

    例如：let add = |a, b| a + b;

- 当闭包函数没有参数只有捕获的自由变量时，管道符里的参数也可以省略

    例如： let add = || a + b;

### 闭包的实现
闭包是一种语法糖. 闭包不属于Rust语言提供的基本语法要素，而是在基本语法功能之上又提供的一层方便开发者编程的语法.

闭包和普通函数的差别就是闭包可以捕获环境中的自由变量.

闭包可以作为函数参数，这一点直接提升了Rust语言的抽象表达能力. 当它作为函数参数传递时，可以被用作泛型的trait限定，也可以直接作为trait对象来使用.

闭包无法直接作为函数的返回值，如果要把闭包作为返回值，必须使用trait对象.

### 闭包与所有权
闭包表达式会由编译器自动翻译为结构体实例，并为其实现Fn、FnMut、FnOnce三个trait中的一个:
- `FnOnce`：会转移方法接收者的所有权。没有改变环境的能力，只能调用一次。
- FnMut:会对方法接收者进行可变借用。有改变环境的能力，可以多次调用。
- Fn:会对方法接收者进行不可变借用。没有改变环境的能力，可以多次调用。

如果要实现Fn，就必须实现FnMut和FnOnce
如果要实现FnMut，就必须实现FnOnce
如果要实现FnOnce，就不需要实现FnMut和Fn

#### 捕获环境变量的方式
- 对于复制语义类型，以不可变引用（&T）来进行捕获
- 对于移动语义类型，执行移动语义，转移所有权来进行捕获
- 对于可变绑定，并且在闭包中包含对其进行修改的操作，则以可变引用（&mut T）来进行捕获

Rust使用move关键字来强制让闭包所定义环境中的自由变量转移到闭包中.

#### 规则总结
- 如果闭包中没有捕获任何环境变量，则默认自动实现Fn
- 如果闭包中捕获了复制语义类型的环境变量，则：

    - 如果不需要修改环境变量，无论是否使用move关键字，均会自动实现Fn。
    - 如果需要修改环境变量，则自动实现FnMut。

- 如果闭包中捕获了移动语义类型的环境变量，则：

    - 如果不需要修改环境变量，而且没有使用move关键字，则会自动实现FnOnce。
    - 如果不需要修改环境变量，而且使用move关键字，则会自动实现Fn。
    - 如果需要修改环境变量，则自动实现FnMut。

- FnMut的闭包在使用move关键字时，如果捕获变量是复制语义类型的，则闭包会自动实现Copy/Clone。如果捕获变量是移动语义类型的，则闭包不会自动实现Copy/Clone

## 迭代器
Rust使用的是外部迭代器，也就是for循环. 外部迭代器：外部可以控制整个遍历进程.

Rust中使用了trait来抽象迭代器模式. Iterator trait是Rust中对迭代器模式的抽象接口.

迭代器主要包含：
- next方法：迭代其内部元素
- 关联类型Item
- size_hint方法：返回类型是一个元组，该元组表示迭代器剩余长度的边界信息

Iter类型迭代器，next方法返回的是Option<&[T]>或Option<&mut [T]>类型的值. for循环会自动调用迭代器的next方法. for循环中的循环变量(是引用)则是通过模式匹配，从next返回的Option<&[T]>或Option<&mut [T]>类型中获取&[T]或&mut [T]类型的值.

IntoIter类型的迭代器的next方法返回的是Option<T>类型，在for循环中产生的循环变量是值，而不是引用.

### IntoIterator trait
如果想要迭代某个集合容器中的元素，必须将其转换为迭代器才可以使用.

Rust提供了FromIterator和IntoIterator两个trait，他们互为反操作:
- FromIterator ：可以从迭代器转换为指定类型
- IntoIterator ：可以从指定类型转换为迭代器

Intoiter可以使用into_iter之类的方法来获取一个迭代器. into_iter的参数时self，代表该方法会转移方法接收者的所有权. 而还有其他两个迭代器不用转移所有权
- Iter ：获取不可变借用，对应&self
- IterMut ：获得可变借用，对应&mut slef

### 哪些实现了Iterator的类型？
只有实现了Iterator的类型才能作为迭代器.

实现了IntoIterator的集合容器可以通过into_iter方法来转换为迭代器.

实现了IntoIterator的集合容器有：
- `Vec<T>`
- `&'a [T]`
- `&'a mut [T] => 没有为[T]类型`实现IntoIterator

### 迭代器适配器
通过适配器模式可以将一个接口转换成所需要的另一个接口. 适配器模式能够使得接口不兼容的类型在一起工作. 适配器也叫包装器(Wrapper).

迭代器适配器，都定义在std::iter模块中：
- Map ：通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器。
- Chain ：通过连接两个迭代器来创建一个新的迭代器。
- Cloned ：通过拷贝原始迭代器中全部元素来创建新的迭代器。
- Cycle ：创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代。
- Enumerate ：创建一个包含计数的迭代器，它返回一个元组（i,val），其中i是usize类型，为迭代的当前索引，val是迭代器返回的值。
- Filter ：创建一个机遇谓词判断式过滤元素的迭代器。
- FlatMap ：创建一个类似Map的结构的迭代器，但是其中不会包含任何嵌套。
- FilterMap ：相当于Filter和Map两个迭代器一次使用后的效果。
- Fuse ：创建一个可以快速遍历的迭代器。在遍历迭代器时，只要返回过一次None，那么之后所有的遍历结果都为None。该迭代器适配器可以用于优化。
- Rev ：创建一个可以反向遍历的迭代器

Rust可以自定义迭代器适配器

### 消费器
迭代器不会自动发生遍历行为，需要调用next方法去消费其中的数据. 最直接消费迭代器数据的方法就是使用for循环.

Rust提供了for循环之外的用于消费迭代器内数据的方法，叫做消费器（Consumer）.

Rust标准库std::iter::Iterator中常用的消费器：
- any ：可以查找容器中是否存在满足条件的元素
- fold ：该方法接收两个参数，第一个为初始值，第二个为带有两个参数的闭包。其中闭包的第一个参数被称为累加器，它会将闭包每次迭代执行的结果进行累计，并最终作为fold方法的返回值
- collect ：专门用来将迭代器转换为指定的集合类型
- `all`
- `for_each`
- `position`

## 锁
- RwLock读写锁：是多读单写锁，也叫共享独占锁. 它允许多个线程读，单个线程写。但是在写的时候，只能有一个线程占有写锁；而在读的时候，允许任意线程获取读锁。读锁和写锁不能被同时获取。
- Mutex互斥锁：只允许单个线程读和写

## 内存管理
drop-flag：在函数调用栈中为离开作用域的变量自动插入布尔标记，标注是否调用析构函数，这样，在运行时就可以根据编译期做的标记来调用析构函数.

实现了Copy的类型，是没有析构函数的. 因为实现了Copy的类型会复制，其生命周期不受析构函数的影响.

## 异步
在异步操作里, 异步处理完成后的结果, 一般用 Promise 来保存, 它是一个对象，用来描述在未来的某个时刻才能获得的结果的值, 一般存在三个状态:
- 初始状态，Promise 还未运行
- 等待（pending）状态, Promise 已运行, 但还未结束
- 结束状态, Promise 成功解析出一个值，或者执行失败

一般而言, async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行. 大多数语言中, async/await 是一个语法糖（syntactic sugar）, 它使用状态机将 Promise 包装起来, 让异步调用的使用感觉和同步调用非常类似, 也让代码更容易阅读.

## FAQ
### 各编程语言中的类型系统
静态类型语言：在编译阶段确定所有变量的类型.
动态类型语言：在执行阶段确定所有变量的类型.
不允许隐式转换的是强类型，允许隐式转换的是弱类型.

- 没类型： 比如汇编语言，没有类型的概念，所有都只是一个数字
- 弱静态类型： 比如C/C++语言，可以定义类型，但是不强制执行，在不同类型之间自动转换
- 强静态类型： 比如Java，定义类型，并且用虚拟机检查类型
- 强动态类型： 比如Python和Ruby，动态推断类型而不需要定义，然后解释器会强制执行.
- 弱动态类型： Perl/PHP,js

> ruby和Python在运行时通过Duck Typing来进行运行时类型检查, 以保证类型安全.

![](/misc/img/rust/9zv7ejia98.jpeg)