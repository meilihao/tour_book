# rust
程序的三大定律:
1. 程序必须正确
1. 程序必须可维护, 但不能违反第一定律
1. 程序必须高效, 但不能违反前两条定律

rust无疑是迈向这个目标的更近一步.

编程两大难题(本质是使用类型不安全的语言, 它们的内存管理机制不完善):
1. 编写内存安全的代码
1. 编写线程安全的代码

> 在之前的年代, 计算资源匮乏, 为追求性能, 牺牲了部分安全性.

rust是一门同时追求安全,并发和性能的现代系统级编程语言.
rust三大设计哲学:
1. 内存安全

    类型安全即类型系统可以保证程序的行为是意义明确, 不出错的. c/c++的类型系统不是类型安全的, 比如它们不检查数组越界.

    > 类型安全: 类型系统给内存中的plain data赋予了类型信息，如果不按照类型信息来解释内存中的数据，应该产生编译错误或者 产生well-specified的运行时错误.

    类型安全是内存安全的前提.

    内存安全: 不会出现内存访问错误, 只有当程序访问未定义内存时才会产生内存错误. 常见的场景有:
    1. 引用空指针
    1. 使用未初始化内存
    1. 释放后再次使用, 即虚悬指针
    1. 缓冲区溢出, 比如数组越界
    1. 非法释放已释放过的指针或未分配的指针, 即重复释放

    rust为了保证内存安全, 建立了严格的安全内存管理模型:
    - 所有权系统: 每个被分配的内存都有一个独占其所有权的指针. 只有当该指针被销毁时, 其对应的内存该会被随之释放.
    - 借用和生命周期: 每个变量都有其生命周期, 一旦超出生命周期, 变量就会被自动释放. 如果是借用, 则可以通过标记生命周期参数供编译器检查的方式, 防止出现虚悬指向即释放后使用的情况.

    > rust所有权系统还包括了从现代c++借鉴的RAII机制, 这是rust无gc但是可以安全管理内存的基石.

    为了实现内存安全, rust还具备具有的特性:
    1. 仿射类型(Affine Type), 该类型可用来表达rust所有权中的Move语义.

    借助类型, rust可在编译阶段对类型进行检查是否满足安全内存模型, 有效地阻止未定义行为的发生.

    内存安全bug和并发安全的bug的产生内在原因均是内存的不正当访问造成的. 借助装备了所有权的强大类型系统, rust还解决了并发安全问题. 它通过静态检查分析, 在编译期就能检查出多线程并发代码中所有的数据竞争问题.
1. 零成本抽象即代码表达能力不存在运行时开销.

    rust的抽象并不存在运行时的开销, 其一切都是在编译期完成的.

    rust的零成本抽象的基石是泛型和trait.
1. 实用性

    为了保证支持硬实时, rust借鉴了c++的确定性析构, RAII和智能指针, 用于自动地, 确定地管理内存, 从而避免了gc的引入.

    为了保证程序的鲁棒性, rust重新审视了错误处理机制. rust针对三类非正常情况: 失败, 错误和异常, 提供了专门的处理方式:
    - 失败: 使用断言工具
    - 错误: 基于返回值的分层处理 
    - 异常: rust将其看作无法被合理解决的问题, 提供了线程恐慌机制, 发生异常时, 线程可以安全地退出.

    为了兼容现有生态, rust支持方便且零成本的FFI机制, 兼容C-ABI, 在语言架构层面上将rust分为safe rust和unsafe rust两部分. unsafe专门和外部生态打交道, 因为rust编译器检查和跟踪的范围有限, 不能检查到与其链接的其他生态接口, 因此这些生态由自身来保证安全性. 总结就是, safe rust由rust编译器在编译时保证安全, unsafe rust开发者让编译器信任自身有能力保证安全.

### 编译
rust编译器是LLVM编译器的前端, 它将代码编译成LLVM IR, 然后通过LLVM编译成对应架构的机器码.

rust源码经过分词和解析生成AST(抽象语法树), 再进一步简化处理为HIR(High-level IR, 方便编译器做类型检查), 再进一步编译为MIR(middle IR, 在rust 1.12引入), 最后MIR被翻译为LLVM IR, 之后由LLVM编译成目标机器码.

引入MIR原因:
1. 缩短编译时间

    实现了增量编译, 仅重新编译更改过的部分.
1. 缩短执行时间

    进入llvm前实现更细颗粒度的优化, 单纯依赖llvm的优化颗粒度太粗, 增加了更多的优化空间
1. 更精确的类型检查

    实现更灵活的借用检查

rust语言组成:
- 语言规范
- 编译器
- 核心库

    定义了rust语言的核心, 不依赖于操作系统和网络等相关的库, 不负责堆分配,不提供并发和I/O.
    通过在模块顶部引入`#![no_std]`来使用核心库.
    组成:
    1. 基础trait, 如Copy, Debug, Display,Option等
    1. 基本原始类型, 如 bool, char,i8/u8,..i64/u64, isize/usize, f32/f64, str, array, slic, tuple, pointer等
    1. 常用功能型数据类型, 比如String, Vec, HashMap, Rc, Arc,Box等
    1. 常用的宏定义, 如println()!, assert!, panic!, vec!.

    做嵌入式应用开发时, 核心库是必需的.
- 标准库

    提供应用程序开发所需的基础和跨平台支持.

    组成:
    1. 与核心库一样的基本trait, 原始数据类型, 功能型数据类型和常用的宏等, 以及与核心库几乎完全一致的API.
    1. 并发, I/O和运行时.
    
        如线程模块,  用于消息传递的通道类型, Sync trait等并发模块; 文件, tcp, udp, 管道, socket等常见I/O.
    1. 平台抽象.
        - os模块提供了许多与操作环境交互的基本功能, 包括程序参数, 环境变量, 目录导航
        - 路径模块封装了处理文件路径的平台特定规则.
    1. 底层操作接口

        如std::mem,std::ptr, std::intrinsic等, 操作内存,指针, 调用编译器固有函数.
    1. 可选和错误处理类型Option和Result, 以及各种迭代器.
    
### 语句和表达式
rust语法分语句(statement, 要执行的一些操作和产生副作用的表达式)和表达式(expression, 主要用于计算求值).

语句又分:
- 声明语句(Declaration statement) : 用于声明各种语言项(item), 比如变量, 静态变量, 常量, 结构体, 函数等, 以及通过extern和use关键词引入的包和模块等.
- 表达式语句(expression statement) : 特指以分号结尾的表达式. 此类表达式求值结果会被舍弃, 并总是返回单元类型`()`.

rust编译器解析代码时, 如果遇到分号, 就会继续往后面执行; 如果碰到语句, 则执行语句; 如果碰到表达式, 则会对表达式求值, 如果分号后面什么都没有, 就会补上单元值;  当
遇到函数时, 会将函数体的花括号识别为块表达式(block expression, 由一对花括号和一系列表达式组成, 它总是返回块中最后一个表达式的值)

let创建的变量一般称为绑定(bingding).

rust的表达式可分为位置表达式(place expression)和值表达式(value expression), 即其他语言中的左值和右值.

位置表达式就是表示内存位置的表达式, 分别有如下几类:
1. 本地变量
1. 静态变量
1. 解引用(*expr)
1. 数组索引(expr[expr])
1. 字段引用(expr.field)
1. 位置表达式组合

通过位置表达式可对某个数据单元的内存进行读写.
值表达式一般只引用了某个存储单元地址中的数据, 它相当于数据值, 只能进行读操作.

**从语法角度讲, 位置表达式代表了持久化数据, 值表达式代表了临时数据.**

表达式的求值过程可分为位置上下文(place context)和值上下文(value context).

let关键字声明位置表达式默认不可变, 为不可变绑定., 只能对对应的存储单元进行读取.
let mut声明的可变绑定可以对相应的存储单元进行写入.

所有权转移: 当位置表达式出现在值上下文中, 表示将会把内存地址转移给另一个位置表达式.

**在语义上, 每个变量绑定实际上都拥有该存储单元的所有权, 这种转移内存地址的行为就是所有权(ownership)的转移, 在rust中称为移动(move)语义, 那种不转移的情况实际上是一种复制(copy)语义. **rust没有gc, 所以完全依靠所有权来进行内存管理.

rust提供引用操作符(&), 此时不转移所有权, 可直接获取表达式的存储单元地址(即内存位置), 可通过该地址对存储进行读取. 因此引用已被称为借用.

rust的作用域是静态作用域, 即词法作用域(lexical scope), 由一对花括号来开辟作用域, 该作用域在词法分析阶段就已确定, 不会动态改变.

连续用let定义同名变量的做法被称为变量遮蔽(variable shadow).

变量绑定的生命周期(lifetime): 从使用let声明创建变量绑定开始, 到超出词法作用域的范围时结束.

rust中函数是一等公民, 其自身可作为函数的参数和返回值使用.

rust编译器像C++或D语言一些, 支持编译时函数执行(compile-time function execution, CTFE), 该功能由miri(mir解析器, 已集成入rustc)来执行.

rust中固定长度的数组必须在编译期就知道长度, 否知会报错, 这就用了CTFE的能力.

`const fn`强制编译器在编译期执行函数, 其中const一般用于定义全局常量.

当前rust支持的常量有: 字面量, 元组, 数组, 字段结构体, 枚举, 只包含单行代码的块表达式, 范围等.

闭包与函数的区别: 闭包可捕获外部变量, 而函数不可以.

rust闭包实际上由一个匿名结构体和trait来组合实现的, 语法是`|params| {expr}`.

```rust
// 一般情况下, 闭包默认会按引用捕获变量, 如果将此闭包返回, 则引用也会跟着返回, 但这里随着函数调用结束, 本地变量i会被销毁, 随闭包返回的i的引用就变成了虚悬指针.
// 因此需要使用move来将被引用的变量的所有权转移到闭包中, 不再按引用捕获变量, 这样闭包才可以安全地返回.
pub fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    move |j| j * i
}
```

### 流程控制
变量绑定支持if表达式.
rust循环支持while, loop, for...in; 无限循环需使用loop.
rust支持match, 其使用了模式匹配(pattern matching)技术, 支持绑定模式(bingding mode, 即使用操作符@将模式中的值绑定给一个变量, 供分支右侧的代码使用). match使用`_`来兜底.
match表达式要求所有的分支都必须返回相同的类型.
rust提供if let和while let表达式, 分别在某些场合代替match表达式.

### 基本数据类型
rust不支持将数值转为bool类型.
对于原始固定长度的数组, 只有实现了Copy trait的类型可作为其元素, 即只有在栈上存放的元素才可以存放在该类型的数组中.
slice是对一个数组(包括固定大小数组和动态数组)的引用片段.
处于内存安全考虑, rust将字符串分为两种: str字符串(也叫字符串切片), 固定长度的字符串, 通常以不可变借用的形式存在(`&str`); String字符串, 长度可变的字符串.
`& 'static str`是静态生命周期字符串. 静态生命周期即程序生命周期.
str字符串类型由两部分组成: 执行字符串序列的指针和记录长度的值.
rust字符串的本质是一段有效的utf8字节序列.

unsafe块: rust编译器将内存安全交由开发者自行负责.

rust指针包括 引用(reference), 原生指针(raw pointer), 函数指针(fn pointer)和智能指针(smart pointer).
引用的本质是非空指针.
原生指针主要用于unsafe rust中, 有两种类型: 不可变原生指针 `*const T`和可变原生指针`*mut T`.
`Box::new(20)`表示在堆内存上存储数值20.
never类型: 表示永远不可能有返回值的计算类型. panic!宏会返回never类型`!`. never类型可以强制转换为其他任何类型.

#### 智能指针
智能指针来自c++.
**rust中的值默认被分配到栈**, 可通过`Box<T>`将值装箱(在堆中分配).`Box<T>`是指向T类型堆内存变量的智能指针, 当它超出作用域时, 将调用其析构函数销毁内部对象, 并自动释放堆内存.
可通过解引用来获取`Box<T>`中的T. 因为`Box<T>`的行为像引用, 并且可以自动释放内存, 因此将其称为智能指针.

### 泛型和trait
泛型允许开发者编写一些在使用时才制定类型的代码. rust编译器会在编译期间自动为具体类型生成实现代码.
trait借鉴了Haskell的Typeclass, 是rust实现零成本抽象的基石, 其机制如下:
- trait是rust唯一的接口抽象方法
- 可以静态生成 也可以动态调用
- 可以当做标记类型拥有某些特定行为的"标签"来使用

```rust
// `<T: Debug>`表示有trait限定(trait bound)的泛型, 即只有实现了Debug trait的类型才适用. 只有实现了Debug trait的类型才拥有使用`{:?}`格式化打印的行为
fn match_opton<T: Debug>(o: Option<T>) {
    match o {
        ...
    }
}

struct Duck;
trait Fly {
    fn fly(&self) -> bool;
}
impl Fly for Duck{
    fn fly(&self) -> bool {
        return true;
    }
}
fn fly_static<T: Fly>(s: T) -> bool {
    s.fly()
}

fn fly_static(s: &Fly) -> bool {
    s.fly()
}

fn main(){
    let duck = Duck;
    fly_static::<Duck>(duck); // 静态分发, rust编译器会为`fly_static::<Duck>(duck)`这个具体类型的调用生成特殊化的代码
    fly_dyn(&Duck)
}
```

rust没有传统面向对象编程语言中的继承概念. 它通过trait将类型和行为明确地进行了区分, 充分贯彻了组合优于继承和面向接口编程的编程思想.

### 复合类型
rust提供4种复合类型:
1. 元组(Tuple) : 一种异构有序序列, 即元素类型可能不同的固定长度的序列.

    通过`tuple_name.${N}`的形式访问.
    因为let支持模式匹配, 因此可用let解构元组.
    单元值就是空元组`()`.
1. 结构体(Struct)

    结构体名称需遵从驼峰式命名规则.
    结构体上方的`#[derive(Debug, PartialEq)]`是属性, 可让结构体自行实现Debug trait 和 PartialEq trait, 即允许对struct实例进行打印和比较.

    分三种:
    1. 具名结构体(named-field struct)

        它是rust面向对象思想的一种体现.
    1. 元组结构体(tuple-like struct)

        没有字段名称, 仅有类型. 比如`struct Color(i32, i32, i32);`
        当一个元组结构体只有一个字段时, 称为New Type模式. 因为它把一种类型封装成了新类型.
    1. 单元结构体(unit-like struct)

        没有任何字段的结构体, 比如`strcut Empty`.
        `std::ops::RangeFull`就是一个单元结构体.

        在Release编译模式下, 单元结构体实例会被优化为同一个对象; 而在Debug模式下, 则不会进行这样的优化.

    在rust中函数和方法是有区别的, 不在impl块中定义的函数是自由函数, 而在impl块中定义的函数是方法, 第一个参数通常是`&self/&mut self`, 表示对结构体实例自身的引用.
1. 枚举体(Enum)

    分三类:
    1. 无参数枚举体

        ```rust
        enum Number {
            Zero,
            One,
        }

        let a = Number::One;
        ```
    1. 类C枚举体

        ```rust
          enum Number {
            Zero = 1 ,
            One = 2,
        }

        let a = Number::One as i32;
        ```
    1. 带类型参数的枚举体

        ```rust
          enum IpAddr {
            V4(u8,u8,u8,u8),
            V6(String),
        }

        let a = IpAddr::V4(127,0,0,1);
        let b : fn(String) -> IpAddr = IpAddr::V6;//  IpAddr::V6是 `fn(String) -> IpAddr` 函数指针.
        ```
1. 联合体(Union)

### 常用集合类型
std::collections提供了4种通用集合类型:
1. 线性序列: 向量(Vec), 双端队列(VecDeque), 链表(LinkedList)

    向量也是一种数组, 但可动态增长.
    `vec!`是一个宏, 用来创建向量字面量.
    rust的VecDeque是基于可增长的RingBuffer算法实现的双端队列.
    通常最好使用Vec或VecDeque类型, 因为它们比链表更加快速, 内存访问效率更高, 并且可以更好地利用cpu缓存.
1. Key-Value映射: 无序哈希表(HashMap), 有序哈希表(BTreeMap)

    key必须是可哈希的类型
    value必须是在编译期已知大小的类型
1. 集合类型: 无序集合(HashSet), 有序集合(BTreeMap)

    集合类型实际就是把Key-Value映射的Value设置成空元组.
1. 优先队列: 基于二叉最大堆(BinaryHeap)实现.

### 宏
宏语句可以使用圆括号, 中括号, 花括号, 一般使用中括号表示数组.

## FAQ
### 各编程语言中的类型系统
静态类型语言：在编译阶段确定所有变量的类型.
动态类型语言：在执行阶段确定所有变量的类型.
不允许隐式转换的是强类型，允许隐式转换的是弱类型.

- 没类型： 比如汇编语言，没有类型的概念，所有都只是一个数字
- 弱静态类型： 比如C/C++语言，可以定义类型，但是不强制执行，在不同类型之间自动转换
- 强静态类型： 比如Java，定义类型，并且用虚拟机检查类型
- 强动态类型： 比如Python和Ruby，动态推断类型而不需要定义，然后解释器会强制执行.
- 弱动态类型： Perl/PHP,js

![](/misc/img/rust/9zv7ejia98.jpeg)