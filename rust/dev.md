# dev
## 方法论
程序的三大定律:
1. 程序必须正确
1. 程序必须可维护, 但不能违反第一定律
1. 程序必须高效, 但不能违反前两条定律

rust无疑是迈向这个目标的更近一步.

编程两大难题(本质是使用类型不安全的语言, 它们的内存管理机制不完善):
1. 编写内存安全的代码
1. 编写线程安全的代码

> 在之前的年代, 计算资源匮乏, 为追求性能, 牺牲了部分安全性.

## 系统编程语言
系统编程语言是相对于应用级编程语言, 它处于更底层, 更接近硬件层次, 其特点有:
1. 可在资源非常受限环境运行
1. 运行时开销小, 非常高效
1. 很小的运行库, 甚至没有
1. 可以允许直接的内存操作

其他系统编程语言有c,c++等.

## 基本概念
- 数据（值和类型、指针和引用）
- 代码（函数、方法、闭包、接口和虚表）
- 运行方式（并发并行、同步异步和 Promise / async / await ）
- 编程范式（泛型编程）

### 数据
数据是程序操作的对象.

类型是对值的区分, 它包含了值在内存中的长度、对齐以及值可以进行的操作等信息. 且值是无法脱离具体的类型讨论的.

很多编程语言中的数据类型是分为两类：
- 值类型

    一般是指可以将数据都保存在同一位置的类型, 例如数值、布尔值、结构体等都是值类型

    值类型有:
    - 原生类型
    - 结构体
    - 枚举体

- 引用类型

    会存在一个指向实际存储区的指针. 比如通常一些引用类型会将数据存储在堆中，而栈中只存放指向堆中数据的地址（指针）

    引用类型有：
    - 普通引用类型(裸指针), 比如go的指针
    - 原生指针类型, 比如go的slice, map, chan

不管是强类型的语言还是弱类型的语言，语言内部都有其类型的具体表述。一般而言，编程语言的类型可以分为原生类型和组合类型两大类.

原生类型（primitive type）是编程语言提供的最基础的数据类型。比如字符、整数、浮点数、布尔值、数组（array）、元组（tuple）、指针、引用、函数、闭包等。所有原生类型的大小都是固定的，因此它们可以被分配到栈上。

指针和引用:
- 指针: 指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到**任意数据类型**

	胖指针(fat pointer): 比正常指针携带更多信息的指针, 比如包含了动态大小类型地址信息和携带了长度信息的指针, 比如`&str`, `数组[T]`. `&[u32;5]`为普通指针, `&mut [32]`为胖指针. 很多数据结构的引用, 内部都是由胖指针实现的.
- 引用: 引用（reference）和指针非常类似，不同的是，引用的解引用访问是受限的，它只能解引用到它**引用数据的类型**，不能用作它用.

> 编译器会检查对引用的使用是否是类型是匹配合理的, 而指针的就没有这样的限制, 不会编译期间进行检查, 使用灵活性更高, 但也会有更多安全问题. 在 rust 里也只能在 unsafe code 中使用指针, 常规都是使用引用.

组合类型（composite type）或者说复合类型，是指由一组原生类型和其它类型组合而成的类型。组合类型也可以细分为两类:
- 结构体（structure type）：多个类型组合在一起共同表达一个值的复杂数据结构
- 标签联合（tagged union）：也叫不相交并集（disjoint union），可以存储一组不同但固定的类型中的某个类型的对象，具体是哪个类型由其标签决定

### 类型系统
类型是对表示信息的值进行细粒度的区分.

在类型系统中, 一切皆类型. 基于类型定义的一系列组合,运算和转换等方法, 可以看做类型的行为.

类型系统优势:
1. 排查错误 : 很多语言可在编译期或运行期排查的类型错误
1. 抽象 : 抽象有利于强化编程规范和工程化系统
1. 文档 : 明确的类型可表明程序的行为
1. 优化效率 : 静态语言可通过在编译器进行类型检查来优化部分操作, 节省运行时的时间
1. 类型安全
    - 类型安全的语言可避免类型间的无效操作. 比如`3/"hello"`
    - 类型安全的语言可保证内存安全, 避免诸如空指针, 虚悬指针和缓冲区溢出等内存安全问题
    - 类型安全的语言可避免语义上的逻辑错误.

类型系统分类:
- 静态类型: 在编译期进行类型检查的语言
- 动态类型: 在运行期进行类型检查的语言
- 强类型: 不允许类型的自动隐式转换, 在强制转换前不同类型无法操作.
- 弱类型: 与强类型相对.

静态类型的语言能在编译期对代码进行静态分析, 依靠的就是类型系统.

如果一个类型系统允许在一段代码在不同的上下文中具有不同的类型, 该类型系统就叫作多态类型系统.
现代编程语言有三种多态形式:
1. 参数化多态(parametric polymorphism)即泛型

    很多时候函数或数据类型都需要适用多种类型, 以避免大量的重复性工作. 泛型使得语言极具表达力, 同时也能保证静态类型安全.

    在编译期, 都会被单态化(monomorshization, 编译器进行静态分发的一种测量, 即通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程).

    单态化静态分发的好处是性能好, 没有运行时开销, 缺点是容易造成编译后生成的二进制文件膨胀. rust采用该
1. Ad-hoc(ad-hoc polymorphism), 也叫特定多态, 指同一种行为定义在不同的上下文中会响应不同的行为实现.

    haskell使用Typeclass来支持ad-hoc, **rust使用trait来支持ad-hoc多态**即多种类型实现了同一个trait.
    函数重载是ad-hoc多态.
1. 子类型多态(subtype polymorphism)

    一般用在面向对象语言中, 比如java. 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有时也可以看作父类型的值, 反之则不然.

多态的上下文中的方法解析过程被称为分发, 调用该方法被称为分发化（ dispatching）. 因此按多态发生的时间又可分为:
1. 静多态(static polymorphism), 也叫静态分发

    发生在编译期.
    参数化多态和ad-hoc多态一般是静多态.
    静多态牺牲灵活性获取性能.
1. 动多态(dynamic polymorphism), 也叫动态分发, 类似golang的接口

    发生在运行时.
    子类型多态一般是动多态.
    动多态牺牲性能获取灵活性.
    动多态在运行时需要查表, 占用较多空间, 因此一般情况下都使用静多态.

编程语言中不同类型的本质是内存空间和编码方式的不同. 所以编译器需要事先知道类型的大小, 才能分配合理的内存.

### 类型转换
在编程语言中, 类型转换分为隐式类型转换(Implicit Type Conversion ）和显式类型转换(Explicit Type Conversion). 隐式类型转换是由编译器或解释器来完成的，开发者并未参与, 所以又称之为强制类型转换(Type Coercion). 显式类型转换是由开发者指定的，就是一般意义上的类型转换(Type Cast).

不当的类型转换会带来内存安全问题. 比如C语言和 JavaScript 语言中的隐式类型转换.

### 代码
代码是程序运行的主体, 是逻辑的体现.

函数是编程语言的基本要素， 它是对完成某个功能的一组相关语句和表达式的封装。 函数也是对代码中重复行为的抽象. 在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分.

方法是对象内部定义的函数.

闭包是一种特殊的函数, 它将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包.

接口是一个软件系统开发的核心部分，它反映了系统的设计者对系统的抽象理解。作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性.

在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力. 但是，在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，导致无法单纯从一个指针分析出这个引用具备什么样的能力. 因此，在生成这个引用的时候，需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表。这个列表，就是我们熟知的虚表（virtual table）.

由于虚表记录了数据能够执行的接口，所以在运行期，想对一个接口有不同实现，可以根据上下文动态分派.

### 运行方式
代码以何种方式运行，往往决定着程序的执行效率.

并发是同时处理多件事情的能力.

并行是同时刻处理多件事情的手段.

很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个 M:N 的调度器，把 M 个并发任务，合理地分配在 N 个 CPU core 上并行运行，让程序的吞吐量达到最大.

同步是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束.

同步执行保证了代码的因果关系（causality），是程序正确性的保证.

> 在遭遇 I/O 处理时，高效 CPU 指令和低效 I/O 之间的巨大鸿沟，成为了软件的性能杀手.

异步是指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束.

在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象，用来描述在未来的某个时刻才能获得的结果的值，一般存在三个状态:
1. 初始状态，Promise 还未运行
1. 等待（pending）状态，Promise 已运行，但还未结束
1. 结束状态， Promise 成功解析出一个值，或者执行失败

在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 等。除了这个词以外，也经常看到 async/await 这对关键字.

一般而言，async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用**状态机**将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读

### 编程范式
为了在不断迭代时，更好地维护代码，还会引入各种各样的编程范式，来提升代码的质量.

泛型编程包含两个层面，数据结构的泛型和使用泛型结构代码的泛型化.

泛型编程通过参数化让数据结构像函数一样延迟绑定，提升其通用性，类型的参数可以用接口约束，使类型满足一定的行为，同时，在使用泛型结构时，代码也需要更高的抽象度.


## 缺陷
从软件开发的角度来看，一个软件系统想要提供具有良好用户体验的功能，最基本的要求就是控制缺陷. 为了控制缺陷，在软件工程中，定义了各种各样的流程，从代码的格式，到 linting，到 code review，再到单元测试、集成测试、手工测试.

排查缺陷的手段像一个漏斗:
1. 语法缺陷

	对 Rust 来说，它提供了 Rust Language Server / Rust Analyzer 第一时间报告语法错误

1. 类型安全缺陷

	如果将一个程序写得不可能在执行时导致未定义行为，那么就称这个程序为定义良好的（well defined）. 如果一种语言的安全检查可以保证所有程序都定义良好，那么就称这种语言是类型安全的.

	类型安全与一门语言是在编译时还是在运行时检查类型无关. C/C++ 在编译时检查，但它不是类型安全的； Python 在运行时检查，但它是类型安全的.

	rust是强类型语言

1. 内存和资源安全缺陷

	大部分语言，如 Java / Python / Golang / Elixir 等，他们通过语言的运行时解决了内存安全问题.

	Rust 可以说基本上解决了主要的内存和资源的安全问题，通过所有权、借用检查和生命周期检查，来保证内存和资源一旦被分配，在其生命周期结束时，会被释放掉.

1. 并发安全缺陷

	Rust 通过所有权规则和类型系统，主要是两个 trait：Send/Sync 来解决这个问题.

1. 错误处理缺陷

	很多语言并没有强制开发者一定要处理错误，Rust 使用 Result<T, E> 类型来保证错误的类型安全，还强制必须处理这个类型返回的值，避免开发者丢弃错误

1. 码风格和常见错误引发的缺陷

	Rust 有内置的 cargo fmt 和 cargo clippy  来帮助开发者统一代码风格，来避免常见的开发错误

1. 逻辑缺陷
	
	需要有不错的单元测试覆盖率

1. 功能缺陷

	需要通过足够好的集成测试，把用户主要使用的功能测试一遍

1. 用户体验缺陷

	需要端到端的测试，甚至手工测试，才能发现

上述的最后三类缺陷是语言和编译器无法帮助解决的. Rust 在设计之初，尽可能把大量缺陷在编译期，在秒和分钟级就检测出来，让开发者修改，不至于把缺陷带到后续环境，最大程度的保证代码质量.

## 语言安全
语言可以是内存安全、类型安全的，也可以是并发安全的:
- 内存安全意味着程序不会写入禁用的内存地址，也不会访问无效的内存
- 类型安全意味着程序不允许用户为字符串变量分配数字，并且此检查会在编译期发生
- 并发安全意味着程序在执行多个线程时不会因为条件竞争而修改共享状态

如果一种语言自身提供所有这些层面的安全，那么它被认为是安全的.

## 语言比较
- [Golang vs. Rust: Which Programming Language To Choose in 2022?](https://www.trio.dev/blog/golang-vs-rust)

## FAQ
### 鸭子类型
只要给定的值拥有函数运行所需的属性和方法, 那它就能使用这个函数.