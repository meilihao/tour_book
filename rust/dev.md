# dev
## 方法论
程序的三大定律:
1. 程序必须正确
1. 程序必须可维护, 但不能违反第一定律
1. 程序必须高效, 但不能违反前两条定律

rust无疑是迈向这个目标的更近一步.

编程两大难题(本质是使用类型不安全的语言, 它们的内存管理机制不完善):
1. 编写内存安全的代码

	内存泄露（ Memory Leak ）并不在内存安全（ Memory Safety ）范围内.

	内存泄漏是指没有对应该释放的内存进行释放, 属于没有对合法的数据进行操作. 内存不安全操作是对不合法的数据进行了操作.

	只要不会出现以下内存问题即为内存安全:
	1. 使用未定义内存
	1. 空指针
	1. 悬垂指针

		悬垂指针(dangling pointer）是指堆内存已被释放，但其本身还没有做任何处理, 依旧指向己回收内存地址的指针.
	1. 缓冲区溢出
	1. 非法释放未分配的指针或已经释放过的指针
1. 编写线程安全的代码

> 在之前的年代, 计算资源匮乏, 为追求性能, 牺牲了部分安全性.

## 系统编程语言
系统编程语言是相对于应用级编程语言, 它处于更底层, 更接近硬件层次, 其特点有:
1. 可在资源非常受限环境运行
1. 运行时开销小, 非常高效
1. 很小的运行库, 甚至没有
1. 可以允许直接的内存操作

其他系统编程语言有c,c++等.

## 基本概念
- 数据（值和类型、指针和引用）
- 代码（函数、方法、闭包、接口和虚表）
- 运行方式（并发并行、同步异步和 Promise / async / await ）
- 编程范式（泛型编程）

### 数据
数据是程序操作的对象.

类型是对值的区分, 它包含了值在内存中的长度、对齐以及值可以进行的操作等信息. 且值是无法脱离具体的类型讨论的.

根据内存栈和堆的分配机制, 编程语言中的数据类型分为两类：
- 值类型

    一般是指直接将数据保存在栈中的类型, 例如数值、布尔值、结构体等都是值类型

    值类型有:
    - 原生类型
    - 结构体
    - 枚举体

    值类型作为右值进行赋值操作时, 会自动复制一个副本.

- 引用类型

    会存在一个指向实际存储区的指针. 比如通常一些引用类型会将数据存储在堆中，而栈中只存放指向堆中数据的地址（指针）

    引用类型有：
    - 普通引用类型(裸指针), 比如go的指针
    - 原生指针类型, 比如go的slice, map, chan

    一些纯面向对象语言只剩下了引用类型的概念, 比如在 Ruby, Python中一切皆对象, 而对象就是引用类型.

不管是强类型的语言还是弱类型的语言，语言内部都有其类型的具体表述。一般而言，编程语言的类型可以分为原生类型和组合类型两大类.

但随着语言的发展，类型越来越丰富，值类型和引用类型已经难以描述全部情况, 比如一个rust Vector类型, 其内部可以包含基本的值类型，也包含引用类型. rust使用了值语义(value semantic)和引用语义(reference semantic)来定义:
1. 值语义: 按位复制以后与原始对象无关
1. 引用语义:(也叫指针语义): 一般是指将数据存储在heap中, 通过栈中的指针来管理heap上的数据. 引用语义禁止按位复制.

> 按位复制就是指栈复制即浅复制, 它只复制栈上的数据; 相对而言, 深复制就是对栈上和堆上的数据一起复制.

编程语言类型 = 原生类型 + 组合类型.

原生类型（primitive type）是编程语言提供的最基础的数据类型。比如字符、整数、浮点数、布尔值、数组（array）、元组（tuple）、指针、引用、函数、闭包等。所有原生类型的大小都是固定的，因此它们可以被分配到栈上。

指针和引用:
- 指针: 指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到**任意数据类型**

	胖指针(fat pointer): 比正常指针携带更多信息的指针, 比如包含了动态大小类型地址信息和携带了长度信息的指针, 比如`&str`, `数组[T]`. `&[u32;5]`为普通指针, `&mut [32]`为胖指针. 很多数据结构的引用, 内部都是由胖指针实现的.
- 引用: 引用（reference）和指针非常类似，不同的是，引用的解引用访问是受限的，它只能解引用到它**引用数据的类型**，不能用作它用.

> 编译器会检查对引用的使用是否是类型是匹配合理的, 而指针的就没有这样的限制, 不会编译期间进行检查, 使用灵活性更高, 但也会有更多安全问题. 在 rust 里也只能在 unsafe code 中使用指针, 常规都是使用引用.

组合类型（composite type）或者说复合类型，是指由一组原生类型和其它类型组合而成的类型。组合类型也可以细分为两类:
- 结构体（structure type）：多个类型组合在一起共同表达一个值的复杂数据结构
- 标签联合（tagged union）：也叫不相交并集（disjoint union），可以存储一组不同但固定的类型中的某个类型的对象，具体是哪个类型由其标签决定

### 类型系统
类型是对表示信息的值进行细粒度的区分.

在类型系统中, 一切皆类型. 基于类型定义的一系列组合,运算和转换等方法, 可以看做类型的行为.

类型系统优势:
1. 排查错误 : 很多语言可在编译期或运行期排查的类型错误
1. 抽象 : 抽象有利于强化编程规范和工程化系统
1. 文档 : 明确的类型可表明程序的行为
1. 优化效率 : 静态语言可通过在编译器进行类型检查来优化部分操作, 节省运行时的时间
1. 类型安全
    - 类型安全的语言可避免类型间的无效操作. 比如`3/"hello"`
    - 类型安全的语言可保证内存安全, 避免诸如空指针, 虚悬指针和缓冲区溢出等内存安全问题
    - 类型安全的语言可避免语义上的逻辑错误.

类型系统分类:
- 静态类型: 在编译期进行类型检查的语言
- 动态类型: 在运行期进行类型检查的语言
- 强类型: 不允许类型的自动隐式转换, 在强制转换前不同类型无法操作.
- 弱类型: 与强类型相对.

静态类型的语言能在编译期对代码进行静态分析, 依靠的就是类型系统.

如果一个类型系统允许在一段代码在不同的上下文中具有不同的类型, 该类型系统就叫作多态类型系统.
现代编程语言有三种多态形式:
1. 参数化多态(parametric polymorphism)即泛型

    很多时候函数或数据类型都需要适用多种类型, 以避免大量的重复性工作. 泛型使得语言极具表达力, 同时也能保证静态类型安全.

    在编译期, 都会被单态化(monomorshization, 编译器进行静态分发的一种测量, 即通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程).

    单态化静态分发的好处是性能好, 没有运行时开销, 缺点是容易造成编译后生成的二进制文件膨胀. rust采用该
1. Ad-hoc(ad-hoc polymorphism), 也叫特定多态, 指同一种行为定义在不同的上下文中会响应不同的行为实现.

	特定多态是同一种行为的不同实现. rust通过定义 trait 以及为不同的类型实现这个 trait, 就已经实现了特定多态.

    haskell使用Typeclass来支持ad-hoc, **rust使用trait来支持ad-hoc多态**即多种类型实现了同一个trait.
    函数重载和运算符重载是ad-hoc多态.
1. 子类型多态(subtype polymorphism)

    一般用在面向对象语言中, 比如java. 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有时也可以看作父类型的值, 反之则不然.

在 Rust 中, 参数多态通过泛型来支持、特设多态通过 trait 来支持、子类型多态可以用 trait object 来支持.

多态的上下文中的方法解析过程被称为分发, 调用该方法被称为分发化（ dispatching）. 因此按多态发生的时间又可分为:
1. 静多态(static polymorphism), 也叫静态分发

    发生在编译期.
    参数化多态和ad-hoc多态一般是静多态.
    静多态牺牲灵活性获取性能.
1. 动多态(dynamic polymorphism), 也叫动态分发, 类似golang的接口

    发生在运行时.
    子类型多态一般是动多态.
    动多态牺牲性能获取灵活性.
    动多态在运行时需要查表, 占用较多空间, 因此一般情况下都使用静多态.

编程语言中不同类型的本质是内存空间和编码方式的不同. 所以编译器需要事先知道类型的大小, 才能分配合理的内存.

### 类型转换
在编程语言中, 类型转换分为隐式类型转换(Implicit Type Conversion ）和显式类型转换(Explicit Type Conversion). 隐式类型转换是由编译器或解释器来完成的，开发者并未参与, 所以又称之为强制类型转换(Type Coercion). 显式类型转换是由开发者指定的，就是一般意义上的类型转换(Type Cast).

不当的类型转换会带来内存安全问题. 比如C语言和 JavaScript 语言中的隐式类型转换.

### 代码
代码是程序运行的主体, 是逻辑的体现.

函数是编程语言的基本要素， 它是对完成某个功能的一组相关语句和表达式的封装。 函数也是对代码中重复行为的抽象. 在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分.

方法是对象内部定义的函数.

闭包是一种特殊的函数, 它将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包.

接口是一个软件系统开发的核心部分，它反映了系统的设计者对系统的抽象理解。作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性.

在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力. 但是，在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，导致无法单纯从一个指针分析出这个引用具备什么样的能力. 因此，在生成这个引用的时候，需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表。这个列表，就是我们熟知的虚表（virtual table）.

由于虚表记录了数据能够执行的接口，所以在运行期，想对一个接口有不同实现，可以根据上下文动态分派.

### 内存管理
按照内存的管理方式可将编程语言大致分为两类:
1. 手动内存管理

	手动内存管理类需要开发者手动使用malloc和free等函数显式管理内存

	优点: 性能
	确定: 容易出bug
1. 自动内存管理类

	自动内存管理类使用 GC(Garbage Collection, 垃坡回收)来对内存进行自动化管理, 而无须开发者手动开辟和释放内存, 比如 Java, C#, Ruby, Python 等语言都是靠 GC 自动化管理内存的

	优点: 解放心智, 并帮助提升了代码的抽象度和可靠性
	缺点: 性能较差, 尤其是"Stop-the-World"问题

程序通过 malloc 申请到的内存空间是大小不一, 不连续且无序的. 堆分配算法有很多种, 本质分为两大类:
1. 空闲链表(Free List)

	空闲链表的优势是实现简单, 但如果链表遭到破坏 整个堆就无法正常工作.
1. 位图标记(Bitmap)

	优势是速度快, 如果单个内存块数据遭破坏, 不会影响整个堆, 但缺点是容易产生内存碎片

### 运行方式
代码以何种方式运行，往往决定着程序的执行效率.

并发是同时处理多件事情的能力.

并行是同时刻处理多件事情的手段.

很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个 M:N 的调度器，把 M 个并发任务，合理地分配在 N 个 CPU core 上并行运行，让程序的吞吐量达到最大.

同步是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束.

同步执行保证了代码的因果关系（causality），是程序正确性的保证.

> 在遭遇 I/O 处理时，高效 CPU 指令和低效 I/O 之间的巨大鸿沟，成为了软件的性能杀手.

异步是指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束.

在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象，用来描述在未来的某个时刻才能获得的结果的值，一般存在三个状态:
1. 初始状态，Promise 还未运行
1. 等待（pending）状态，Promise 已运行，但还未结束
1. 结束状态， Promise 成功解析出一个值，或者执行失败

在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 等。除了这个词以外，也经常看到 async/await 这对关键字.

一般而言，async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用**状态机**将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读

线程其实是对底层硬件运行过程的直接抽象, 优点: 主流语言默认支持线程, 缺点:
1. 线程调度由kernel控制, 运行顺序无法预测
1. 编写正确的多线程要求高, bug有时难重现和调试 

消除竞态条件的关键在于判断出正确的临界区.

### 编程范式
为了在不断迭代时，更好地维护代码，还会引入各种各样的编程范式，来提升代码的质量.

泛型编程包含两个层面，数据结构的泛型和使用泛型结构代码的泛型化.

泛型编程通过参数化让数据结构像函数一样延迟绑定，提升其通用性，类型的参数可以用接口约束，使类型满足一定的行为，同时，在使用泛型结构时，代码也需要更高的抽象度.

Rust 对面向对象编程风格的支持可以总结为以下几点:
- 封装 : Rust提供了结构体（ struct ）和枚举体(Enum ）来封装数据, 并可使用 pub 定义其字段可见性, 提供了 impl 来实现数据的行为
- 多态 : 通过 trait 和泛型以及枚举体（ Enum ）来允许程序操作不同类型的值
- 代码复用 : 通过泛型单态化, trait 对象, 宏（ macro), 语法扩展( procedural macro), 代码生成（ code generation ）来设计模式

设计模式的思想一共涵盖了4点:
- 针对接口编程
	
	trait
- 组合优于继承
	
	泛型和trait 限定可替代继承实现多态, 基于代数数据类型的结构体或枚举体在没有继承的情况下也一样可以更自由地构造各种类型
- 分离变和不变

	rust语言级支持
- 委托代替继承

	迭代器

### 模块化编程
模块化编程是指可以把整个代码分成小块的、 分散的、 独立的代码块, 这些独立的代码块就被称为模块.

模块化编程拥有如下3点好处:
1. 增强维护性 : 一个设计良好的模块，独立性更高, 对外的依赖更少, 更方便维护
1. 隔离性 : 拥有各自的命名空间, 避免命名冲突, 限制错误范围等
1. 代码复用 : 通过引入现成的模块来避免代码复制

## 缺陷
从软件开发的角度来看，一个软件系统想要提供具有良好用户体验的功能，最基本的要求就是控制缺陷. 为了控制缺陷，在软件工程中，定义了各种各样的流程，从代码的格式，到 linting，到 code review，再到单元测试、集成测试、手工测试.

排查缺陷的手段像一个漏斗:
1. 语法缺陷

	对 Rust 来说，它提供了 Rust Language Server / Rust Analyzer 第一时间报告语法错误

1. 类型安全缺陷

	如果将一个程序写得不可能在执行时导致未定义行为，那么就称这个程序为定义良好的（well defined）. 如果一种语言的安全检查可以保证所有程序都定义良好，那么就称这种语言是类型安全的.

	类型安全与一门语言是在编译时还是在运行时检查类型无关. C/C++ 在编译时检查，但它不是类型安全的； Python 在运行时检查，但它是类型安全的.

	rust是强类型语言

1. 内存和资源安全缺陷

	大部分语言，如 Java / Python / Golang / Elixir 等，他们通过语言的运行时解决了内存安全问题.

	Rust 可以说基本上解决了主要的内存和资源的安全问题，通过所有权、借用检查和生命周期检查，来保证内存和资源一旦被分配，在其生命周期结束时，会被释放掉.

1. 并发安全缺陷

	Rust 通过所有权规则和类型系统，主要是两个 trait：Send/Sync 来解决这个问题.

	> 共享可变状态是万恶之源.

1. 错误处理缺陷

	很多语言并没有强制开发者一定要处理错误，Rust 使用 Result<T, E> 类型来保证错误的类型安全，还强制必须处理这个类型返回的值，避免开发者丢弃错误

1. 码风格和常见错误引发的缺陷

	Rust 有内置的 cargo fmt 和 cargo clippy  来帮助开发者统一代码风格，来避免常见的开发错误

1. 逻辑缺陷
	
	需要有不错的单元测试覆盖率

1. 功能缺陷

	需要通过足够好的集成测试，把用户主要使用的功能测试一遍

1. 用户体验缺陷

	需要端到端的测试，甚至手工测试，才能发现

上述的最后三类缺陷是语言和编译器无法帮助解决的. Rust 在设计之初，尽可能把大量缺陷在编译期，在秒和分钟级就检测出来，让开发者修改，不至于把缺陷带到后续环境，最大程度的保证代码质量.

### 错误
错误有3类:
- 失败(Failure) : 违反契约(满足程序正确运行的前提条件)的行为
- 错误(Error) : 可能出现问题的位置出现了问题. 在意料之中, 并且有办法解决的问题, 这些问题通常都和具体的业务相关联 
- 异常(Exception): 不可预知的问题

常见错误处理方式:
1. 返回代号

	在发生错误时，大量的 C 函数会返回−1 或 NULL。当进行系统调用时出现错误， C 语言会设置全局变量 errno 表示调用失败
1. 异常

	Java 和 C#之类的高级编程语言就是采用`try...catch`方式处理错误的

Rust 没有沿用上述两种处理方式, 而是有一套独特的处理异常情况的机制，其并不像其它语言中的 try 机制那样, 而是借鉴 Haskell定义了Option和Result.

## 语言安全
语言可以是内存安全、类型安全的，也可以是并发安全的:
- 内存安全意味着程序不会写入禁用的内存地址，也不会访问无效的内存
- 类型安全意味着程序不允许用户为字符串变量分配数字，并且此检查会在编译期发生
- 并发安全意味着程序在执行多个线程时不会因为条件竞争而修改共享状态

如果一种语言自身提供所有这些层面的安全，那么它被认为是安全的.

## 语言比较
- [Golang vs. Rust: Which Programming Language To Choose in 2022?](https://www.trio.dev/blog/golang-vs-rust)

## 高并发
作为构建高性能事件驱动系统的一个很典型模式, Reactor pattern 包含三部分
- task，待处理的任务。任务可以被打断，并且把控制权交给 executor，等待之后的调度
- executor，一个调度器。维护等待运行的任务（ready queue），以及被阻塞的任务（wait queue）
- reactor，维护事件队列。当事件来临时，通知 executor 唤醒某个任务等待运行

executor 会调度执行待处理的任务，当任务无法继续进行却又没有完成时，它会挂起任务，并设置好合适的唤醒条件。之后，如果 reactor 得到了满足条件的事件，它会唤醒之前挂起的任务，然后 executor 就有机会继续执行这个任务。这样一直循环下去，直到任务执行完毕


以 tokio 为例：async/await 提供语法层面的支持，Future 是异步任务的数据结构，当 fut.await 时，executor 就会调度并执行它.

tokio 的调度器（executor）会运行在多个线程上，运行线程自己的 ready queue 上的任务（Future），如果没有，就去别的线程的调度器上“偷”一些过来运行。当某个任务无法再继续取得进展，此时 Future 运行的结果是 Poll::Pending，那么调度器会挂起任务，并设置好合适的唤醒条件（Waker），等待被 reactor 唤醒。而 reactor 会利用操作系统提供的异步 I/O，比如 epoll / kqueue / IOCP，来监听操作系统提供的 IO 事件，当遇到满足条件的事件时，就会调用 Waker.wake() 唤醒被挂起的 Future。这个 Future 会回到 ready queue 等待执行.

tokio 一般会在每个物理线程（或者 CPU core）下运行一个线程，每个线程有自己的 run queue 来处理 Future。为了提供最大的吞吐量，tokio 实现了 work stealing scheduler，这样，当某个线程下没有可执行的 Future，它会从其它线程的 run queue 中“偷”一个执行


不是所有的应用场景都适合用 async/await:
1. 处理计算密集型任务时

	当处理的任务是 CPU 密集型，而非 IO 密集型，更适合使用线程，而非 Future.

	因为 Future 的调度是协作式多任务（Cooperative Multitasking），也就是说，除非 Future 主动放弃 CPU，不然它就会一直被执行，直到运行结束.

	也可用tokio::task::yield_now()主动让出cpu, 避免某个计算密集型的任务饿死其它任务.
2. 异步代码中使用 Mutex 时

	大部分时候，标准库的 Mutex 可以用在异步代码中，而且，这是推荐的用法. 然而，标准库的 MutexGuard 不能安全地跨越 await，所以，当需要获得锁之后执行异步操作，必须使用 tokio 自带的 Mutex
3. 在线程和异步任务间做同步时

	一般的做法是使用 channel 来在线程和 future 两者之间做同步

## FAQ
### 鸭子类型
只要给定的值拥有函数运行所需的属性和方法, 那它就能使用这个函数.

### 内存对齐
内存对齐包括基本数据对齐和结构体（或联合体）数据对齐.

对于基本数据类型，默认对齐方式是按其大小进行对齐，也被称作自然对齐.

假设对齐字节数为 (N= 1, 2, 4, 8, 16）, 每个成员内存长度为 Len, Max(Len）为最大成员内存长度. 如果没有外部明确的规定, N默认按 Max(Len）对齐. 字节对齐规则为:
1. 结构体的起始地址能够被 Max(Len）整除
1. 结构体中每个成员相对于结构体起始地址的偏移量, 即对齐值, 应该是 Min(N, Len)的倍数, 若不满足对齐值的要求, 编译器会在成员之间填充若干个字节.
1. 结构体的总长度应该是 Min(N, Max (Len））的倍数，若不满足总长度要求, 则编译器会在为最后一个成员分配空间后, 在其后面填充若干个字节.

### 并发与并行
并发是一种能力，而并行是一种手段. 因为并行处理是基于硬件的，而并发处理是可以通过设计编码进行提高的.

在代码的运行方式中，并发是并行的基础，是同时与多个任务打交道的能力；并行是并发的体现，是同时处理多个任务的手段.

很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个 M:N 的调度器，把 M 个并发任务，合理地分配在 N 个 CPU core 上并行运行，让程序的吞吐量达到最大, 比如go.

### 同步和异步
同步是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束.

同步执行保证了代码的因果关系（causality），是程序正确性的保证.

然而在遭遇 I/O 处理时，高效 CPU 指令和低效 I/O 之间的巨大鸿沟，成为了软件的性能杀手.

异步是指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束.

在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象，用来描述在未来的某个时刻才能获得的结果的值，一般存在三个状态:
1. 初始状态，Promise 还未运行
1. 等待（pending）状态，Promise 已运行，但还未结束
1. 结束状态， Promise 成功解析出一个值，或者执行失败

在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 以及 async/await.

一般而言，async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用**状态机**将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读.

### 各编程语言中的类型系统
静态类型语言：在编译阶段确定所有变量的类型.
动态类型语言：在执行阶段确定所有变量的类型.
不允许隐式转换的是强类型，允许隐式转换的是弱类型.

- 没类型： 比如汇编语言，没有类型的概念，所有都只是一个数字
- 弱静态类型： 比如C/C++语言，可以定义类型，但是不强制执行，在不同类型之间自动转换
- 强静态类型： 比如Java，定义类型，并且用虚拟机检查类型
- 强动态类型： 比如Python和Ruby，动态推断类型而不需要定义，然后解释器会强制执行.
- 弱动态类型： Perl/PHP,js

> ruby和Python在运行时通过Duck Typing来进行运行时类型检查, 以保证类型安全.

![](/misc/img/rust/9zv7ejia98.jpeg)

### 函数式编程（functional programming）
函数式编程风格通常包含将函数作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等等.

Rust 的一些在功能上与其他被认为是函数式语言类似的特性:
- 闭包（Closures），一个可以储存在变量里的类似函数的结构
- 迭代器（Iterators），一种处理元素序列的方式

### SOLID 原则
- SRP：单一职责原则，是指每个模块应该只负责单一的功能，不应该让多个功能耦合在一起，而是应该将其组合在一起
- OCP：开闭原则，是指软件系统应该对修改关闭，而对扩展开放
- LSP：里氏替换原则，是指如果组件可替换，那么这些可替换的组件应该遵守相同的约束，或者说接口
- ISP：接口隔离原则，是指使用者只需要知道他们感兴趣的方法，而不该被迫了解和使用对他们来说无用的方法或者功能
- DIP：依赖反转原则，是指某些场合下底层代码应该依赖高层代码，而非高层代码去依赖底层代码

好的 trait, 设计一定是符合 SOLID 原则的