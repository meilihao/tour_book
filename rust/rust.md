# rust
> 部分example来自[Rust By Practice( Rust 练习实践 )](https://practice-zh.course.rs/)

rust是一门同时追求**安全,并发和性能**的现代系统级编程语言.

rust是一门系统编程语言, 特点:
1. 高性能: 没有gc
1. 高可靠: 所有权模型保证了内存安全和线程安全
1. 生产力: 拥有出色的文档、友好的编译器和清晰的错误提示信息, 还集成了一流的工具 cargo, 智能地自动补全和类型检验的多编辑器支持, 以及自动格式化代码等等

Rust 中最大的思维转换就是变量的所有权和生命周期，这是几乎所有编程语言都未曾涉及的领域.

> Rust 处理很多问题的思路: 编译时, 处理大部分使用场景, 保证安全性和效率; 运行时, 处理无法在编译时处理的场景, 会牺牲一部分效率, 提高灵活性. 比如使用Rc和Arc共享内存绕过所有权限制; 静态分发和动态分发.

rust三大设计哲学:
1. 内存安全
ref:
- [Rust、Go、C ，哪个才是“内存管理大师”？](https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655873042&idx=1&sn=db17488d9ea741c280cf26ee6fb4b8ea)

    RUST的内存安全指的是通过编译器提供基础设施，程序员利用基础设施创建内存安全的类型结构使编译器能够保证此类型的内存安全.

    > RUST官方语言库安全戏法的一些套路：安全类型结构基本上是一个封装类型结构，真正要操作的原始变量被封装在内，并且，此封装类型结构拥有原始变量的所有权.

	类型安全即类型系统可以保证程序的行为是意义明确, 不出错的. c/c++的类型系统不是类型安全的, 比如它们不检查数组越界, 这导致发生了语音规范规定之外的行为即未定义行为(Undefined Behavior). 类型系统其实就是，对类型进行定义、检查和处理的系统.

    > 类型安全: 类型系统给内存中的plain data赋予了类型信息，如果不按照类型信息来解释内存中的数据，应该产生编译错误或者 产生well-specified的运行时错误.

    类型安全是内存安全的前提.

    内存安全: 不会出现内存访问错误, 只有当程序访问未定义内存时才会产生内存错误. 常见的场景有:
    1. 引用空指针
    1. 使用未初始化内存
    1. 释放后再次使用, 即虚悬指针
    1. 缓冲区溢出, 比如数组越界
    1. 非法释放已释放过的指针或未分配的指针, 即重复释放

    rust为了保证内存安全, 建立了严格的安全内存管理模型:
    - 所有权系统: 每个被分配的内存都有一个独占其所有权的指针. 只有当该指针被销毁时, 其对应的内存该会被随之释放.
    - 借用和生命周期: 每个变量都有其生命周期, 一旦超出生命周期, 变量就会被自动释放. 如果是借用, 则可以通过标记生命周期参数供编译器检查的方式, 防止出现虚悬指向即释放后使用的情况.

    所有权和生命周期是 Rust 和其它编程语言的主要区别, 也是 Rust 其它知识点的基础.

    rust所有权系统还包括了从现代c++借鉴的RAII机制, 这是rust无gc但是可以安全管理内存的基石. 在 C++ 中，这种 item 在生命周期结束时释放资源的模式被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）.
    
    > 悬垂指针（dangling pointer, 也叫虚悬指针）是其指向的内存可能已经被分配给其它持有者.

    为了实现内存安全, rust还具备独有的特性:
    1. 仿射类型(Affine Type), 该类型可用来表达rust所有权中的Move语义.
    1. 借用, 生命周期

    借助类型系统, rust可在编译阶段对类型进行检查是否满足安全内存模型, 有效地阻止未定义行为的发生.

    Rust通过使用借用检查器(borrow checker)、所有权(ownership)、借用(borrow)这三个概念来管理和确保跨堆栈和堆的内存安全来管理内存，从而实现内存管理.

	所有权有点类似核心原则, 而借用和生命周期是对语言类型系统的扩展.

    内存安全bug和并发安全的bug的产生内在原因均是内存的不正当访问造成的. 借助装备了所有权的强大类型系统, rust还解决了并发安全问题. 它通过静态检查分析, 在编译期就能检查出多线程并发代码中所有的数据竞争问题.
1. 零成本抽象

    零成本抽象即如果不使用某个抽象, 就不用为它付出开销.

    rust的绝大多数抽象并不存在运行时的开销, 其一切都是在编译期完成的.

    rust的零成本抽象的基石是泛型和trait.
1. 实用性

    为了保证安全性, Rust 引入了强大的类型系统和所有权系统, 不仅保证内存安全, 还保证了并发安全, 同时还不会牺牲性能.

    为了保证支持硬实时, rust借鉴了c++的确定性析构, RAII和智能指针, 用于自动地, 确定地管理内存, 从而避免了gc的引入.

    为了保证程序的鲁棒性, rust重新审视了错误处理机制. rust针对三类非正常情况: 失败, 错误和异常, 提供了专门的处理方式:
    - 失败: 使用断言工具
    - 错误: 基于返回值的分层错误处理. 比如`Option<T>`用来处理可能存在空值的情况, `Result<T>`用来处理可以被合理解决并需要传播的错误
    - 异常: rust将其看作无法被合理解决的问题, 提供了线程恐慌机制, 发生异常时, 线程可以安全地退出.

    为了兼容现有生态, rust支持方便且零成本的FFI机制, 兼容C-ABI, 在语言架构层面上将rust分为safe rust和unsafe rust两部分. unsafe专门和外部生态打交道, 因为rust编译器检查和跟踪的范围有限, 不能检查到与其链接的其他生态接口, 因此这些生态由自身来保证安全性. 总结就是, safe rust由rust编译器在编译时保证安全, unsafe rust开发者让编译器信任自身有能力保证安全.

    同时rust提供了强大的包管理器cargo.

rust编程的哲学和golang相同: 组合优于继承. rust不提供类型层面上的继承, 所有的类型都是独立存在的.

Rust中可导致内存泄漏的情况大概有3种：
1. 线程崩溃, 析构函数无法调用
1. 使用引用计数时造成了循环引用
1. 调用 Rust 标准库中的 forget 函数主动泄漏

以上3种情况从本质上是rust并不会保证百分之百调用析构函数.

## 发版
Rust 编译器的版本号采用了`语义化版本号（ Semantic Versioning ）`规划, 版本格式为: `主版本号.次版本号.修订号`.

为了兼顾更新速度以及稳定性, Rust 使用了多渠道发布的策略:
- nightly

	nightly 版本是每天在主版本上自动创建出来的版本，这个版本上的功能最多，更新最快，但是某些功能存在问题的可能性也更大 因为新功能会首先在这个版本上开启，供用户试用.

	nightly 版本中使用试验性质的功能，必须手动开启 featur gate 也就是说要在当前项目的入口文件中加入`#![feature (name,...)]`语句, 否则是编译不过的. 等到这个功能最终被稳定了, 再用新版编译器编译的时候，它会警告你这个 feature gate 现在是多余的了，可以去掉了.

- beta

	beta 版本是每隔 段时间，将一些在 nightly 版本中验证过的功能开放给用户使可以被看作 stable 版本的“预发布”版本
- stable

	stable 版本则是正式版，它定期发布一个新版本，一些实验性质的新功能在此版本上无法使用, 因此它也是最稳定、最可靠的, 保证向前兼容的版本. 

Rust 相对重大的设计必须经过 RFC(Request For Comments ）设计步骤. 这个步骤主要是用于讨论如何“设计”语言. [这个项目](https://github.com/rust-lang/rfcs)旨在于所有大功能必须先写好设计文挡，讲清楚设计的目标、实现方式 优缺点等，让整个社区参与讨论，然后由“核心组”(Core Team)的成员参与定夺是否接受这个设计. 许多深层次的设计思想问题可以在这个项目中找到答案.

rust的`RFC -> Nightly -> Beta -> Stable`策略成功实践了快速迭代、敏捷交付以及 视用户反馈的特点，同时也保证了核心设计的稳定性--用户可以根据自己的要和风险偏好，选择合适的版本.

2017 年下半年, rust 设计组又提出了一个基于 poch 演进策略（后来也被称为edition). 它要解决的问题是`如何让 Rust 平稳地进化`. 简单来说就是让 Rust 的兼容性保证是一个有时限的长度, 而不是永久.

## 内存管理
Rust 编译器目前自带两个默认分配器: alloc_system和alloc_jemalloc.

Rust 2015的编译器产生的二进制文件默认使用 alloc_jemalloc(某些平台可能不支持 jemalloc), 而对于静态或动态链接库默认使用 alloc_system.

Rust 2018默认使用 alloc_system, 并且可由开发者自己指定 jmalloc 或其他第三方分配器.

## 编译
Rust 是跨平台语次编译, 到处运行, 这得益于 LLVM.

rust编译器是LLVM编译器的前端, 它将代码编译成LLVM IR, 然后通过LLVM编译成对应架构的机器码.

rust源码经过分词和解析生成AST(抽象语法树), 再进一步简化处理为HIR(High-level IR, 方便编译器做类型检查), 再进一步编译为[MIR](https://play.rust-lang.org/)(middle IR, 在rust 1.12引入), 最后MIR被翻译为LLVM IR, 之后由LLVM编译成目标机器码.

> 最开始借用检查器是基于HIR, 检查颗粒度粗. rust 2018引入NLL后, 可在MIR检查借用, 检查颗粒度细.

引入MIR原因:
1. 缩短编译时间

    实现了增量编译, 仅重新编译更改过的部分.
1. 缩短执行时间

    进入llvm前实现更细颗粒度的优化即增加了更多的优化空间. 单纯依赖llvm的优化颗粒度太粗, 且rust无法控制
1. 更精确的类型检查

    实现更灵活的借用检查

MIR是基于控制流图（Control Flow Graph，CFG）的抽象数据结构，它用有向图（DAG）形式包含了程序执行过程中所有可能的流程, 所以将基于MIR的借用检查称为非词法作用域的生命周期, 因此确实不依赖词法作用域了.

MIR由一下关键部分组成：
- 基本块（Basic block，bb），他是控制流图的基本单位，
    
    - 语句（statement）
    - 终止句（Terminator）

- 本地变量, 栈中内存的位置，比如函数参数、局部变量等. 一般用下划线和数字作为标识(比如`_1`), 其中`_0`通常表示返回地址.
- 位置（Place），在内存中标识未知的额表达式。
- 右值（RValue），产生值的表达式。


> LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time), 链接时间(link-time), 运行时间(run-time)以及空闲时间(idle-time).

> 无疑，不同编译器的中间语言IR是不一样的，而IR可以说是集中体现了这款编译器的特征：它的算法，优化方式，汇编流程等等，想要完全掌握某种编译器的工作和运行原理，分析和学习这款编译器的中间语言无疑是重要手段. 由于中间语言相当于一款编译器前端和后端的“桥梁”，如果我们想进行基于LLVM的后端移植，无疑需要开发出对应目标平台的编译器后端，想要顺利完成这一工作，透彻了解LLVM的中间语言无疑是非常必要的工作. LLVM相对于gcc的一大改进就是大大提高了中间语言的生成效率和可读性, LLVM的中间语言是一种介于c语言和汇编语言的格式, 它既有高级语言的可读性, 又能比较全面地反映计算机底层数据的运算和传输的情况, 精炼而又高效.

## 语言架构
rust概念层次:
1. 混合编程规范

	面向对象+函数式
1. 语义

	所有权, move, copy, 借用, 生命周期, drop等
1. 类型系统

	承载上层的语义和混合编程规范, 赋予了 Rust 高级的抽象表达能力和安全性. 同时还保留了对底层代码执行、数据表示和内存分配等操作的控制能力.

1. 安全内存管理层

### 类型系统
rust是强类型且类型安全的静态语言, 是显式静态类型.

> 显式: 明确指定具体的类型

rust同时支持静多态(参数化多态+ad-hoc多态, 即泛型和trait)和动多态, 其静多态就是一种零成本抽象.

rust中一切皆表达式, 表达式皆有值, 值皆有类型 => rust中一切皆类型.

除了一些基本的原生类型和复合类型, Rust还把作用域也纳入了类型系统即生命周期. 一些根本无法返回值的情况, 比如线程崩溃、 break和continue 等行为, 也都被纳入了类型系统即never 类型. 因此Rust类型系统基本囊括了编程中会遇到的各种情况, 一般情况下不会有未定义的行为出现.

Rust 绝大部分类型都是在编译期可确定大小的类型（Sized Type ）, 但也有少量动态大小的类型（Dynamic Sized Type, DST ）, 比如 str 类型的字符串字面量. 针对DST, Rust 提供了引用类型, 因为引用总会有固定的且在编译期己知的大小.

对于 DST 类型, Rust 有如下限制:
- 只能通过指针来间接创建和操作 DST 类型, `＆[T]/Box<T>`可以, [T]不可以
- 局部变量和函数参数的类型不能是 DST 类型, 因为局部变量和函数参数必须在编译阶段知道它的大小, 因为目前unsized rvalue 功能还没有实现
- enum不能包含DST类型, struct 中只有最后一个元素 以是 DST, 其他成员不行, 如果包含有 DST 类型, 那么这个结构体也就成了 DST 类型.

rust还有零大小类型(zero sized type, zst), 比如单元类型和单元结构体, 同时由该类型组成的数组大小也为零. ZST类型的特点是, 它们的值就是其本身, 运行时并不占用内存空间. 它是Sized Type的特例.

> 动态大小类型(Dynamic sized type, dst)是指编译阶段无法确定占用空间的类型, 为了安全, 指向dst的指针一般是胖指针. 胖指针的设计, 避免了数组类型作为参数传递时自动退化为裸指针类型，丢失了长度信息的问题, 保证了类型安全.

> `&str`是引用类型(包含指针和长度信息), 存储在栈上, str字符串是存储在堆上.

> rust没有gc, 内存首先由编译器分配, rust代码被编译成llvm ir, 其中就携带了内存分配信息. 所以编译器需要事先知道类型, 才好分配合理的内存.

never类型(底类型)表示永远不可能有返回值的类型, 特点:
1. 没有值
1. 是其他任意类型的子类型, 因此**可强制转换为其他任何类型**

如果说ZST类型表示"空", 那么底类型表示"无". rust中使用`!`表示底类型.

rust中有很多情况确实没有值, 但为了类型安全, 必须把这些情况纳入类型系统进行统一处理, 包括:
1. 发散函数(diverging function)

    返回类型是`!`, 表示该代码永远不会返回. 发散类型可转为任意一种类型.
1. continue和break
1. loop的无限循环
1. 空枚举, 比如`enum Void{}`

发散函数有:
1. 导致线程崩溃的panic!("....")以及基于它实现的各种函数/宏, 比如unimplemented!, unreachable!
1. 用于退出函数的`std::process::exit`, 这类函数永远没有返回值.

#### 类型推导
rust和go类似, 只能对局部变量/全局变量进行类型推导, 而函数签名等场景下是不允许的, 这是有意为之, 同时常量（const）和静态变量（static）也必须声明类型. 同时rust使用`as`显式转换类型.

> as同样可用于导入重命名

rust的类型推导强于go, 因为它支持上下文式的推导. 个人建议不要使用上下文推导而是声明时就指定类型.

`xxx::<i32>()`该形式是泛型函数标注类型, `::<>`的形式称为turbofish操作符, 它通常用于在表达式中为泛型类型、函数或方法指定参数, 解决rust无法从上下文中自动推导出类型的时候.

#### 类型语义
随着类型越来越丰富, 值类型和引用类型难以描述全部情况, rust所以引入了：
- 值语义（Value Semantic）

    复制以后，两个数据对象拥有的存储空间是独立的，互不影响

    基本的原生类型都是值语义，这些类型也被称为 POD（Plain old data）. POD 类型都是值语义，但是值语义类型并不一定都是 POD 类型

    具有值语义的原生类型，在其作为右值进行赋值操作时，**编译器会对其进行按位复制**

- 引用语义（Reference Semantic）

    复制以后，两个数据对象互为别名. 操作其中任意一个数据对象，则会影响另外一个.

    智能指针Box<T>封装了原生指针，是典型的引用类型. Box<T>无法实现 Copy，意味着它被 rust 标记为了引用语义，禁止按位复制.

    引用语义类型不能实现 Copy，但可以实现 Clone 的 clone 方法，以实现深复制.


在 Rust 中，可以通过是否实现 Copy trait 来区分数据类型的值语义和引用语义. 但为了更加精准，Rust 也引用了新的语义：复制（Copy）语义和移动（Move）语义
- Copy语义：对应值语义, 即实现了 Copy 的类型在进行按位复制时是安全的

    这些Copy的类型都在栈中, 编译器知道它们的大小. 比如`Primitive Types中的整数、浮点数、布尔值(true和false)和char`
- Move语义：对应引用语义, 在 Rust 中不允许按位复制，只允许移动所有权

    Clone和Copy类似，但通常需要更多的内存. 另外, 必须用显式`.clone()`来调用它即它不会自己克隆

实现了 Copy trait的作用: 实现 Copy trait 的类型同时拥有复制语义，在进行赋值或者传入函数等操作时，默认会进行按位复制.

对于默认可以安全的在栈上进行按位复制的类型，就只需要按位复制，也方便管理内存.
对于默认只可在堆上存储的数据，必须进行深度复制. 深度复制需要在堆内存中重新开辟空间，这会带来更多的性能开销.

##### 哪些实现了 Copy
ref:
- [官方文档 Copy trait 的页面包含了 Rust 标准库中实现 Copy trait 的所有数据结构](https://doc.rust-lang.org/std/marker/trait.Copy.html)

一个类型实现了Copy, 其 clone 方法就是按位复制, 因此旧变量在复制后仍有效.

任何标量类型及其组合类型都是Copy. 任何不需要分配内存或某种形式资源的类型都可以实现 Copy.

- 结构体 ：当成员都是复制语义类型时，不会自动实现 Copy
- 枚举体 ：当成员都是复制语义类型时，不会自动实现 Copy
- 元组类型 ：本身实现了 Copy. 如果元素均为复制语义类型，则默认是按位复制，否则执行移动语义
- 字符串字面量 &str： 支持按位复制

结构体 && 枚举体：
1. 所有成员都是复制语义类型时，需要添加属性#[derive(Debug,Copy,Clone)]来实现 Copy
1. 如果有移动语义类型的成员，则无法实现 Copy

总结:
- 原生类型，包括函数、不可变引用和裸指针实现了 Copy
- 数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy
- 可变引用没有实现 Copy
- 非固定大小的数据结构，没有实现 Copy

判断是否Copy:
```rust
fn is_copy<T: Copy>() {}

fn main() {
    is_copy::<bool>();
    is_copy::<str>(); // 无法编译
}
```

##### 哪些未实现 Copy
一个类型或者该类型的一部分实现了Drop, 那么就不允许实现Copy了.

String ：to_string() 可以将字符串字面量转换为String

### 语言组成
rust组成:
- 语言规范

	主要由 Rust 语言参考（ The Rust Reference）和 RFC 文档共同构成.

	Rust 语言参考是官方团队维护的一份参考文档(非正式但已最接近正式规范), 包含了三类内容:
	1. 对每种语言结构及其用法的描述
	1. 对内存模型、并发模型、链接、调试等内存的描述
	1. 影响语言设计的基本原理和参考

- 编译器
- 核心库

	Rust的语法由核心库和标准库共同提供, 其中核心库是标准库的基础.

    它定义了rust语言的核心, 不依赖于操作系统和网络等相关的库, 不负责堆分配,不提供并发和I/O.

    可通过在模块顶部引入`#![no_std]`来使用核心库, 它是做嵌入式开发所必须的. 核心库和标准库的功能有一些重复.
    
    核心库组成:
    1. 基础trait, 如Copy, Debug, Display,Option等
    1. 基本原始类型, 如 bool, char, i8/u8, i64/u64, isize/usize, f32/f64, str, array, slic, tuple, pointer等
    1. 常用功能型数据类型, 比如String, Vec, HashMap, Rc, Arc, Box等

        String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型.

        Rust 标准库中还包含一系列其他字符串类型，比如 OsString、OsStr、CString 和 CStr, 前缀(非String/非Str)对应着它们提供的所有权和可借用的字符串变体.

        使用 to_string 方法从字符串字面值创建 String: `"...".to_string()` <=> `String::from("...")` <=> `str::to_string("hello")`<=>`ToString::to_string("hello")`<=>`<str as ToString>::to_string("hello")`.

        其他形式称为限定方法调用，因为它们需要指定`方法关联的类型或特型`. 最后一种带尖括号的形式，则同时指定了两者，因此称为完全限定方法调用, 比如`<str as ToString>::to_string()`.

        完全限定方法调用用途:
        1. 两个trait方法同名, 不知用哪个
        1. 无法推断self参数的类型
        1. 将函数本身作为参数
        1. 在宏里调用trait方法

        ```rust
        trait UsernameWidget {
            fn get(&self) -> String;
        }

        trait AgeWidget {
            fn get(&self) -> u8;
        }

        struct Form {
            username: String,
            age: u8,
        }

        impl UsernameWidget for Form {
            fn get(&self) -> String {
                self.username.clone()
            }
        }

        impl AgeWidget for Form {
            fn get(&self) -> u8 {
                self.age
            }
        }

        fn main() {
            let form = Form{
                username: "rustacean".to_owned(),
                age: 28,
            };

            // 如果你反注释下面一行代码，将看到一个错误: Fully Qualified Syntax
            // 毕竟，这里有好几个同名的 `get` 方法
            // 
            // println!("{}", form.get());
            
            let username = UsernameWidget::get(&form); // 完全限定语法
            assert_eq!("rustacean".to_owned(), username);
            let age = AgeWidget::get(&form); // 你还可以使用以下语法 `<Form as AgeWidget>::get`
            assert_eq!(28, age);

            println!("Success!")
        }
        ```

        **Rust 的字符串不支持索引**.

        遍历: `for c in "नमस्ते".chars()`或`for b in "नमस्ते".bytes()`.

        Rust 的原始字符串语法是在`r`后跟一个或多个`#`和一个双引号, 然后是字符串内容, 最后以另一个双引号及相同个数的`#`结尾. 原始字符串中的任何字符都无须转义，包括双引号. 为避免歧义，通过在双引号两侧添加更多的`#`，总是可以明确标识字符串的结束位置
    1. 常用的宏定义, 如println()!, assert!, panic!, vec!

        Rust 中的宏(`!`)与C/C＋＋ 中的宏是完全不一样的东西. 简单点说，可以把它理解为一种安全版的编译期语法扩展, 这里之所以使用宏，而不是函数，是因为标准输出宏可以完成编译期格式检查. 更加安全. 这个宏最终还是调用了`std::io`模块内提供的一些函数来完成的. 如果需要更精细地控制标准输出操作, 也可以直接调用标准库来完成.

        Rust 支持声明宏（declarative macro）和过程宏（procedure macro），其中过程宏又包含三种方式：函数宏（function macro），派生宏（derive macro）和属性宏（attribute macro）. println! 是函数宏，是因为 Rust 是强类型语言，函数的类型需要在编译期敲定，而 println! 接受任意个数的参数，所以只能用宏来表达.

- 标准库

    提供应用程序开发所需的基础和跨平台支持.

    标准库组成:
    1. 与核心库一样的基本trait, 原始数据类型, 功能型数据类型和常用的宏等, 以及与核心库几乎完全一致的API.
    1. 并发, I/O和运行时.
    
        如线程模块, 用于消息传递的通道类型, Sync trait等并发模块, 文件, tcp, udp, 管道, socket等常见I/O.
    1. 平台抽象.
        - os模块提供了许多与操作环境交互的基本功能, 包括程序参数, 环境变量, 目录导航
        - 路径模块封装了处理文件路径的平台特定规则.
    1. 底层操作接口

        如std::mem,std::ptr, std::intrinsic等, 操作内存,指针, 调用编译器固有函数.

    1. 可选和错误处理类型Option和Result, 以及各种迭代器.

    Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举, 这个枚举是`Option<T>`，而且它定义于标准库中.
- 包管理器

Rust 源代码的后缀名使用`.rs`表示, 且必须使用 utf-8 编码.

#### Rust命令规范
> rust使用蛇形命名法(snake case)来规范函数和变量名称的风格: 只使用小写的字母进行命名, 并以`_`分割word.

- 函数： 蛇形命名法（snake_case），例如：func_name()
- 文件名： 蛇形命名法（snake_case），例如file_name.rs、main.rs
- 临时变量名：蛇形命名法（snake_case）
- 全局变量名：
- 结构体： 大驼峰命名法，例如：struct FirstName { name: String}
- enum类型: 大驼峰命名法
- 关联常量：常量名必须全部大写
- Cargo默认会把连字符`-`转换成下划线`_`
- Rust也不建议以`-rs`或`_rs`为后缀来命名包名, 而且会强制性的将此后缀去掉

#### 语句与表达式
Rust 是一门基于表达式（expression-based）的语言.

Rust 的语法分成两大类: 语句 Statement 和表达式 Expression. 语句是指要执行的一些操作但不返回值的表达式, 表达式主要用于计算求值, 它们的区别是后面带不带分号.

语句又分为两种:
1. 声明语句(Declaration statement）

	用于声明各种语言项(Item)，包括声明变量、静态变量、常量 结构体、函数等，以及通过 extern和use引入包和模块等
1. 表达式语句(Expression statement)
	
	特指以分号结尾的表达式. 此类表达式求值结果将会被舍弃, 并总是返回`单元类型()`

rust使用`{}`表示复杂表达式, 比如:
```rust
    // 在块中可以使用函数语句, 最后一个步骤是表达式, 此表达式的结果值是整个表达式块所代表的值, 这种表达式块叫做函数体表达式.
    // 函数体表达式并不能等同于函数体, 它不能使用 return 关键字
    let y = {
        let x = 3;
        x + 1
    };
```

Rust编译器在解析代码的时候，如果碰到分号，就会继续往后面执行; 如果碰到语句，则执行语句; 如果碰到表达式，则会对表达式求值，如果分号后面什么都没有，就会补上单元值.

当遇到函数的时候，会将函数体的花括号识别为块表达式（Block Expression ）. 块表达式是由一对花括号和一系列表达式组成的, 它总是返回块中最后一个表达式的值.

#### 变量和绑定
> stack上分配的数据必须是已知固定大小的, heap上是编译时未知或运行时大小可变的数据.

let创建的变量称为绑定(Binding), 它表明了标识符（ Identifier) 和值（ Value ）之间建立了一种关联关.

> 使用 let 关键字创建变量并绑定一个值是一个语句, 因为语句不返回值， 因此，不能把 let 语句赋值给另一个变量. 在C语言或Ruby语言中的赋值语句会返回所赋的值, 因此`x = y = 6`是正确的, 它使得x和y变量同时拥有6这个值; 而rust不能这样写.

rust类型没有“默认构造函数”，变量没有“默认值” .
Rust 里面的下划线是一个特殊 的标识符，在编译器内部它是被特殊处理的.

Rust的表达式一般可以分为位置表达式(Place Expression ）和 值表达式(ValueExpression). 在其他语言中, 一般叫作左值(Value, 因为它在赋值运算符的左边)和右值(RValue, 除左值外的值).

位置表达式就是表示内存位置的表达式, 分别有以下几类:
- 本地变量
- 静态变量
- 解引用(`*expr`)

    当使用`.`运算符时, 则不需要担心`*`, rust会帮你处理解引用.
- 数组索引(`expr[expr]`) 
- 字段引用（`expr.field`) 
- 位置表达式组合

通过位置表达式可对某个数据单元的内存进行读写. 值表达式一般只引用了某个存储单元地址中的数据, 它相当于数据值, 只能进行读操作.

let关键字声明位置表达式默认不可变, 即**不可变绑定**, 只能对对应的存储单元进行读取. 引用默认情况下也是不可变的.
let mut声明的**可变绑定**可以对相应的存储单元进行写入.

```rust
fn main() {
    let (mut x, y) = (1, 2);
    x += 2;

    assert_eq!(x, 3);
    assert_eq!(y, 2);
}
```

> mut在模式匹配中是修饰变量绑定, `&mut`是表示引用, mut的意义完全不同.

> 在 Rust 中，一般把声明的局部变量并初始化的语句称为`变量绑定`, 强调的是“绑定”的含义，与 C/C＋＋ 中的“赋值初始化”语句有所区别: Rust中，每个变量必须被合理初始化之后才能被使用, 使用未初始化变量这样的错误，在Rust 中是不可能出现的 （利用 unsafe 做 hack 除外）. 编译器做一个执行路径的静态分析，确保变量在使用前一定被初始化.

> 类型一定是跟在冒号`:`后面, 这样语法歧义更少，语法分析器更容易编写.

> const(常量)可以在任意作用域进行定义，而定义的常量贯穿整个程序的生命周期. 在编译的时候，常量就能确定其值, 编译器不一定会给const分配内存空间, 同时编译器**会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址**；对于变量出现重复的定义(绑定)会发生变量遮盖，而对于常量则是不允许出现重复的定义的.

> 全局(static)变量和常量类似，但static变量不会被内联，在整个程序中，全局变量只有一个实例, **必须是编译期可确定的常量**，也就是说所有的引用都会指向一个**相同的地址**. 因为全局变量可变，就会出被多个线程同时访问的情况，因而引发内存不安全的问题，所以对于全局可变(static mut)变量的访问和修改代码就必须在unsafe块中进行定义. 声明static变量时禁止调用普通函数, 但const fn可以, 因为const fn是编译时执行的.

> 任何需要 static mut 的地方，都可以用 AtomicXXX / Mutex / RwLock 来取代

在存储的数据比较大，需要引用地址或具有可变性的情况下使用静态变量. 否则，应该优先使用普通常量. 推荐使用lazy_static实现复杂的static变量初始化. lazy_static可以把定义全局静态变量延迟到运行时, 而非编译时.

lazy_static限制:
1. 使用 lazy_static 宏定义的全局静态变量如果有析构函数是不会被调用的, 因为是静态生命周期
1. lazy_static 宏中不能定义太多的全局静态变量，否则会引发线程恐慌. 这是因为在它调用了内部的宏, rust对宏的递归调用有调用次数限制, 可通过`#![recursion_limit="128"]`属性修改,默认值为 32.

> 赋值号左边的部分是一个“模式”，`let (mut a, mut b) = (1, 2);`是对 tuple 的模式解构; `let Point { x : ref a, y : ref b} = p;`是对结构体的模式解构, `ref`= `let a =  &p.a`

格式化输出
ref:
- [字符串操作 - 《Rust程序设计 - 17.4 格式化值》]()

打印操作由 std::fmt 里面所定义的一系列宏来处理，包括：
- format!：将格式化文本写到字符串（String）
- print!：与 format! 类似，但将文本输出到控制台（io::stdout）
- println!: 与 print! 类似，但输出结果追加一个换行符
- eprint!：与 format! 类似，但将文本输出到标准错误（io::stderr）
- eprintln!：与 eprint! 类似，但输出结果追加一个换行符

[println! format](https://doc.rust-lang.org/std/fmt/#formatting-traits):
- nothing(即默认)⇒ Display : `println!("{}",2)`
- ? ⇒ Debug : `println!("{:?}",2)`
- x? ⇒ Debug with lower-case hexadecimal integers
- X? ⇒ Debug with upper-case hexadecimal integers
- :#? ⇒ 带换行和缩进的Debug打印 : `println!("{:#?}",("t1","t2"))` 
- o ⇒ Octal : `println!("{:o}",2)`
- x ⇒ LowerHex : `println!("{:x}",12)`
- X ⇒ UpperHex : `println!("{:X}",12)`/`println!("{:X}", '居' as u32)`(打印unicode码点)
- p ⇒ Pointer : `println!("{:p}",&2)`
- b ⇒ Binary :  : `println!("{:b}",2)`
- e ⇒ LowerExp : `println!("{:e}",2)`
- E ⇒ UpperExp : `println!("{:E}",2)`
- u ⇒ unicode字符: `println!("\u{5C45}")`
- 命名参数       : `println!("{a} {b} {b}",a = "x", b="y")`

> 想把 a 输出两遍可用: `println!("a is {0}, a again is {0}", a);`/`println!("a is {a}, a again is {a}", a=1);`

> `println!("{:-^30}", title);`,`-`是填充字符, `<`表示变量在填充字符左边, `>`表示在填充字符右边, `^`表示在填充字符中间

## 所有权(ownership)
所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全. **所有权的存在就是为了管理堆数据**.

所有运行的程序都必须管理其使用计算机内存的方式. 一些语言中具有垃圾回收机制(go, java等)，在程序运行时不断地寻找不再使用的内存；在另一些语言中(c, c++等)，开发者必须亲自分配和释放内存. Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在**编译时**会根据一系列的规则进行检查, 在运行时，所有权系统的任何功能都不会减慢程序.

所有权本质上就是在语言层面禁止了同一个可变数据会有多个变量引用的情况, 一旦作为参数传递了, 就会发生所有权的移动（Move）或借用（Borrow）, 即从根本上杜绝了并发情景下的数据共享冲突.

> 变量范围是变量的一个属性, 其代表变量的可行域, 默认从声明变量开始有效直到变量所在域结束.

> Rust 之所以没有明示释放变量的步骤是因为在变量范围结束的时候, 其编译器自动添加了调用释放资源函数的步骤.

> rust的栈中的所有数据都必须占用已知且固定的大小, 在编译时大小未知或大小可能变化的数据会分配到堆上.

Rust中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者.

在进行赋值操作时，对于可以实现Copy的复制语义类型，所有权并未改变. 对于复合类型来说，是复制还是移动，取决于其成员的类型.

所有权的规则:
- Rust 中的每一个值都有一个被称为其所有者（owner）的变量
- 值在任一时刻有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃

    内存在拥有它的变量离开作用域后就被自动释放(调用`drop`方法)

    在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）, 即本质是将资源的生命周期和对象的生命周期绑定.

    > 在推断所有权规则时，作用域是一个非常重要的属性, 它也会被用来推断借用和生命周期

这三条规则很好理解, 核心就是保证单一所有权. 其中第二条规则讲的所有权转移是 Move 语义, Rust 从 C++ 那里学习和借鉴了这个概念.

通过单一所有权模式, Rust解决了堆内存过于灵活、不容易安全高效地释放的问题, 既避免了手工释放内存带来的巨大心智负担和潜在的错误; 又避免了全局引入追踪式 GC 或者 ARC 这样的额外机制带来的效率问题.

rust 内存回收策略：内存在拥有它的变量离开作用域后就被自动释放.

所有权规则解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势.

```rust
#[derive(Debug)]
struct Foo(u32);

fn main() {
    let foo = Foo(2048);
    let bar = foo;
    println!("Foo is {:?}", foo); // 报错: foo已被move给bar
    println!("Bar is {:?}", bar);
}
```

```rust
fn main() {
    let foo = 4623;
    let bar = foo;
    println!("{:?} {:?}", foo, bar); // 正常
}
```

```rust
#[derive(Copy, Clone, Debug)]
struct Dummy;

fn main() {
    let a = Dummy;
    let b = a;
    println!("{}", a); // 正常, 因此Dummy有实现Copy
    println!("{}", b);
}
```

```rust
fn main() {
    let mut s = String::from("hello, ");

    let r1 = &mut s;
    r1.push_str("world");
    let r2 = &mut s;
    r2.push_str("!");
    
    println!("{}",r1); // 注释这行后或将r2改为r2不报错. 报错: 同生命周期内s存在多个可变引用
}

fn main() {
    // 报错, 从不可变对象借用为可变
    let s = String::from("hello, ");

    borrow_object(&mut s)
}

fn borrow_object(s: &mut String) {}

fn main() {
    let mut s = String::from("hello, ");

    // 正确, 从可变对象借用为不可变
    borrow_object(&s);
    
    s.push_str("world");
}

fn borrow_object(s: &String) {}

// 获得可变借用
fn add_hungary(country_name: &mut String) { // first we say that the function takes a mutable reference
    country_name.push_str("-Hungary"); // push_str() adds a &str to a String
    println!("Now it says: {}", country_name);
}

fn main() {
    let mut country = String::from("Austria");
    add_hungary(&mut country); // we also need to give it a mutable reference.
}

// ----
// 获得所有权, 并将country设为可变
fn adds_hungary(mut country: String) { // Here's how: adds_hungary takes the String and declares it mutable!
    country.push_str("-Hungary");
    println!("{}", country);
}

fn main() {
    let country = String::from("Austria"); // country is not mutable, but we are going to print Austria-Hungary. How?
    adds_hungary(country);
}
```

所有权的静态检查和动态检查逻辑:
- 静态检查, 靠编译器保证代码符合所有权规则
- 动态检查, 通过 Box::leak() 让堆内存拥有不受限的生命周期, 然后在运行过程中, 通过对引用计数的检查, 保证这样的堆内存最终会得到释放.

所有权也让代码变得复杂, 如果要**避免所有权转移之后不能访问**的情况, 一般需要手动复制, 编写麻烦且效率不高, 因此rust提供了两种解决方法:
1. Rust 提供了 Copy 语义. 如果一个数据结构实现了 Copy trait，那么它就会使用 Copy 语义. 这样, **在赋值或者传参**时, 值会自动**按位拷贝**（浅拷贝）.

    Copy: 在赋值或者传参时, 值会自动按位拷贝. 这意味着该值可以使用任意次数，每个值都是全新的.

    等同于go的值传递.

    > Rust 的只读引用实现了 Copy trait

    > Clone是Copy的父trait.

    > 默认情况下, C++具有复制语义. 后来的C++ 11 版本提供了对移动语义的支持.

1. 不使用 Copy 语义时, 可以`借用`数据

    > 在 Rust 中, "借用"和"引用"是一个概念, 只不过在其他语言中引用的意义和 Rust 不同, Rust使用"借用", 便于区分

> Rust 没有传引用的概念, Rust 所有的参数传递都是传值, 和go相同.

变量与数据交互的方式:
1. move

    > 当以转移所有权的方式给函数传参时，称其为传值（by value）。如果传给函数的是对值的引用，则称其为传引用（by reference）.

    在 Rust 中，对多数类型而言，给变量赋值、给函数传值或从函数返回值这样的操作不会复制值, 而是转移（move）值.

    移动: 通过变量访问或重新分配给变量时移动到接收项的值表示移动语义. 由于Rust 的仿射类型系统，它默认会采用移动语义. 仿射类型系统的一个突出特点是值或资源只能使用一次，而 Rust 通过所有权规则展示此属性.

    默认情况下，所有类型都有“移动语义”，但是一旦一个类型实现了 `Copy'，它就会得到`复制语义`.

    设计选择: **Rust 永远也不会自动创建数据的 “深拷贝”. 因此，任何 自动 的复制可以被认为对运行时性能影响较小.**

    仅在栈中的基本数据类型的数据的"移动"方式是直接复制, 这不会花费更长的时间或更多的存储空间, "基本数据"类型有这些：

    - 所有整数类型: i32 、 u32 、 i64 等
    - 布尔类型 bool: true 或 false
    - 所有浮点类型: f32 和 f64
    - 字符类型 char
    - 仅包含以上类型数据的元组(Tuples)

    Rust会尽可能地降低程序的运行成本, 所以默认情况下, 长度较大的数据存放在堆中, 且采用移动的方式进行数据交互.

    > 在 match 表达式中，移动类型默认也会被移动.

    move可以理解为浅拷贝+使原所有者变量失效.
1. [Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html)

    克隆仅在需要复制的情况下使用, 毕竟复制数据会花费更多的时间.
    由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 clone 来解决所有权问题.

    Clone的返回类型是 Self，而且函数不可能返回非固定大小的值，所以 Clone 特型本身扩展了 Sized 特型。这样就具有了将实现的 Self 类型绑定为 Sized 的效果.

    克隆一个值通常涉及创建该值所拥有一切内容的副本及分配内存，因此 clone 无论在时间消耗还是内存占用方面都可能比较昂贵.

    clone主要针对heap上的数据.

    Clone 是深度拷贝，栈内存和堆内存一起拷贝

    > Clone的`clone_from()`价值: 某些情况下a已存在时, `a.clone_from(&b)`比`a = b.clone()`高效, 比如a带buffer且buffer足够大, 此时可避免内存分配

    > 在 clone 一个数据时只需要有已有数据的只读引用。但对 Rc<T> 这样在 clone() 时维护引用计数的数据结构，clone() 过程中会改变自己，所以要用 Cell<T> 这样提供内部可变性的结构来进行改变.

对 Rust 而言，一个值如果没有实现 Copy, 在赋值、传参以及函数返回时会被 Move. 其实 Copy 和 Move 在内部实现上, 都是浅层的按位做内存复制, 只不过 Copy 允许访问之前的变量, 而 Move 不允许.

Copy是一种自动化特征，大多数堆栈上的数据类型都自动实现了它. 它通常用于数据完全在栈上的变量的复制, 比如基元类型和不可变引用(&T); 否则Copy开销很大, 因为它需要从堆中复制数据. Copy 特征复制类型的方式与 C 语言中的 memcpy 函数类似，后者用于按位复制值。默认情况下不会为自定义类型实现 Copy 特征，因为 Rust 希望显式指定复制操作，并且要求开发人员必须选择实现该特征. 没有实现 Copy 特征的类型包括`Vec<T>、 String 和可变引用`等.

> 任何实现 Drop 特型的类型不能是 Copy。Rust 认为如果一个类型需要特殊的清理代码，那就一定需要特殊的复制代码，因此不能是 Copy

> 有一条经验规则，就是任何在值被清除后需要特殊处理的类型都不能是 Copy 类型。比如，Vec 需要释放其元素， File 需要关闭其文件勾柄，而 MutexGuard 需要解锁其互斥量。

> 用户定义的类型默认属于非 Copy 类型。如果自定义结构体的所有字段本身都是 Copy 类型，那可以在定义上方添加 #[derive(Copy, Clone)] 属性把这个类型标注成 Copy 类型;对于并非所有字段都是 Copy 类型的结构体，就算加这个属性也不管用, 编译器会报错.

Clone 特征用于显式复制, 并附带 clone 方法， 类型可以实现该方法以获取自身的副本.

Clone 与 Copy 的不同之处在于, 其中的赋值操作时Copy是隐式复制值, 要复制 Clone值，就必须显式调用 clone 方法. clone 方法是一种更通用的复制机制, Copy 是它的一个
特例，即总是按位复制.

String 和 Vec 这类元素很难进行复制, 只实现了 Clone 特征. 智能指针类型也实现了 Clone 特征, 它只是在指向堆上相同数据的同时复制指针和额外的元数据（例如引用
计数）.

涉及函数入参的所有权机制:
```rust
fn main() {
    let s = String::from("hello");
    // s 被声明有效

    takes_ownership(s);
    // s 的值被当作参数传入函数
    // 所以可以当作 s 已经被移动，从这里开始已经无效

    let x = 5;
    // x 被声明有效

    makes_copy(x);
    // x 的值被当作参数传入函数
    // 但 x 是基本类型，依然有效
    // 在这里依然可以使用 x 却不能使用 s

} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放


fn takes_ownership(some_string: String) {
    // 一个 String 参数 some_string 传入，有效
    println!("{}", some_string);
} // 函数结束, 参数 some_string 在这里释放

fn makes_copy(some_integer: i32) {
    // 一个 i32 参数 some_integer 传入，有效
    println!("{}", some_integer);
} // 函数结束, 参数 some_integer 是基本类型, 无需释放
```

涉及函数返回值的所有权机制:
```rust
fn main() {
    let s1 = gives_ownership();
    // gives_ownership 移动它的返回值到 s1

    let s2 = String::from("hello");
    // s2 被声明有效

    let s3 = takes_and_gives_back(s2);
    // s2 被当作参数移动, s3 获得返回值所有权
} // s3 无效被释放, s2 被移动, s1 无效被释放.

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    // some_string 被声明有效

    return some_string;
    // some_string 被当作返回值移动出函数
}

fn takes_and_gives_back(a_string: String) -> String {
    // a_string 被声明有效

    a_string  // a_string 被当作返回值移出函数
}
```

Rust 有一个叫做 Copy trait(类似深拷贝)的特殊注解，可以用在类似整型这样的**存储在栈上的类型上. 如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用**. Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait.

作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的. 默认支持 Copy 的类型有：
- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型, char
- 元组，当且仅当其包含的类型也都是 Copy 的时候. 比如 (i32, i32) 是 Copy 的，但 (i32, String) 就不是.

将值传递给函数在语义上与给变量赋值相似: 向函数传递值可能会移动或者复制，就像赋值语句一样. 返回值也可以转移所有权.

变量的所有权总是遵循相同的模式：将值赋给另一个变量时**移动**它 . 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有.

引用(Reference)是 Rust 提供的一种指针语义. 引用是基于指针的实现，它与指针的区别是，指针保存的是其指向内存的地址, 而引用可以看作某块内存的别名, 使用它需要满足编译器的各种安全检查规则.

引用(`&`)语法可创建一个 指向 值 的引用，但是**并不拥有它**, **因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃**. 实质上"引用"是变量的间接访问方式, 且"引用"并没有在栈中复制变量的值. 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权.

引用的生命周期不能超出值的生命周期.

引用举例:
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = &s1; // s2是s1的引用`&String`
    s2.push_str("oob"); // 错误，禁止修改租借的值
    let s3 = s1; //  报错. s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借
    println!("{}", s2);
}

// 改为:
fn main() {
    let s1 = String::from("hello");
    let mut s2 = &s1;
    let s3 = s1;
    s2 = &s3; // 使用前重新从 s3 租借所有权
    println!("{}", s2);
}

fn main() {
    let mut s1 = String::from("run");
    // s1 是可变的

    let s2 = &mut s1;
    // s2 是可变的引用

    s2.push_str("oob");
    println!("{}", s2);
}
```

可变引用与不可变引用相比除了权限不同以外, **可变引用不允许多重引用**, 但不可变引用可以.

Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生. 由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用.

垂悬引用（Dangling References）: 没有实际指向一个真正能访问的数据的指针（注意: 不一定是空指针，还有可能是已经释放的资源）, 比如:
```rust
fn main() {
    // 伴随着 dangle 函数的结束，其局部变量的值本身没有被当作返回值, 被释放了, 但它的引用却被返回, 这个引用所指向的值已经不能确定的存在, 因此会报错
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

**获取引用作为函数参数称为`借用(borrowing)`**.

借用所有权会让所有者受到如下限制:
1. 在不可变借用期间，所有者不能修改资源，并且也不能再进行可变借用
1. 在可变借用期间，所有者不能访问资源，并且也不能再出借所有权

引用在离开作用域之时, 就是其归还所有权之时.

为了保证内存安全，借用必须遵循以下三个规则
- 规则1 ：借用的生命周期不能长于出借方的生命周期
- 规则2 ：可变借用（引用) 不能有别名, 因为可变借有独占性
- 规则3 : 不可变借用（引用)不能再次出借为可变借用

规则1是为了防止出现悬垂指针. 规则2和3可以总结为一条核心的原则: 共享不可变, 可变不共享. rust 编译器会做严格的借用检查, 违反以上规则的行为均无法正常通过编译.

不可变借用可以被出借多次, 因为它不能修改内存数据, 因此它也被称为共享借用. 可变借用只能出借一次，否则，难以预料数据何时何地会被修改.

Rust 的借用检查带来了如下好处：
1. 不可变借用保证了没有任何指针可以修改值的内存，便于将值存储在寄存器中
1. 可变借用保证了在写的时候没有任何指针可以读取值的内存，避免了脏读
1. 不可变借用保证了内存不会在读取之后被写入新数据
1. 保证了不可变借用和可变借用不相互依赖, 从而可以对读写操作进行自由移动和排序

解引用操作会获得所有权.

引用默认不允许修改引用的值, 允许可变引用(`&mut`), 但可变引用有一个很大的限制：**在特定作用域中的特定数据有且只有一个可变引用. 这个限制的好处是 Rust 可以在编译时就避免数据竞争.数据竞争（data race）类似于竞态条件**，它可由这三个行为造成：
- 两个或更多指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

引用规则:
1. 在任意给定时间(即作用域)内，要么只能有一个可变引用，要么只能有多个不可变引用. 即任意时刻不能在拥有不可变引用的同时拥有该变量的可变引用.

    对一个变量, 在其作用域内:
    1. 至多1个可变引用
    2. 可变引用与不可变引用不能共存
    3. 只读变量不能有可变引用

    多个可变:
    ```rust
    // 无法编译
    fn main() {
        let mut data = vec![1, 2, 3];

        for item in data.iter_mut() {
            data.push(*item + 1);
        }
    }
    ```

    ```python
    if __name__ == "__main__":
        data = [1, 2, 3]
        for item in data:
            data.append(item + 1)
            print(item)
        # unreachable code
        print(data)
    ```

    同时有一个可变引用和若干个只读引用:
    ```rust
    // 无法编译
    fn main() {
        let mut data = vec![1, 2, 3];
        let data1 = vec![&data[0]]; // data扩容会导致`&data[0]`无效
        println!("data[0]: {:p}", &data[0]);

        for i in 0..100 {
            data.push(i);
        }

        println!("data[0]: {:p}", &data[0]);
        println!("boxed: {:p}", &data1);
    }
    ```

2. 引用必须总是有效的.

除了引用, 另一个没有所有权的数据类型是 slice. slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合. 字符串 slice（string slice）是 String 中一部分值的引用. 字符串字面值就是 slice.

> 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.

使用可变借用的前提是：出借所有权的绑定变量必须是一个可变绑定.

在所有权系统中，引用&x也可以称为x的借用（Borrowing）. 通过&操作符来完成所有权租借。所以引用并不会造成绑定变量所有权的转移.

引用在离开作用域之时，就是其归还所有权之时:
- 不可变借用（引用）不能再次出借为可变借用
- 不可变借用可以被出借多次
- 可变借用只能出借一次
- 不可变借用和可变借用不能同时存在，针对同一个绑定而言
- 借用的生命周期不能长于出借方的生命周期

核心原则：**共享不可变，可变不共享**

因为解引用操作会获得所有权，所以在需要对移动语义类型（如&String）进行解引用时需要特别注意.

> rust 有一个叫 自动引用和解引用（automatic referencing and dereferencing）的功能, 这与golang相同.

#### 所有权与引用
Rust 用 Copy trait 来区分值语义和引用语义. 与此同时 Rust 也引入了复制(Copy) 吾义和移动(Move) 语义. 复制语义对应值语义, 移动语义对应引用语义. 这样划分是因为引入了所有权机制, 在所有权机制下同时保证内存安全和性能.

所有权转移: 当位置表达式出现在值上下文中, 表示将会把内存地址转移给另一个位置表达式. 简单来说就是一个值的所有权被转移给另外一个变量绑定的过程.

**在语义上, 每个变量绑定实际上都拥有该存储单元的所有权, 这种转移内存地址的行为就是所有权(ownership)的转移, 在rust中称为移动(move)语义, 那种不转移的情况实际上是一种复制(copy)语义. **rust没有gc, 以完全依靠所有权来进行内存管理.

Rust的所有权在类型系统理论中称为仿射类型(affine type）, 它属于类型理论中的子结构类型系统(Substructural Type System)的概念. 子结构类型系统又是子结构逻辑(Substructural Logic ）在类型系统中的应用. 而子结构逻辑属于证明理论里的推理规则.

所有者拥有以下3种权限:
1. 控制资源（不仅仅是内存）的释放
1. 出借所有权，包括不可变（共 ）的和可变（独占）的
1. 转移所有权

枚举体和结构体是类似的, 当成员均为复制语义类型时, 不会自动实现 Copy. 而对于元组类型来说, 其本身实现了 Copy, 如果元素均为复制语义类型, 则默认是按位复制的, 否则会执行移动语义.

数组和 Option 类型与元组类型都遵循这样的规则: 如果元素都是复制语义类型，也就是都实现了 Copy, 那么它们就可以接位复制, 否则就转移所有权.

rust提供引用操作符(`&`), 此时不转移所有权, 可直接获取表达式的存储单元地址(即内存位置), 可通过该地址对存储进行读取. 因此引用已被称为借用.

模式匹配可能导致变量所有权转移, 使用ref可避免该情况. ref是模式的一部分, 它只能出现在赋值操作符的左边. `&`是借用运算符, 是表达式的一部分, 只能出现在赋值操作符的右边.

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它. 当持有堆中数据值的变量离开作用域时, 其值将通过 drop 被清理掉, 除非数据被移动为另一个变量所有.

drop-flag：在函数调用栈中为离开作用域的变量自动插入布尔标记，标注是否调用析构函数，这样，在运行时就可以根据编译期做的标记来调用析构函数.

实现了Copy的类型，是没有析构函数的. 因为实现了Copy的类型会复制，其生命周期不受析构函数的影响.

#### 函数和闭包
和主流语言一样, main函数代表程序的入口.

函数是对代码中重复行为的抽象。在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分.

函数是通过关键字 fn 定义的.

函数传参和返回都可能发生移动或复制.

> 函数参数支持模式匹配, 传参等价于一个隐式的let绑定, 因此可将调用者的不可变入参重新声明成可变绑定, 此时通常发生所有权的转移, 不建议这么做, 推荐使用引用.

> 通常函数定义时不允许直接使用语言中的保留字和关键字等作为函数名. 但是在Rust 2018 版本中, 可通过将原生标识操作符r#(Raw Identifier)作为前缀，即可使用关键字为函数命名, 该语法一般用于 FFI中, 用于避免C函数名和 Rust 的关键字或保留字重名而引起冲突.

高阶函数是指以函数作为参数或返回值的函数, 它也是函数式编程语言最基础的特性, Rust支持高阶函数. 实现这功能的基础在于 Rust 支持类似 C/C++ 中的函数指针, 其值是函数的地址.

rust中函数是一等公民, 其自身可作为函数的参数和返回值使用. 一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包

const 函数是纯函数，必须是可重现的。这意味着它们不能将可变参数带入任何类型，也不能包含动态的操作，例如堆分配.

闭包(Closure)通常是指词法闭包, 是一个持有外部环境变量的函数. 外部环境是指闭包定义时所在的词法作用域. 外部环境变量, 在函数式编程范式中也被称为 自由变量，是指
并不是在闭包内定义的变量. 将自由变量和自身绑定的函数就是闭包.

> 其实在 Rust 中，闭包是一种语法糖.

> rust闭包早期实现是装箱(Boxed)闭包, 该实现使llvm难以对其进行内联和优化. 当前实现是非装箱(Unboxed)闭包.

闭包即匿名函数, 闭包有以下几个特点:
- 可以像函数一样被调用
- 可以捕获上下文环境中的自由变量
- 可以自动推断输入和返回的类型

函数是对代码中重复行为的抽象。在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分.

闭包与函数的区别:
1. 延迟执行: 闭包只在调用时执行
1. 捕获环境变量: 闭包可捕获外部变量, 而函数不可以.

闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

闭包对于环境变量来说有以下三种捕获方式:
1. 对于复制语义类型 ，以不可变引用`&T`来捕获
1. 对于移动语义类型 执行移动语义`Move`转移所有权来捕获
1. 对于可变绑定，如果在闭包中包含对其进行修改的操作, 则以可变引用`&mut`来捕获

Rust 中闭包实际上就是由一个匿名结构体和 trait 来组合实现的.

```rust
// 一般情况下, 闭包默认会按引用捕获变量, 如果将此闭包返回, 则引用也会跟着返回, 但这里随着函数调用结束, 本地变量i会被销毁, 随闭包返回的i的引用就变成了虚悬指针.
// 因此需要使用move来将被引用的变量的所有权转移到闭包中, 不再按引用捕获变量, 这样闭包才可以安全地返回.
pub fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    move |j| j * i
}
```

两个定义一模一样的闭包并不一定属于同种类型:
```rust
fn main(){
    let c1 = || {};
    let c2 = || {};
    let v = [c1, c2];
}
```

Rust 的闭包实现机制使得每个闭包表达式都是一个独立的类型, 因此上面代码可用trait对象来解决:
```rust
fn boxed_closure(c: &mut Vec<Box<Fn()>>){
    let s = "second";
    c.push(Box::new(|| println!("first")));
    c.push(Box::new(move || println!("{}", s)));
    c.push(Box::new(|| println!("third")));
}
fn main(){
    let mut c: Vec<Box<Fn()>> = vec![];
    boxed_closure(&mut c);
    for f in c {
        f(); // first / second / third
    }
}
```

#### 作用域与生命周期
变量绑定具有`时空`双重属性:
1. 空间属性是指标识符与内存空间进行了绑定
1. 时间属性是指绑定的时效性，也就是指它的生存周期

堆变量的生命周期不具备任意长短的灵活性, 因为堆上内存的生死存亡, 是跟栈上的所有者牢牢绑定. 而栈上内存的生命周期, 又跟栈的生命周期相关, 所以核心只需要关心调用栈的生命周期.

绑定的生存周期也被称为生命周期(lifetime), 是和词法作用域有关的. 绑定的析构顺序和声明顺序相反.

目前 rust 的生命周期是基于词法作用域的, 编译器能自动识别函数内部这些局部变量绑定的生命周期.

rust的作用域是静态作用域, 即词法作用域(lexical scope), 由一对花括号来开辟作用域, 该作用域在词法分析阶段就已确定, 不会动态改变.

变量绑定的生命周期(lifetime): 从使用let声明创建变量绑定开始, 到超出词法作用域的范围时结束.


let 绑定会创建新的词法作用域， 如果有其它变量作为右值进行赋值操作, 也就是绑定操作, 那么该变量因为进入了 let创建的词法作用域, 所以要么转移所有权, 要么按位复制, 这取决于该变量是复制语义还是移动语义的. 除了 let声明, 还有一些场景会创建新的词法作用域: `{}`, match匹配, 循环语句, if let和while let, 函数, 闭包.

Rust允许在同一个代码块中声明同样名字的变量的做法被称为变量遮蔽(variable shadow), **个人强烈不推荐使用**. 隐藏区别于mut: 隐藏会创建新变量, 同时可改变其类型.

> 变量遮蔽不会导致其生命周期提取结束, 而是超出词法作用域的范围时结束.

#### CTFE
rust编译器像C++或D语言一些, 支持编译时函数执行(compile-time function execution, CTFE, from rust 2018).

rust中固定长度的数组必须在编译期就知道长度, 否知会报错, 这就用了CTFE的能力.

`const fn`强制编译器在编译期执行函数, 其中const一般用于定义全局常量.

除了 onst fn 官方还在实现 const generics 特性.

rust编译器目前可以支持的常量表达式有字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等.

# base
## 文档
`cargo doc --no-deps --open`, `--no-deps`是告诉cargo忽略生成依赖项的文档.

> 可以将 cargo doc 与 cargo watch 搭配使用, 以获得无缝编写文档的体验，并在生成的页面上获得对项目中任何文档更改的实时反馈.

> 通过cargo-travis可在在 GitHub 项目的 gh-pages 分支页面上托管项目文档

## 代码
rust代码使用`.rs`扩展名, 且必须是utf-8编码.

注释由rustdoc解析, 支持:
- 元素级：这些注释适用于模块中的元素, 例如结构体、枚举声明、函数及特征常量等. 它们应该出现在元素的上方. 对于单行注释, 它们以`//`开头, 而对于多行
注释, 则以`/*`开头，以`*/`结尾, 但它也可用在代码中间, 比如`let some_number/*: i16*/ = 100;`
- 模块级：这些是出现在根层级的注释, 例如 main.rs、 lib.rs, 以及其他任意模块, 可使用`//!`表示单行注释的开始, 使用`/*!`表示多行注释的开始, 并将`*/`
作为结尾标记. 它们适用于包和模块.

> `///`=`#[doc]`, `//!`=`#![doc]`

这些注释会被转成文档属性`#[doc(key=value)]`.

常见文档属性:
- #![doc(html_logo_url = "image url")：用于在文档页面的左上角添加徽标（ logo）
- #![doc(html_root_url = "https://docs.rs/slotmap/0.2.1")]：用于设置文档页面的统一资源定位器（ Uniform Resource Locator， URL）
- #![doc(html_playground_url = "https://play.rust-lang.org/")]： 用于在文档中的代码示例附近放置一个“ Run”按钮，以便能够通过在线 Rust 工作台运行它
元素级属性
- #[doc(hidden)]：假定你已经为公共函数 foo 编写了文档作为自己的注释，但是不希望该函数的使用者查看这些文档，那么可以使用此属性告知 rustdoc 忽略为 foo 生
成文档
- #[doc(include)]：用于引用来自其他文件的文档。如果文档很长，这有助于你将文档和代码分开
- #[doc(inline)]: 用于内联文档, 而不是链接到一个单独的页面
- #[doc(no_inline)]: 用于防止链接到单独的页面或其它地方

Rust 允许在文档注释中使用`'`来嵌入代码:
```rust
// doctest_demo/src/lib.rs

//! This crate provides functionality for adding things
//!
//! # Examples
//! ```
//! use doctest_demo::sum;
//!
//! let work_a = 4;
//! let work_b = 34;
//! let total_work = sum(work_a, work_b);
//! ```

/// Sum two arguments
///
/// # Examples
///
/// ```

/// assert_eq!(doctest_demo::sum(1, 1), 2);
/// ```
pub fn sum(a: i8, b: i8) -> i8 {
a + b
}
```

## 语句/表达式
> Rust 中一切皆表达式，当某个地方需要一个表达式，但实际却是一个语句时，编译器会自动补上`单元值()`，这算是一个特殊的表达式.

Rust 程序里, 表达式（ Expressio ）和语句（ Statement ）是完成流程控制、计算求值的主要工具. 在Rust 里, 表达式可以是语句的一部分，反过来，语句也可以是表达式的一部分. 一个表达式总是会产生 个值，因此它必然有类型; 语句不产生值，它的类型永远是`()`. 如果把一个表达式加上分号，那么它就变成了一个语句；如果把语句放到一个语句块中包起来, 那么它就可以被当成一个表达式使用.

rust中语句块也可以是表达式的一部分. 语句和表达式的区分是后者不带`;`. 如果带了分号, 意味着这是一条语句，它的类型是`()`; 如果不带分号，它的类型就是表达式的类型.

Rust 中的表达式语法具有非常好的“一致性”，每种表达式都可以嵌入到另一种表达式中，组成更强大的表达式.

Rust 表达式包括字面量表达式、方法调用表达式、数组表达式、索引表达式、单目运算符表达式、双目运算符表达式等:
- 运算表达式

	比较运算符的两边必须是同类型的, 并满足 PartialEq 约束.

	**Rust里面的运算符优先级与C语言里面的运算符优先级设置是不一样的，有些细微的差别. 建议: 如果碰到复杂一点的表达式, 尽量用小括号明确表达计算顺序, 避免依赖语言默认的运算符优先级**.
- 赋值表达式

	Rust规定, 赋值表达式的类型为`unit`即`()`, 以避免像C语言那样的连续赋值, 或者误将`==`写成`=`

	Rust 不支持`++`,`--`运算符，请使用`+=1`,`-=1`替代

	在 rust 中没有必要专门设计像 C/C＋＋ 那样的三元运算符`?:`, 因为通过现有的设计可以轻松实现同样的功能, 且可读性更佳.

Rust 表达式又可以分为‘左值’ （lvalue ）和‘右值’（rvalue)两类. 所谓左值是这个表达式可以表达一个内存地址，它们可以放到赋值运算符左边使用, 其他的都是右值.

Rust 对所有类型（包括结构体）的命名有一个约定，即每个单词的首字母要大写，比如GrayscaleMap，称为驼峰拼写法（CamelCase）。字段和方法的名字要小写，单词间以下划
线分隔，称为蛇形拼写法（snake_case）.

## 变量, 函数和数据结构
变量 = 全局变量 + 局部变量
全局变量 = 常量 + 静态变量

全局值只能在初始化时声明非动态的类型，并且在编译期，它在堆栈上的大小是已知的。但 lazy_static!宏，可用于初始化任何能够从程序
中的任何位置全局访问的动态类型。

使用 lazy_static!宏声明的元素需要实现 Sync 特征。这意味着如果某个静态值可变，那么必须使用诸如 Mutex 或 RwLock 这样的多线程类型，而不是 RefCell.

Rust 引用永远不为空. 没有跟 C 的 NULL 或 C++ 的 nullptr 对应的东西存在。引用没有默认的初始值（无论什么类型的变量，在其初始化之前都不能使用）。而且， Rust（在 unsafe代码外部）不会将整数转换为引用，因此不能把 0 转换成引用.

- 变量

	- 不可变: `let x:T;`
	- 可变: `let mut x:T;`, 当声明为可变变量时, x的内容可被修改, 且允许可变引用.

		```rust
		let (mut a, mut b) = (1, 2); 
		let Point { x : ref a, y : ref b} = p;
		let mut v:Vec<u8> = Vec::new();
		```

	实际上, let 语句引入了一个模式解构, 不能把 let mut 视为一个组合, 而应该将 `mut x` 视为一个组合.

	Rust中，一般把声明的局部变量并初始化的语句称为“变量绑定”，强调的是“绑定”的含义，与 C/C＋＋ 中的“赋值初始化”语句有所区别.

	Rust 中，每个变量必须被合理初始化之后才能被使用, 使用未初始化变量这样的错误，在Rust 是不可能出现的 （利用 unsafe hack 除外）.

	Rust 允许在同一个代码块中声明同样名字的变量, 如果这样做, 后面声明的变量会将前面声明的变量“遮蔽”(Shadowing)起来. 实际上，传统编程语 C/C＋＋ 中也存在类似的功能，只不过它们只允许嵌套的代码块内部变量出现遮蔽, 而 Rust 在这方面放得稍微宽一点, 同一语句块内部声明的变量也可以发生遮蔽.

	rust变量声明的类型后置更方便类型推导.

	Rust 只允许**`局部变量/全局变量`实现类型推导，而函数签名等场景则是不允许, 这是特意这样设计的**:
	局部变量只有局部的影响; 全局变量必须当场初始化; 而函数名具有全局性影响. 函数签名如果使用自动挡类型推导, 可能导致某个调用的地方使用方式发生变化, 它的参数、返回值类型就发生了变化, 进而导致其他调用地方的编译错误，这是设计者不希望看到的情况.

	> 在编译器能够推导类型的情况下，变量类型一般可以省略，但常量（const）和静态变量（static）必须声明类型

	> Rust 的类型推断基于 Hindly-Milner 类型系统.


    在Rust中, ref和&都是用于引用传递的关键字，但它们在模式匹配中有些微的区别. 其中，ref用于将一个变量绑定为其值的引用，而&则直接将变量绑定为引用。 这意味着，当使用ref时，需要在变量名前加上ref关键字，而使用&则直接在变量名前加上&符号.
    ```rust
    fn main() {
        let c = '中';

        let r1 = &c;
        // fill the blank，dont change other code
        let ref r2 = c;

        assert_eq!(*r1, *r2);
    }
    ```

- 静态变量:  **需要明确指定常量的数据类型**

	- 不可变: `static X:T = T::new();`
	- 可变: `static mut X:T = T::new();`

	静态变量和常量一样全局可访问, 它也被编入可执行文件的数据段, 不会被内联且有固定内存地址. 静态变量可以被声明为可变.

	static 语句同样也是一个模式匹配, 与let 不同的是，用static 声明的变量的生命周期是整个程序，从启动到退出, static变量的生命周期永远是`'static`, 它占用的内存也不会在执行过程中被回收. 这也是 rust 中唯一的声明全局的方法.

	在使用静态变量时, 有一些限制, 可用lazy_static检查:
	1. 全局变量必须在声明的时候马上初始化

		**局部变量声明后只要在使用前初始化即可**.
	1. 全局变量的初始化必须是**编译期常量**，不能包括执行期才能确定的表达式、语句和函数调用
	1. 带有 mut 修饰的全局变量，在使用的时候必须使用 unsafe 关键字

		修改静态变量本质上不是线程安全的.

	rust禁止在声明static变量的时候调用普通函数, 或者利用语句块调用其他非const代码. const fn是允许的, 因为它是在编译期执行的.

	静态值通常与同步原语搭配使用，它们还用于实现全局锁定，以及与 C 程序库集成.

	> 名称要求使用大写，否则编译器会报 Warning

    在存储的数据比较大、需要引用地址或具有可变性的情况下使用静态变量；否则，应该优先使用普通常量.

- 常量: **不允许用mut修饰, 且需要明确指定常量的数据类型**.

	`const X:T = <value>;`

	常量是一个右值, 它不能被修改, 允许在任何作用域内声明. 常量编译后会被放在可执行文件的数据段, 全局可访问.

	通常，如果不需要依赖静态的单例属性及其预定义的内存位置，而只需要其具体值，那么应该更倾向于使用常量。它们允许编译器进行更好的优化，并且更易于使用.

	常量的初始化表达式也一定是一个**编译期常量**, 不能是运行期的.

	它与 static 大区别在于: 编译器并不一定会给const常量分配内存空间, 在编译过程中，它很可能会被**内联优化**. 因此, 千万不要用 hack 的方式, 通过 unsafe 代码去修改常量的值, 这么做是没有意义的. const也不具备类似 let 模式匹配功能.

	常量不支持重定义（遮蔽），这和变量是不同的.

	> 常量名一般使用大写字母，否则编译器会报 Warning.

	与静态变量的区别:
	1. 常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址
	1. 常量不可变，而静态变量和普通变量一样，默认不可变，但可以通过 mut 关键字定义为可变

	结构体、枚举和特征中的常量:
	```rust
	enum Item {
	    One,
	    Two,
	}
	struct Food {}

	impl Item {
	    const DEFAULT_COUNT: u32 = 34;
	}
	impl Food {
	    const FAVORITE_FOOD: &str = "Cake";
	}

	trait Circular {
	    const PI: f64 = 3.14;
	    fn area(&self) -> f64;
	}
	struct Circle {
	    rad: f64,
	}
	impl Circular for Circle {
	    fn area(&self) -> f64 {
	        Circle::PI * self.rad * self.rad
	    }
	}
	fn main() {
	    let c_one = Circle { rad: 4.2 };
	    println!("Area of circle one: {}", c_one.area());
	}
	```

- 函数: `func x(a1:T1,...)-> T{}`

	Rust 函数参数的类型和返回值的类型都必须显式定义, 如果没有返回值可以省略, 返回`unit即空元组`. 函数内部如果提前返回, 需要用 return 关键字, 否则最后一个表达式就是其返回值. 如果最后一个表达式后添加了`;`, 隐含其返回值为 unit.

	> Rust 函数名一般建议使用下划线风格（小写字母），即 蛇形命名法（snake_case），否则编译器会警告；而 Go 使用驼峰风格

	> 函数参数和变量一样，默认是不可变的，当需要可变参数时，可使用 mut 修饰.

	> 虽然 Rust 不支持多返回值，但因为有元组类型，因此返回元组相当于支持多返回值.

	> param是形参, arg是实参.

	rust函数使用fn标识, 其参数列表与let一样也可模式解构.

	在rust中， 如果函数没有返回值， 那么其返回值是unit即空元组`()`

	Rust 中, 每个函数具有自己单独的类型，但是这个类型可以自动转换成fn类型. 因此两个有同样的参数类型和同样的返回值类型的函数, 但它们是不同类型因而不能赋值给相同变量, 解决方案是让先转为通用的fn类型即可.

	Rust 支持一种特殊的发散函数（ Diverging functions ）, 它的返回类型是`!`. 发散类型的最大特点就是，它可以被转换为任意一个类型.

	Rust 中，有以下这些情况永远不会返回，它们的类型就是!:
	1. panic 以及基于它实现的各种函数/宏，比如`unimplemented!, unreachable!` ; 
	1. 死循环 `loop {}`
	1. 进程退出函数 `std::process::exit` 以及类似的 libc 中的 exec 一类函数

	在大部分主流操作系统上，一个进程开始执行的时候可以接受一系列的参数，退出的时候也可以返回一个错误码. 许多编程语言也因此为 main 函数设计了参数和返回值类型, rust和go不同, 传递参数和返回状态码都由单独的 API 来完成.

	Rust 设计组扩展了 main 函数的签名，使它变成了一个泛型函数，这个函数的返回类型可以是任何一个满足 Terminationtrait的类型，其中`（）,booL Result` 是满足这个约束的，它们都可以作为 main 函数的返回
类型.

	函数可以用 const 键字修饰，这样的函数可以在编译阶段被编译器执行，返回值也被视为编译期常量.

	Rust 函数参数的类型和返回值的类型都必须显式定义，如果没有返回值可以省略，返回 unit。函数内部如果提前返回，需要用 return 关键字，否则最后一个表达式就是其返回值。如果最后一个表达式后添加了; 分号，隐含其返回值为 unit.

	example:
	```rust
	fn pi() -> f64 {
	  3.1415926
	}

	fn not_pi() {
	  3.1415926;
	}

	fn main() {
	  let is_pi = pi();
	  let is_unit1 = not_pi();
	  let is_unit2 = {
	    pi();
	  };
	  
	  println!("is_pi: {:?}, is_unit1: {:?}, is_unit2: {:?}", is_pi, is_unit1, is_unit2);
	}
	```

- 元组: 它通过圆括号包含一组表达式构成

	如果元组中只包含一个元素, 应该在后面添加一个逗号, 以区分括号表达式和元组. 元组内部也可以一个元素都没有 这个类型单独有一个名字， unit （单元类型）.
	访问元组内部元素有两种方法, 一种是“模式匹配”（ pattern destructuring ）, 另外一种是“数字索引”.

	unit 类型是 Rust 最简单的类型之一， 是占用空间最小的类型之一. 空元组与空结构体 struct Foo 一样，都是占用0字节空间. `std::mem::size_of`函数可以计算一个类型所占用的内存空间. `std::mem::size_of_val`函数可以计算一个值所占用的内存空间.

	> 元组只允许用常量作为索引

- 结构体: `struct S{...}`, 不能使用自动类型推导功能, 必须显式指定.

	三种形式:
	1. 空结构体, 不占用任何空间, 比如`struct Marker;`
	1. 元组结构体(`tuple struct `), struct的每个成员都是匿名的, 可通过索引范围, 比如`struct Color(u8,u8,u8);`
	1. 普通结构体, struct的每个成员都有名字, 可通过名字访问

		```rust
		struct Person{
			name: String,
			age: u8,
		}
		```

	Rust 允许 struct 类型的初始化使用一种简化的写法: 如果有局部变量名字和成员变量名字恰好一致, 那么可以省略掉重复的冒号初始化.

	Rust 设计了一个语法糖，允许用一种简化的语法赋值使用另外一个 struct 的部分成员: `..expr`这样的语法, 只能放在初始化表达式中, 所有成员的最后最多只能有一个.

	`struct Fool;`/`struct Foo();`/`struct Foo{}`其实是同一个东西.

	tuple struct 一个特别有用的场景，那就是当它只包含一个元素的时候，就是所谓的newtype idiom. 因为它实际上让我们非常方便地在一个类型的基础上创建了一个新的类型.

	`type CharacterVec = Vec<char>;`通过关键字 type, 可创建一个新的类型名称，但是这个类型**不是全新的类型，而只是一个具体类型的别名**, 在编译器看来, 这个别名与原先的具体类型是一模一样. 而使用 tuple struct 做包装，则是**创造了一个全新的类型，它跟被包装的类型不能发生隐式类型转换**, 可以具有不同的方法, 满足不同的 trait, 完全按需而定.

	`Account { name, .. }`的`...`表示不关心Account除name外的其他字段; `Account { name, ..account1 }`的`account1`表示Account除name外的其他字段来自于account1实例, 该形式叫struct更新语法.

	struct如果可变, 那么实例中所有字段都是可变的, 不允许部分可变; struct如果不可变, 那么实例中所有字段都是不可变的.

	如果struct字段有引用, 那么需要生命周期保证只要struct实例是有效的, 里面的引用也会是有效的.

	struct调用方法时会自动引用或解引用即rust根据情况自动添加`&/&mut/*`来匹配其方法签名.

    **Rust 在内存中排布数据时, 会根据每个域的对齐（aligment）对数据进行重排, 使其内存大小和访问效率最好**. 但也可使用`#[repr]`宏, 强制让 Rust 编译器不做优化, 保持和 C 的行为一致, 以便Rust 代码可以方便地和 C 代码无缝交互.

- enum: `enum E{...}`

	enum即列举所有可能的值来定义的一种类型.

	> Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 代数数据类型（algebraic data types）最为相似

    > struct是用于将多个事物集合在一起, 而枚举则是用于将多个选择集合在一起

	两种形式:
	1. 枚举

		```rust
		enum Status {
			Ok = 0,
			Bad = 1,
			NotFound = 2,
			...
		}
		```

        没有`=N`时, Rust 给 enum 的每个arm提供了一个以 0 开头的数字, 供它自己使用; 上一个arm有`=N`, 但下一个没有时, Rust就会从前一个arm加1来赋值给当前arm.
	1 标签联合

		enum可承载多个不同的数据结构中的一种, 比如元组和struct.

		```rust
		// 由于它实在是太常用, 标准库将 Option 以及它的成员 Some,None 都加入到了Prelude, 它表示的含义是`要么存在、要么不存在`
		// Rust 在语言层面彻底不允许空值 null 的存在，但无奈null 可以高效地解决少量的问题，所以 Rust 引入了 Option 枚举类. Option 是 Rust 标准库中的枚举类，这个类用于填补 Rust 不支持 null 引用的空白.
		// 由于 Option 是 Rust 编译器默认引入的，在使用时可以省略 `Option::` 直接写 None 或者 Some().
		enum Option<T>{
			Some(T),
			None,
		}
		```

		> 很多语言默认不允许 null，但在语言层面支持 null 的出现（常在类型前面用`?`符号修饰）.

	如果说`tuple, struct, tuple struct`, 在Rust 中代表的是多个类型的“与”关系，那么 enum 类型在 Rust 中代表的就是多个类型的“或”关系.

	与C/C＋＋ 中的枚举相比, Rust 中的 enum 要强大得多，它可以为每个成员指定附属的类型信息. 它是一种更安全的类型, 可以被称为`tagged union`.

	rust enum内存布局:
	- tag: 	一个内部的整数`tag 标记`来描述当前变量属于哪种类型

		这个标记对用户是不可见的，通过恰当的语法设计，保证标记与类型始终是匹配的，以防止用户错误地使用内部数据.

		Rust 对某些枚举会直接优化掉标签字段. 比如上面的Option, 如果其类型 T 是`引用, Box 或其他智能指针类型, String, Vec<T>, HashMap<K,V>`等引用类型时, 因为引用类型的第一个字段是个指针, 而指针是不可能等于 0, 因此 Rust 就会省掉 Option<T> 的标签字段. 比如`Option<Box<i32>>` 在内存中只用 1 个机器字存储, 0 表示 None，非零表示 Some 封装的值
	- value: 足以容纳最大变体所有字段的内存来存储

	Rust 里面也支持 union 类型，这个类型与C语言中的 union 完全一致, 但在 Rust 里面，读取它内部的值被认为是 unsafe 行为, 一般情况下我们不使用这种类型. 它存在的主要目的是为了方便与C语言进行交互.

	```rust
	enum Number {
		Int(i32),
		Float(f32),
	}
	```
	等价于:
	```c
	struct Number {
		enum {Int, Float} tag;
		union {
			int32_t int_value;
			float float_value;
		} value;
	};
	```

	在实际中, enum 的内存布局未必是这个样子， 编译器有许多优化，可以保证语义正确的同时减少内存使用，并加快执行速度. 如果是在 FFI 下， 要保证 Rust 里面的 enum 的内存布局和C语言兼容的话, 可以给这个 enum 添加一个`#[repr(C, Int)]`属性标签.

	> rust的enum和struct其实是一种代数类型系统(Algebraic Data Type, ADT). enum内部的variant(用于区分enum里面的数据类型)的类型是函数类型. 因此Some可以当成函数作为参数传递给迭代器的`map()`. 枚举被称为求和类型, 是因为它可以容纳的值的范围基本上是其变体的取值范围的总和; 而结构体被称为乘积类型, 是因为它的取值区间是其每个字段取值区间的笛卡儿积.

Rust 里的合法标识符（包括变量名、函数名、 trait 名等） 必须由数字、字母、 下划线组成， 且不能以数字开头, 这个规定和许多现有的编程语言是一样.

rust的`_`和go类似, 是一个特殊的标识符，在编译器内部它是被特殊处理的, 其的含义是`忽略这个变量绑定, 后面不会再用到了`.

Rust 中, enum和struct均为内部成员创建了新的名字空间, 如果要访问内部成员，可
以使用`::`, 不同的 enum 中重名的元素也不会互相冲突.

rust复合类型支持递归定义, 但需要使用指针, 否则计算其大小时因递归而无解.


type alias:
```rust
type Carry = u8;
```

## 基本数据类型
ref:
- [字符串操作 - 《Rust程序设计 - 17.3 String与str》]()
- [rust原生类型](https://doc.rust-lang.org/std/index.html#primitives)

    - [**Types**](https://minstrel1977.gitee.io/rust-reference/types.html)

> primitive types (primitive = very basic)

基本数据类型也叫标量类型(scalar type), 表示只能存储单个值的类型.

rust有四种主要的标量类型:整型, 浮点, 布尔, 字符型.

- bool : true, false
- char : 单个字符, 大小为4B, 并代表了一个 Unicode 标量值（Unicode Scalar Value）, 等价于go的rune. char 由单引号包裹, 不同于字符串使用双引号.

	对于ASCII字符用`u8`表示.

    只有u8能转换成char, 其他无符号整数会报错.

    `.len()`会返回字符串的字节数, `.chars().count()`返回字符数
	
	> Unicode 标量值包含从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF 在内的值.

    > 如果要打印&str或char的字节, 则可以在字符串前写上`b`

    > go同样: 单个字符是rune
- 整数

	整数是一个没有小数部分的数字. 有符号整数范围: -2^(n-1)~2^(n-1)-1; 无符号范围: 0~2^n-1

	> 如果一个变量是有符号类型，那么它的最高位的那一个 bit 就是“符号位”，表示该数为正值还是负值; 如果个变量是无符号类型，那么它的最高位和其他位一样，表示该数的大小.

    大小  有符号     无符号
    8 bit   i8  u8
    16 bit  i16     u16
    32 bit  i32     u32
    64 bit  i64     u64
    128 bit     i128    u128
    Arch    isize   usize // arch 是由 CPU 构架决定的大小的整型类型, 与指针占用的空间大小一致, 在 x86 机器上为 32 位，在 x64 机器上为 64 位. 即isize和usize是自适应类型, 它们主要作为某些集合的索引.

    `<type>::MIN, <type>::MAX`可表示整数的最小/大值

    > Rust 要求数组索引必须是 usize 值.

    > 所有数值字面量支持任意位置添加`_`以方便阅读, 并且支持后缀表示类型, 比如`0x_ff_u8`

    > **整数自动推导时默认是i32, 即使在 64 位机器上也是 i32**. 因为 i32 在大多数情况下都足够表达整数值，并且它通常是最高效和常用的整数类型之一.

    > 字面量后面可以跟后缀，可代表该数字的具体类型，从而省略掉显示类型标记, **个人不推荐**.

    > rust不支持`++/--`

    > Rust 也继承了 C 的按位整数操作符 &、 |、 ^、 << 和 >>, 但对于按位非， Rust 使用 `!` 而不是 `~`

    > 与 C 不一样， Rust 中位操作的优先级高于比较操作。`x & BIT != 0` =>`(x & BIT)!= 0`

    > 当将任何数值转换成无符号整型 T 时，如果当前的数值不在新类型的范围内，可以对当前数值进行加值或减值操作( 增加或减少 T::MAX + 1 )，直到最新的值在新类型的范围内, 比如`assert_eq!(1000 as u8, 232)`

    > 从 Rust 1.45 开始，当浮点数超出目标整数的范围时，转化会直接取正整数取值范围的最大或最小值, 比如`assert_eq!(300.1_f32 as u8, 255)`, `assert_eq!(-100.1_f32 as u8, 0)`. 该浮点数转换有一点性能损耗, 如果对于某段代码有极致的性能要求，可以考虑使用`<f32>.to_int_unchecked::<u8>()`, 但是这些方法的结果可能会溢出并且返回一些无意义的值, 总之, 需小心使用.

    c中无符号算术运算永远不会overflow, 如果超出范围则自动舍弃高位数据; 有符号如果发生了overflow, 则是undefined behavior, 由编译器处理. 

    未定义行为有利于编译器做一些更激进的性能优化，但是这样的规定有可能导致在程序员不知情的某些极端场景下, 产生诡异 bug.

    Rust 的设计思路则倾向于预防 bug, 而不是无条件压榨效率, Rust 设计者希望能尽量减少`未定义行为`. 因此rust在debug模式下编译器自动插入溢出检查, 一旦溢出就panic; 在release下, 不检查整数溢出, 而是自动舍弃高位即二进制补码包装（two’s complement wrapping）的操作. rustc可使用`-C overflow-checks=no/yes`决定是否开启溢出检查. 以及可使用`#![allow(overflowing_literals)]`来忽略字面量的溢出.

    开发者可以调用标准库中的`checked_*, saturating_*, wrapping_*`系列函数更精细地自主控制整数溢出的行为:
	- `checked_*`系列函数返回的类型是`Option<_>`, 当出现溢出的时候，返回None
	- `saturating_`系列函数返回类型是整数, 如果溢出，则给出该类型可表示范围的`最大/最小`值
	- `wrapping_*`系列函数则是直接抛弃已经溢出的最高位, 将剩下的部分返回.

	在对安全性要求非常高的情况下, 强烈建议用户尽量使用这几个方法替代默认的算术运算符来做数学运算. rust 标准库中就大量使用了这几个方法. ，标准库还提供了一个叫作`std::num::Wrapping<T>`的类型, 它重载了基本的运算符， 可以被当成普通整数使用, 凡是被它包起来的整数, 任何时候出现溢出都是截断行为.

	```rust
	fn main() { 
	    let i = 10 0 i8; 
	    println! ("checked { : ?}", i.checked_add(i)); 
	    println! ("saturating {:?}", i.saturating_add(i)); 
	    println! ("wrapping {:?}", i. wrapping_add( i));
	}

	输出结果为:
	checked None
	saturating 127
	wrapping - 56
	```
- 浮点型

	rust提供基于IEEE-754-2008标准的浮点类型: f32/f64. `std::num::FpCategory`可表示浮点状态(`Nan/Infinite/Zero/Subnormal/Normal`), 默认是f64.

	标准库 std::f32和std::f64都提供了 IEEE 所需的特殊常量值, 比如INFINITY （无穷大）、 NEG INFINITY （负无穷大）、 NAN （非数字值）,MIN（最小有限值)和MAX(最大有限值）.

	> 非0数除以0是inf; 0除以0是Nan; `inf * 0.0`=Nan; `inf/inf`=NaN.

    部分方法:
    - .floor(): 给下一个最低的整数
    - .ceil(): 给下一个最高的整数
    - .round(): 四舍五入. 如果小数部分大于等于0.5，返回数值加1;如果小数部分小于0.5，返回相同数值
    - .trunc():只是把小数点号后的部分截掉

    ```rust
    fn main() {
        assert!(0.1+0.2==0.3); // 会panic
    }

    // 解决
    fn main() {
        println!("{}",0.1+0.2); // 0.30000000000000004, 因为浮点默认是f64
        assert!(0.1_f32+0.2_f32==0.3_f32); // 降低精度
        assert!((0.1_f64+ 0.2 - 0.3).abs() < 0.001); // 坐差
    }
    ```
- 数组

	数组Array是 Rust内建的原始集合类型, 数组的特点为:
	- 数组大小固定
	- 元素均为同类型
	- 默认不可变

	数组的类型签名为`[T;N]. T是一个泛型标记, 代表数组中元素的某个具体类; N代表数组的长度, 是一个编译时常量, 必须在**编译期已知**.

    `[1..5]` 表示左闭右开区间,`[1..=5]`则表示全闭区间

    `let list: [i32; 100] = [1; 100];`即成员100个且值都是1.

	数组是在栈（stack）而不是在堆（heap）上为数据分配内存空间. 对于原始固定长度数组，只有实现了 Copy trait 的类型才能作为其元素，也就是说，只有可以在栈上存放的元素才可以存放在该类型的数组中.

	未来rust 还将支持VLA (variable-length array ）数组即可变长度数组. 对于可变长度数组, 将会基于可以在栈上动态分配内存的函数来实现.

    ```rust
    fn main() {
        let names = [String::from("Sunfei"), "Sunface".to_string()];

        // `get` returns an Option<T>, it's safe to use
        let name0 = names.get(0).unwrap();

        // but indexing is not safe, 可能越界
        let _name1 = &names[1];
    }
    ```
- range

	Range是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列.

	range类型包括左闭右开和全闭两种区间.

	`(1..5)` 表示左闭右开区间,`（1..=5）`则表示全闭区间. 它们分别是 `std::ops::Range`和`std::ops::Rangelnclusive`的实例.

- slice: 签名是`&[T]`

	slice是对一个数组(包括固定大小数组和动态数组)的**引用**片段, 不持有所有权. 在底层，切片是一个胖指针, 代表一个指向数组起始位置的指针和数组长度. 如果用`[T]`类型表示连续序列，那么切片类型就是`&[T]`和`&mut[T]`.

    > 切片之于具体的数据结构，就像数据库中的视图之于表.

	```rust
	x..y // [x, y) 的数学含义

	..y // 等价于 0..y
	x.. // 等价于位置 x 到数据结束
	.. // 等价于位置 0 到结束
	```

    切片一般只出现在数据结构的定义中, 不能直接访问, 在使用中主要用以下形式:
    - `&[T]`: 表示一个只读的切片引用
    - `&mut [T]`: 表示一个可写的切片引用
    - `Box<[T]>`:一个在堆上分配的切片

            Box<[T]> 和 Vec<T> 有一点点差别：Vec<T> 有额外的 capacity，可以增长；而 Box<[T]> 一旦生成就固定下来，没有 capacity，也无法增长.

            Box<[T]> 和切片的引用 &[T] 也很类似：它们都是在栈上有一个包含长度的胖指针，指向存储数据的内存位置。区别是：Box<[T]> 只会指向堆，&[T] 指向的位置可以是栈也可以是堆；此外，Box<[T]> 对数据具有所有权，而 &[T] 只是一个借用

            目前可用的接口就只有一个从已有的 Vec<T> 中转换生成Box<[T]>: Vec<T> 可以通过 into_boxed_slice() 转换成 Box<[T]>，Box<[T]> 也可以通过 into_vec() 转换回 Vec<T>. 这两个转换都是很轻量的转换，只是变换一下结构，不涉及数据的拷贝。区别是，当 Vec<T> 转换成 Box<[T]> 时，没有使用到的容量就会被丢弃，所以整体占用的内存可能会降低。而且 Box<[T]> 有一个很好的特性是，不像 Box<[T;n]> 那样在编译时就要确定大小，它可以在运行期生成，以后大小不会再改变.

            当需要在堆上创建固定大小的集合数据，且不希望自动增长，那么，可以先创建 Vec<T>，再转换成 Box<[T]>

    Vec<T> 和 [T; n] 会转化成为 &[T]，这是因为 Vec<T> 实现了 Deref trait，而 array 内建了到 &[T] 的解引用.

    迭代器可以说是切片的孪生兄弟, 通过切片的 iter() 方法就可以生成一个迭代器，对切片进行迭代.

	> slice底层没有cap属性.

	> 字符串字面值是个slice.

	> 字符串slice内容必须是有效的utf-8字符串. 如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.

	> str 是 Rust 核心语言类型, 就是字符串切片（String Slice）, 常常以引用的形式出现（&str）. String 类型是 Rust 标准公共库提供的一种数据类型(是一个指针, 数据在堆上), 它有所有权, 它的功能更完善——它支持字符串的追加、清空等实用的操作. String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（capacity）属性. String 和 str 都支持切片，切片的结果是 &str 类型的数据.

	> 与go不同, rust slice没有cap, 且没法直接创建, 必须依赖数组或 Vec并通过引用来创建; Go 中使用`:`来引用片段, 而 Rust 使用 `..`.

- str字符串类型(也叫字符串切片, 是DST类型)

    它是对一段**有效的 UTF8字节序列**的引用.

	出于内存安全的考虑, Rust 将字符串分为两种类型, 一种是固定长度字符串，不可随便更改其长的str 字符串, 通常以不可变借用的形式存在(`&str`); 另一种是可增长 符串，可以随意改变其长度的String字符串.

	本质上, 字符串字面量属于 [str 类型](https://github.com/rust-lang/rust/blob/master/library/core/src/str/mod.rs#L122), 只不过它是静态生命周期字符串`&'static str`.
	所谓静态生命周期即程序生命周期.

    > &'static 只能说明引用指向的数据是能一直存活的, 但是引用本身依然受限于它的作用域.

    > `r#""#`(至少包含一个`#`)等价于go的"``", 如果字符串包含`#`, 那么两侧可加更多`#`来解决. 它的其他用途是使用它就可以使用关键字(如let、fn等)作为变量名, 比如`let r#let = 6; // The variable's name is let`

	rust字符串因为包含长度, 因此不是以`\0`表示结束.

	str 字符串类型由两部分组成:
	1. 指向字符串序列的指针
	1. 记录长度的值.

	可以通过 str模块提供的 as_ptr 和len方法分别求得指针和长度.

	字符串字面量用于赋值是接位复制.

	Rust中的字符串不能使用索引访问其中的字符，但可以通过bytes和chars两个方法来分别返回按字节和按字符迭代的迭代器.

	Rust提供了另外两种方法：get和get_mut来通过指定索引范围来获取字符串切片.

    对于 &String 和 &str，如果可理解为 &Vec<T> 和 &[T] 的区别. String 在解引用时，会转换成 &str.

	`&str`存储于栈上, str字符串序列存储于程序的静态只读数据段, 栈或者堆内存中. `&str`是一种胖指针.

    > str 是编译器能够识别的内置类型, 表示有限但大小未知的 UTF-8 编码的连续字节序列, 因此str在堆上, 并且不属于标准库.

    `&str`字符串可以存储在任意地方:
    - 静态存储区. 有代表性的是字符串字面量, `＆'static str`字符串被直接存储到己编译的可执行文件中, 随着程序启动而加载
    - 堆分配 : 如果`&str`字符串是通过 String 字符串取切片生成的, 则存储在堆上. 因为 String 字符串是堆配的, `&str` 不过是其在堆上的切片
    - 栈分配:  str::from_utf8 就可以将栈分配的`[u8;N]`转换为`&str`

    ```rust
    // 要使用 str 类型，只能配合 Box. & 可以用来将 Box<str> 转换为 &str 类型
    // 1
    fn main() {
        let s: Box<str> = "hello, world".into();
        greetings(&s) // 实际是greetings(&(*s)), 只能指针自动解引用了
     }
     
     fn greetings(s: &str) {
         println!("{}",s)
     }
    // 2
    fn main() {
        let s: Box<&str> = "hello, world".into();
        greetings(*s) // 栈上保留的智能指针，指向的是&str，所以 *s 解引用，解的是智能指针
    }

    fn greetings(s: &str) {
        println!("{}", s);
    }
    ```

    ```rust
    fn main() {
        let s1 = String::from("hello,");
        let s2 = String::from("world!");
        let s3 = s1.clone() + &s2; // 只能将 String 跟 &str 类型进行拼接，并且 String 的所有权在此过程中会被 move. `s1.clone() + s2.clone()`是错误语法
        assert_eq!(s3,"hello,world!");
        println!("{}",s1);
    }
    ```

    ```rust
    fn main() {
        let s = "你好，世界"; // s是utf-8数组
        // 修改以下代码行，让代码工作起来
        let slice = &s[0..3];

        assert!(slice == "你");
    }
    ```

    ```rust
    // &String 可以被隐式地转换成 &str 类型.
    fn main() {
        let mut s = String::from("hello world");

        // here, &s is `&String` type, but `first_letter` needs a `&str` type.
        // it works because `&String` can be implicitly converted to `&str, If you want know more ,this is called `Deref` 
        let letter = first_letter(&s);

        println!("the first letter is: {}", letter);

        s.clear();
    }

    fn first_letter(s: &str) -> &str {
        &s[..1]
    }
    ```
- 原生指针

	可表示内存地址 的类型称指针. Rust 提供了多种类型的指针，包括引用(Reference)、原生指针(Raw Pointer)、函数指针(fn Pointer)和智能指针(Smart Pointer).

	引用的本质是非空指针.

	Rust代码可分为Safe Rust和Unsafe Rust 两部分. 引用主要应用于Safe Rust. 在 Safe Rust 中, 编译器会对引用进 用检查以保证内存安全和类型安全.

	原生指针主要用于 Unsafe Rust. 直接使用原生指针是不安全的, 比如原生指针可能指向一个Null, 或者一个己经被释放的内存地址, 因为使用原生指针的地方不在Safe Rust可控范围内, 所以需要程序员自行保证安全.

	Rust 支持两种原生指针: 不可变原生指针`*const T`和`可变原生指针*mut T`.
- never

	Rust 供了一种特殊数据类型 never即`!`. 该类型用于表示永远不可能有返回值的计算类型, 比如线程退出.

	Rust是类型安全的语言, 也需要将这种情况纳入类型系统进行统一管理.

rust的基本原生类型都是POD (Plain Old Data, 相对于面向对象语言新型的抽象数据而言), POD类型都是值语义, 但值语义类型并不一定都是 POD 类型.

对于实现 Copy 的类型, 其clone方法必须是按位复制的. Rust通过 Copy trait 来区分值语义和引用语义, 帮助编译器检测出潜在的内存安全问题.

智能指针`Box<T>`封装了原生指针, 是典型的引用类型. `Box<T>`无法实现 Copy 意味着它被 Rust 标记为了引用语义, 禁止实现按位复制.

## String
rust中字符串就是String和`&str`.

String字符串, 长度可变的utf8字符串, 在堆上分配, 与`&str`的主要区别是它有管理内存空间的能力, 而`&str`没有.

String类型本质是一个成员变量为`Vec<u8>`类型的结构体，所以它是直接将字符内容存放于堆中的.

String类型由三部分组成：
- 执行堆中字节序列的指针（as_ptr方法）
- 记录堆中字节序列的字节长度（len方法）
- 堆分配的容量（capacity方法）

创建String:
```rust
String::New()
xxx.to_string() # 实现了Display trait的类型和字符串字面量
String::from("hello") # 从&str中创建一个String
format!() # format宏
let my_string: String = "Try to make this a String".into() # 使用From trait
```

基础类型变String:
```rust
let one = 1.to_string();         // 整数到字符串
let float = 1.3.to_string();     // 浮点数到字符串
let slice = "slice".to_string(); // 字符串切片到字符串
```

其他用法:
```rust
fn main() {
    let s = String::from("hello中文");
    for c in s.chars() { // 等同go的 `range []rune(s)`
        println!("{}", c);
    }
}

fn main() {
    let s1 = String::from("hi,中国");
    let h = &s1[0..1]; // `s1[0]`是错误语法: `String` cannot be indexed by `{integer}`
    assert_eq!(h, "h");

    let h1 = &s1[3..6];
    assert_eq!(h1, "中");
}
```

Rust 中字符串分为以下几种类型:
- str 表示固定长度的字符串
- String 表示可增长的字符串
- CStr 表示由C分配而被 Rust 借用的字符串, 一般用于和C语言交互
- CString 表示由 Rust 分配且可以传递给C函数使用的C字符串, 同样用于和C语言交互
- OsStr 表示和操作系统相关的字符串. 这是为了兼容 windows 系统
- OsString ，表示 OsStr 的可变版本. 与 Rust 字符串可以相互转换
- Path ，表示路径，定义于 std ::path 模块中. Path 包装了 OsStr, 没有所有权
- PathBuf. 与 Path 配对, Path 的可变版本. PathBuf 包装了 OsString, 有所有权

> std::ffi是std的一部分，它帮助将Rust与其他语言或操作系统一起使用. 它有OsString和CString这样的类型，它们就像操作系统的String或语言C的String一样，它们各自也有自己的&str类型:OsStr和CStr.

> 当必须与一个没有Unicode的操作系统一起工作时，可以使用OsString。所有的Rust字符串都是unicode，但不是每个操作系统支持:
> - Unix系统(Linux等)上的字符串可能是很多没有0的字节组合在一起。而且有时你会把它们读成Unicode UTF-8
> - Windows上的字符串可能是由随机的16位值组成的，没有0。有时你会把它们读成Unicode UTF-16
> - 在Rust中，字符串总是有效的UTF-8，其中可能包含0

字符串迭代:
- 按字节: bytes
- 按字符: chars/char_indices

字符串修改:
- 拼接: 

    - push: 追加单个字符
    - push_str: 追加字符串
    - `+`
    - `format!`
- 插入: insert, insert_str
- 删除: remove, pop, truncate, clear, drain

字符串的查找:
- 存在性判断 : contains, starts_with, ends_with 
- 位置匹配 : find, rfind
- 分割字符串 : split, rsplit, split_terminator, rsplit_terminator, splitn, rsplitn
- 捕获匹配 : matches, rmatches, match_indices, rmatch_indices
- 删除匹配 : trim_matches, trim_left_matches, trim_right_matches
- 替代匹配 : replace, replacen

字符串转换:
- parse

字符串格式化:
- 填充字符串宽度. 格式为`{:number}`, 其中 number 表示数字. 如果number 的长度小于字符串长度, 则什么都不做; 如果 number 的长度大于字符串长度, 则会默认填充空格来扩展字符串的长度
- 截取字符串. 格式为`{:.number}`, 注意 number 有符号`.`, number 表要截取的字符串长度. 也可以和填充格式配合使用, 比如`{:5.3}`
- 对齐字符串: 格式为`{:>}/{:^}/{:<}`, 分别表示左, 中, 右对齐. `{:&<5}`: 左对齐，并使用 `&` 填充

针对整数提供的格式化代码:
- `+` : 强制输出整数的正负符号
- `#` : 用于显示进制的前缀. 比如十六进制显示 Ox, 二进制显示0b.
- `0` : 用于把默认填充的空格替换为0

针对浮点数提供的格式化代码:
- 指定小数点的有效位数. 在指定有效位时会四舍五入
- 科学计数法. 使用`{:e}`可以将浮点数格式化为科学计数法的表示形式

String底层:
```rust
use std::mem;

fn main() {
    let story = String::from("Rust By Practice");

    // Prevent automatically dropping the String's data
    let mut story = mem::ManuallyDrop::new(story);

    let ptr = story.as_mut_ptr();
    let len = story.len();
    let capacity = story.capacity();

    // story has nineteen bytes
    assert_eq!(16, len);

    // 可以基于 ptr 指针、长度和容量来重新构建 String. 
    // 这种操作必须标记为 unsafe，因为需要自己来确保这里的操作是安全的
    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };

    assert_eq!(*story, s);

    println!("Success!")
}
```

## 复合(compound)类型
复合类型（Compound types）可以将多个标量组合成一个类型. Rust 有两个原生的复合类型：元组（tuple）和数组（array）.

rust提供5种复合类型:
1. 元组(Tuple) : 一种**异构有限**序列, 即元素类型可能不同的**固定长度**的序列.

    通过`tuple_name.<N>`的形式访问.
    因为let支持模式匹配(pattern destructuring), 因此可用let解构元组.
    单元值(unit)就是空元组`()`, 不占用内存空间, 可用`std::mem::size_of::<()>()`查看.

    当元组中只有一个元素时（即元组长度是 1），唯一的元素后面必须加上逗号, 以区分括号表达式和元组, 这是避免将小括号当做计算的优先级.

    > 元组成员的析构与其出现的顺序一致, 从左到右. 某成员出发panic时, 析构顺序与局部变量的析构顺序一致. struct和enum的修改和tuple一致.

1. 数组(array) : 与元组不同，数组中的每个元素的类型必须相同. Rust 中的**数组是固定长度**的：一旦声明，它们的长度不能增长或缩小. **数组的大小是在编译时确定
的常量**.

    定义: `let a: [T; n] = {}`
    vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型.

    将所有元素初始化为相同值的语法: `let ys: [i32;500] = [1;500]`

    在rust中, 两个元素类型和成员个数相同的数组才是同类型的.

    多维数组: `[[T;m];n]`

    Rust 中关于数组越界的行为, 定义得非常清晰. 相比于 C/C+, Rust消除的是`"未定义行为"(Undefin Behaviour)`

    > 当想要在栈（stack）而不是在堆（heap）上为数据分配空间, 或者是想要确保总是有固定数量的元素时，数组非常有用. 但是数组并不如 vector 类型灵活.

1. 结构体(Struct)

    分三种:
    1. 具名结构体(named-field struct)

        它是rust面向对象思想的一种体现.
    1. 元组结构体(tuple-like struct)

        没有字段名称, 仅有类型. 比如`struct Color(i32, i32, i32);`
        
        当一个元组结构体只有一个字段时, 比如`struct UserId(u64);`, 称为New Type模式. 因为它把一种类型封装成了新类型.

        > 对于具有 3 个以上字段的数据类型，建议具名结构体.
    1. 单元结构体(unit-like struct)

        没有任何字段的结构体, 比如`strcut Empty{}`.
        `std::ops::RangeFull`就是一个单元结构体.

        在Release编译模式下, 单元结构体实例会被优化为同一个对象; 而在Debug模式下, 则不会进行这样的优化.

        类单元结构体常常在想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用.

    结构体名称需遵从驼峰式命名规则.

    结构体上方的`#[derive(Debug, PartialEq)]`是[属性(类似于代码生成)](https://doc.rust-lang.org/reference/attributes/derive.html), 可让结构体自行实现Debug trait 和 PartialEq trait, 即允许对struct实例进行打印(通过`{:?}或{:#?}`)和比较.

    Rust 允许 struct 类型的初始化使用一种简化的的写法: 如果有局部变量名字与成员变量名字恰好一致, 那么可以省略掉重复的冒号初始化`: `, 比如:
    ```rust
    fn build_user(email: String, username: String) -> User {
        User {
            email,
            username,
            active: true,
            sign_in_count: 1,
        }
    }
    ```

    结构体更新语法（struct update syntax）: 使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例, 比如:
    ```rust
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
    // 使用结构体更新语法为一个 User 实例设置新的 email 和 username 值，不过其余值来自 user1 变量中实例的字段
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1 //  `..user1`后面不可以有逗号
    };
    ```

    在rust中函数和方法是有区别的, 不在impl块中定义的函数是自由函数, 而在impl块中定义的函数是方法, 第一个参数通常是`&self/&mut self`, 表示对结构体实例自身的引用.

    > impl方法分关联方法和实例方法, 区别是关联方法没有self类型参数, 而实例方法有. 其实`instance.foo()`是一种语法糖, 等价于`<InstanceType>::foo(&instance)`

    > 如果结构体类型包含引用，则必须指定这些引用的生命期

    > 生命周期可确保结构体引用的数据有效性跟结构体本身保持一致, 如果尝试在结构体中存储一个引用而不指定生命周期将是无效的即会报错.

    > 引用结构体成员给其他变量赋值时, 要注意：所有权的转移可能会破坏结构体变量的完整性.

1. 枚举体(Enum)

    分三类:
    1. 无参数枚举体

        ```rust
        enum Number {
            Zero,
            One,
        }

        let a = Number::One;
        ```
    1. 类C枚举体

        ```rust
          enum Number {
            Zero = 1 ,
            One = 2,
        }

        let a = Number::One as i32;
        ```
    1. 带类型参数的枚举体

        ```rust
          enum IpAddr {
            V4(u8,u8,u8,u8),
            V6(String),
        }

        let a = IpAddr::V4(127,0,0,1);
        let b : fn(String) -> IpAddr = IpAddr::V6;//  IpAddr::V6是 `fn(String) -> IpAddr` 函数指针.

        enum Message {
            Quit,
            Move { x: i32, y: i32 }, // 匿名struct, 此时并不能像访问结构体字段一样访问枚举类绑定的属性, 而是需要使用`match`
            Write(String),
            ChangeColor(i32, i32, i32),
        }

        // 上面那个枚举等同于有四个含有不同类型的成员
        struct QuitMessage; // 类单元结构体
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // 元组结构体
        struct ChangeColorMessage(i32, i32, i32); // 元组结构体


        // 等价的c定义
        struct Message {
            int tag;
            union {
                struct {} Quit;
                struct {
                    int32_t x, y;
                } Move;
                struct {
                    char* a;
                } Write;
                struct {
                    int32_t _1, _2, _3;
                } ChangeColor;
            } cases;
        }

        enum Book {
            Papery {index: u32},
            Electronic {url: String},
        }
       
        let book = Book::Papery{index: 1001};
        let ebook = Book::Electronic{url: String::from("url...")};
       
        match book {
            Book::Papery { index } => {
                println!("Papery book {}", index);
            },
            Book::Electronic { url } => {
                println!("E-book {}", url);
            }
        }
        ```

        **结构体和枚举还有另一个相似点：可以使用 impl 在枚举上定义方法**.

        Rust的enum与C++ 的enum和union都不同. 它是一种更安全的类型, 可以被称为["tagged union"](https://www.zhihu.com/question/452956370). 这个情况下, rust一般再加一个整型（一般是4 byte，有例外）用作tag, 然后每个case都是一个struct，最后在union起来. enum的某些情况是可以优化的, 优化方法: niche optimization.


        ```rust
        enum Number { 
            Int(i32),
            Float(f32), 
        }
        ```
        用c理解即是:
        ```c
        struct IpAddr { 
            enum {Int, Float} tag; 
            union { 
                int32_t int_value; 
                float float_value; 
            } value; 
        };

        enum Foo {
            C1(&i32, bool),
            C2,
            C3
        }

        // 可被优化成: 当_2为0或者1时Foo表示C1，为2时表示C2，为3时表示C3。 后两种情况下的_1的值未定义.
        struct Foo {
            int32_t *_1;
            uint8_t _2;
        }
        ```

        Rust enum 类型的变量需要区分它里面的数据究竟是哪种变体, 所以它包含了一个内部的`tag 标记`来描述当前变量属于哪种类型. 这个标记对用户是不可见的, 通过恰当的语法设计, 保证标记与类型始终是匹配的，以防止用户错误地使用内部数据, 可用`std::mem::size_of::<Number>()`输出大小来验证.
1. 联合体(Union) 
    rust也支持 union 类型, 这个类型与C中的 union 完全一致, 但在 Rust 里面, 读取它内部的值被认为是 unsafe 行为, 一般情况下不使用这种类型, 而它存在的主要目的是为了方便与C语言进行交互.


> tuple, struct, tuple struct 这几种类型，实质上是同样的内存布局，区别仅仅在于是否给类型及成员起了名字.

## 常用集合类型
标准集合:
|集合|说明|其他语言中类似的集合(C++/Java/Python)|
|Vec<T>|可增数组|vector/ArrayList/list)|
|VecDeque<T>|双端队列（可增长环形缓冲区）|deque/ArrayDeque/collections.deque|
|[LinkedList<T>](https://doc.rust-lang.org/std/collections/struct.LinkedList.html)|双向链表|list/LinkedList/–|
|BinaryHeap<T> where T: Ord|最大堆|priority_queue/PriorityQueue/heapq|
|HashMap<K, V> where K: Eq + Hash|键 – 值散列表|unordered_map/HashMap/dict|
|BTreeMap<K, V> where K: Ord|有序键 – 值表|map/TreeMap/–|
|HashSet<T> where T: Eq + Hash|散列表|unordered_set/HashSet/set|
|BTreeSet<T> where T: Ord|有序集|set/TreeSet/–|

Rust 标准库中包含一系列被称为 集合（collections）的非常有用的数据结构. 大部分其他数据类型都代表一个特定的值，不过集合可以包含多个值. 不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小.

> 有时候, 集合类型里的数据不断进进出出, 导致集合一直增长, 但只使用了很小部分的容量, 内存的使用效率很低, 此时可用比如  shrink_to_fit 方法, 来节约对内存的使用.

std::collections提供了4种通用集合类型:
1. 线性序列: 向量(Vec, **堆上分配**的数组), 双端队列(VecDeque), 链表(LinkedList)

    向量也是一种数组, 但可动态增长.
    `vec!`是一个宏, 用来创建向量字面量.
    rust的VecDeque是基于可增长的RingBuffer算法实现的双端队列.
    通常最好使用Vec或VecDeque类型, 因为它们比链表更加快速, 内存访问效率更高, 并且可以更好地利用cpu缓存.

    > rust的String基于Vec, 可变字符串用String, 不可变字符串用`&str`.

    双端队列（Double-ended Queue，缩写Deque）是一种同时具有队列（先进先出）和栈（后进先出）性质的数据结构. 双端队列中的元素可以从两端弹出，插入和删除操作被限定在队列的两端进行. 它是基于可增长的 RingBuffer 算法实现的双端队列.

    Rust提供的链表是双向链表，允许在任意一端插入或弹出元素.

    但是通常最好使用 Vec/VecDeque 类型, 因为它们比链表更加快速, 内存访问效率更高, 并且可以更好地CPU缓存.

    > 当缓冲区达到其容量上限后，再给向量添加元素会导致一系列操作：分配一个更大的缓冲区，将现有内容复制过去，基于新缓冲区更新向量的指针和容量，最后释放旧缓冲区.

    ```rust
    // 声明
    let mut v2 = Vec::new();
    v2.push(2); // 现在 v2 的类型是 Vec<i32>
    let v3 = Vec::<u8>::new(); // 使用 turbofish 符号, 泛型函数中的 turbofish 运算符出现在函数名之后和圆括号之前

    let mut v: Vec<i32> = Vec::new();
    // let v = vec![1, 2, 3]; // 使用vec!宏, 让rust自动推导类型
    v.push(5); // 在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中

    let vector = vec![1, 2, 4, 8];     // 通过数组创建向量

    let third: &i32 = &v[2]; // 当引用一个不存在的元素时 Rust 会造成 panic
    println!("The third element is {}", third);

    match v.get(2) { // 2 is index. 当 get 方法被传递了一个数组外的索引时，它不会 panic 而是返回 None
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }

    for i in &v {
        println!("{}", i);
    }
    ```

    Vec.with_capacity()获取Vec的cap.
    Vec.pop()从Vec中取出最后一项.

    将 X 类型转换(From/Into 特征)成 Vec:
    ```rust
    fn main() {
        // array -> Vec
        // impl From<[T; N]> for Vec
        let arr = [1, 2, 3];
        let v1 = Vec::from(arr);
        let v2: Vec<i32> = arr.into();
     
        assert_eq!(v1, v2);
     
        
        // String -> Vec
        // impl From<String> for Vec
        let s = "hello".to_string();
        let v1: Vec<u8> = s.into();

        let s = "hello".to_string();
        let v2 = s.into_bytes();
        assert_eq!(v1, v2);

        // impl<'_> From<&'_ str> for Vec
        let s = "hello";
        let v3 = Vec::from(s);
        assert_eq!(v2, v3);

        // 迭代器 Iterators 可以通过 collect 变成 Vec
        let v4: Vec<i32> = [0; 10].into_iter().collect();
        assert_eq!(v4, vec![0; 10]);

        println!("Success!")
     }
    ```
1. Key-Value映射: 无序哈希表(HashMap), 有序哈希表(BTreeMap)

    HashMap要求key是必须可哈希的类型，BTreeMap的key必须是可排序的
    value必须是在编译期已知大小的类型

    可通过 shrink_to_fit / shrink_to 释放掉不需要的内存.

    rust默认hash是SipHash13, 它性能更佳. std也有SipHash24更安全.

    ```rust
    use std::collections::HashMap;
    let mut scores = HashMap::new();

    let teams  = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];

    let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect(); // 使用下划线占位是因为 Rust 能够根据 vector 中数据的类型推断出 HashMap 所包含的类型

    let team_name = String::from("Blue");
    let score = scores.get(&team_name);

    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }

    scores.insert(String::from("Blue"), 11); // 覆盖value
    scores.entry(String::from("Yellow")).or_insert(50); // entry 函数的返回值是一个枚举，Entry，它代表了可能存在也可能不存在的值. Entry 的 or_insert 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用.

    let mut map = HashMap::new();
    map.insert(1, "a");
   
    if let Some(x) = map.get_mut(&1) {
        *x = "b";
    }
    ```

    建议使用Map.get(x)获得Option, 而不是Map[x], 避免程序崩溃

    > 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者

    > 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的.

    HashMap 默认使用一种 “密码学安全的”（“cryptographically strong” ）哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击. 然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价. 如果性能监测显示此哈希函数非常慢，以致于无法接受，可以指定一个不同的 hasher 来切换为其它函数. hasher 是一个实现了 BuildHasher trait 的类型.

    > Rust 哈希表不是用冲突链来解决哈希冲突，而是用开放寻址法的二次探查来解决的


    第三方hash:
    ```rust
    use std::hash::BuildHasherDefault;
    use std::collections::HashMap;
    // 引入第三方的哈希函数
    use twox_hash::XxHash64;


    let mut hash: HashMap<_, _, BuildHasherDefault<XxHash64>> = Default::default();
    hash.insert(42, "the answer");
    assert_eq!(hash.get(&42), Some(&"the answer"));
    ```
1. 集合类型: 无序集合(HashSet), 有序集合(BTreeMap)

    集合类型实际就是把Key-Value映射的Value设置成空元组.
1. 优先队列: 基于二叉最大堆(BinaryHeap)实现.

    它把最大的元素放在前面，但其他元素是按任意顺序排列的

无论是Vec还是HashMap，使用这些集合容器类型，最重要的是理解容量（Capacity）和大小（Size/Len）:
- 容量是指为集合容器分配的内存容量
- 大小是指集合中包含的元素数量

## 指针
与 C 指针不同的是， Rust 引用永远不会是空值，因为在安全 Rust 代码中根本不可能产生空引用, 而且 Rust 引用默认是不可修改的.

无GC 的编程语言， C/C++以及 Rust, 对数据的组织操作有更多的自由度, 表现为:
- 同一个类型，某些时候可以指定它在栈上, 某些时候可以指定它在堆上. 内存分配方式可以取决于使用方式, 与类型本身无关.
- 既可以直接访问数据 ，也可以通过指针间接访问数据. 可以针对任何一个对象取得指向它的指针
- 既可以在复合数据类型中直接嵌入别的类型的实体, 也可以使用指针, 间接指向别的类型
- 甚至可能在复合数据类型末尾嵌入不定长数据构造出不定长的复合数据类型

rust指针大致分为三种:
1. 引用(reference)

	`&T`或`&mut T`, 受Rust的安全检查规则的限制

	引用的本质是非空指针.

	引用是Rust提供的一种无所有权的指针语义, 引用的生命期不能超过其引用的资源. 引用是基于指针的实现，它与指针的区别是：指针保存的是其指向内存的地址，而引用可以看做某块内存的别名（Alias）.
1. 裸指针(raw pointer),

	`*const T`或`*mut T`.

	可以在unsafe块下任意使用, 不受Rust的安全检查规则的限制.

    ```rust
    fn main() {
        let mut values: [i32; 2] = [1, 2];
        let p1: *mut i32 = values.as_mut_ptr();
        let first_address: usize = p1 as usize; 
        let second_address = first_address + 4; // 4 == std::mem::size_of::<i32>()
        let p2: *mut i32 = second_address as *mut i32; // p2 指向 values 数组中的第二个元素
        unsafe {
            // 将第二个元素加 1
            *p2 += 1;
        }
        
        assert_eq!(values[1], 3);

        println!("Success!")
    }

    fn main() {
    let arr :[u64; 13] = [0; 13];
    assert_eq!(std::mem::size_of_val(&arr), 8 * 13);
    let a: *const [u64] = &arr;
    let b = a as *const [u8];
    unsafe {
        assert_eq!(std::mem::size_of_val(&*b), 13)
    }
}
    ```
1. 智能指针(smart pointer)

	智能指针实际上是一种结构体, 是对指针的一层封装, 因此它的行为类似指针. 它还通过其元数据提供了一些额外的功能, 比如自动释放堆内存.

    > 智能指针一定是一个胖指针, 但胖指针不一定是一个智能指针. 比如 &str 就只是一个胖指针, 它有指向堆内存字符串的指针, 同时还有关于字符串长度的元数据. 智能指针对堆上的值是有所有权的, 普通胖指针是没有所有权的, 这是 Rust 中智能指针和普通胖指针的区别.

    在 Rust 中, 凡是需要做资源回收的数据结构, 且实现了 Deref/DerefMut/Drop, 就都是智能指针. 比如用于在堆上分配内存的 `Box<T> 和 Vec<T>`、用于引用计数的`Rc<T> 和 Arc<T`, 很多其他数据结构，如 `PathBuf、Cow<'a, B>、MutexGuard<T>、RwLockReadGuard<T> 和 RwLockWriteGuard` 等也是智能指针.

	智能指针区别于常规结构体的特性在于：它实现了Deref和Drop这两个trait:
	- Deref：提供了解引用能力

		解引用会获得所有权, 解引用操作符是`*`.
	- Drop：提供了自动析构的能力

	智能指针和普通引用的区别之一就是所有权的不同. 智能指针拥有资源的所有权，而普通引用是对所有权的借用.

	> rust在堆上分配内存的唯一方法是通过智能指针类型.
    > 自实现智能指针: [smartstring](https://github.com/bodil/smartstring)
1. 函数指针(fn pointer)

引用和裸指针类型之间的异同:
1. 可以通过 as 操作符随意转换, 比如 `&T as *const T`和`＆mut T as *mut T` 
1. 裸指针可 unsafe 块下任意使用, 不受 Rust 安全检查规则的限制, 而引用则必须受到编译器安全检查规则的限制

Rust 有不止一种指针类型, 常见的几种指针类型:
- `Box<T>` : 指向**在堆上分配**的类型T的, 具有所有权的指针, 有权释放内存

	Rust中的值默认被分配到栈内存, 可通过`Box<T>`将值装箱(在堆内存中分配). 可通过解引用来获取`Box<T>`中的T. 因为`Box<T>`的行为像引用, 并且可以自动释放内存, 因此将其称为智能指针.

    > C++ 的 unique_ptr 就是 Rust 的 Box 的前身.

	Box 类型的所有权语义取决于包装类型。如果基础类型为Copy, 那么 Box 实例将成为副本，否则默认情况下将发生移动.

	String类型和Vec类型的值都是被分配到堆内存并返回指针的，通过将返回的指针封装来实现Deref和Drop.

	```rust
	struct Node {
		data: u32,
		next: Option<Box<Node>>
	}
	```

	Box<T>是指向类型为T的堆内存分配值的智能指针. 当Box<T>超出作用域范围时，将调用其析构函数，销毁内部对象，并自动释放堆中的内存.

	```rust
	fn main(){
		// a装箱的字符串字面行了按位复制, 而b装箱的String类型是引用语义, 会转移所有权
	    let a = Box::new("hello");
	    let b = Box::new("Rust".to_string());
	    let c = *a;
	    let d = *b;
	    println!("{:?}", a);
	    //error[E0382]: use of moved value: `b`
	    //println!("{:?}", b);
	}
	```

	Deref时对于 `Box<T>`类型来说, 如果包含的类型T是复制语义, 则执行按位复制; 如果移动语义, 则移动所有权.

	对 `Box<T>` 使用操作符`*`进行解引用而转移所有权的行为被称为解引用移动. 目前支持此行为的智能指针只有`Box<T>`.

    Box<T> 有一个缺省的泛型参数 A，就需要满足 Allocator trait，并且默认是 Global.

    Allocator trait 提供很多方法:
    1. allocate 是主要方法，用于分配内存，对应 C 的 malloc/calloc
    1. deallocate，用于释放内存，对应 C 的 free
    1. 还有 grow / shrink，用来扩大或缩小堆上已分配的内存，对应 C 的 realloc

    如果想替换默认的内存分配器，可以使用`#[global_allocator]`标记宏, 定义自己的全局分配器, 比如[在 Rust 下使用 jemalloc](https://crates.io/crates/jemallocator).

    GlobalAlloc trait和 Allocator trait 的区别，主要在于是否允许分配长度为零的内存.

    `Box::new()`里包含box 关键字, 它是 Rust 内部的关键字，用户代码无法调用，它只出现在 Rust 代码中，用于分配堆内存，box 关键字在编译时，会使用内存分配器分配内存.

    目前Box<T> drop trait 什么都没有做, 编译器会自动插入 deallocate 的代码. 这是 Rust 语言的一种策略：在具体实现还没有稳定下来之前，先把接口稳定，实现随着之后的迭代慢慢稳定.

- `&T` : 指向类型T的借用指针, 也称为引用, 无权释放内存, 无权写数据, 是 Copy 类型.

	类似C中的`const T*`
- `&mut T` : 指向类型T的mut型借用指针, 无权释放内存, 有权写数据, 不是Copy类型.

	类似C中的`T*`
- `*const T` : 指向类型T的只读裸(即原始)指针, 没有生命周期信息, 无权写数据. 它是 Copy 类型。这类似于&T，只是它可以为空值.
- `*mut T` : 指向类型T的可读写裸(即原始)指针, 没有生命周期信息, 有权写数据.  它不支持 Copy 特征（ non-Copy）.

> Rust 的原始指针实际上就是 C++ 中的那种指针, 使用原始指针是不安全的，因为 Rust 不会跟踪它指向哪里.

```rust
fn main() {
	// 可将引用强制转换为原始指针
    let a = &56;
    let a_raw_ptr = a as *const i32;
    // or
    let b = &mut 5634.3;
    let b_mut_ptr = b as *mut f64;
}
```

此之外，在标准库中还有一种封装起来的可以当作指针使用的类型, 即智能指针(smart pointer, 来自c++):
- `Rc<T>` : 指向类型T的引用计数指针, 共享所有权, 线程不安全

    通过clone方法共享的引用所有权称为强引用，RC<T>是强引用.

    当与一个 Rc 类型交互时，其内部会发生如下变化:
	- 当通过调用 Clone()获取对 Rc 的一个新共享引用时， Rc 会增加其内部引用计数。Rc 内部使用 Cell 类型处理其引用计数。
	- 当引用超出作用域时，它会对引用计数器执行递减操作。
	- 当所有共享引用计数超出作用域时， refcount 会变成 0。 此时， Rc 上的最后一次 drop	调用会执行相关的资源清理工作

	Rc<T>主要通过两种方式使用:
	- 静态方法 Rc::new 会生成一个新的引用计数器。
	- clone 方法会增加强引用计数并分发一个新的 Rc<T>

	Rc 内部会保留两种引用：强引用（ Rc<T>）和弱引用（ Weak<T>）。二者都会维护每种类型的引用数量的计数，但是仅在强引用计数值为零时，才会释放该值. 它的弱引用可打破引用循环.

    > Weak 相当于一个弱化版本的 Rc，不参与到引用计数的计算中，而 Weak 可以 upgrade 到 Rc 来使用.

	Rc通过clone创建的引用是强引用; 用Rc::downgrade创建的是弱引用, 它的指针没有所有权, 所以被称为弱引用.

	```rust
	use std::rc::Rc;
	fn main() {
	    let x = Rc::new(45);
	    let y1 = x.clone(); // 增加强引用计数
	    let y2 = x.clone();  // 增加强引用计数
	    println!("{:?}", Rc::strong_count(&x));
	    let w =  Rc::downgrade(&x);  // 增加弱引用计数
	    println!("{:?}", Rc::weak_count(&x));
	    let y3 = &*x;         // 不增加计数
	    println!("{}", 100 - *x);
	}
	```

    Rc使用了Box::leak(). Box::leak()创建的对象, 会从堆内存上泄漏出去, 不受栈内存控制, 是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象.

    Box::leak()可以跳出 Rust 编译器的静态检查，保证 Rc 指向的堆内存，有最大的生命周期，然后再通过引用计数，在合适的时机，结束这段内存的生命周期.

    无法获得`&mut T`的可变借用, 需使用`(Rc<RefCell<T>>).borrow_mut()`

- `Arc<T>` : 指向类型T的原子型引用计数指针, 共享所有权, 线程安全

	`Arc<T>`是线程安全版本的`Rc<T>`

    无法获得`&mut T`的可变借用, 用`(Arc<Mutex<T>>).lock()`或`(Arc<RwLock<T>>).write()`
- `Cow<’a, T>` : Clone-on-write, 写时复制指针. 可能是借用指针, 也可能是具有所有权的指针

    它是一个 enum，可以包含一个对类型 B 的只读引用，或者包含对类型 B 的拥有所有权的数据.

	`Cow<T>`是一个枚举体的智能指针，包括两个可选值：
	- Borrowed, 用于包裹引用
	- Owned, 用于包裹所有者

        ToOwned 特征意味着它是一种可以转变为拥有所有权的类型. 例如, str 通常是一个引用 (&str), 可将其转换为一个拥有所有权的String

	Cow<T>的功能是：以不可变的方式访问借用内容，以及在需要可变借用或所有权的时候再clone其借用的数据. 它实现了Deref. Cow<T>旨在减少复制操作，提高性能，一般用于读多写少的场景. Cow<T>的另一个用处是统一实现规范.

	Cow<T>使用:
	- 实现了 Deref, 所以可以直接调用T的不可变方法
	- 在需要修改T时，可以使用 to_mut 方法来获取可变借用. 该方法会产生克隆，但仅克隆一次, 如果多次调用，则只会使用第一次的克隆对象. 如果T本身拥有所有权, 则此时调用 to_mut 不会发生克隆
	- 在需要修改T时，也可以使用 into_owned 方法来获取一个拥有所有权的对象. 如果T是借用类型，这个过程会发生克隆，井创建新的所有权对象. 如果T是所有权对象，则会将所有权转移到新的克隆对象.
- Cell<T>：提供**实现了 Copy 特征的类型的内部可变性**. 换句话说，有可能获得多个可变引用

	在一个不可修改的值内部有一个小小的可修改数据, 这就叫作内部修改能力（interior mutability）.

	Cell 唯一特别的地方是不需要对其自身的mut 引用, 也能取得或设置其私有字段的值.

	Cell<T>可以为值提供可变性，甚至允许值位于不可引用之后。它以极低的开销提供此功能:
	- Cell::new 方法允许你通过传递任意类型 T 来创建 Cell 类型的新实例。
	- get:get 方法允许你复制单元（ cell）中的值。仅当包装类型 T 为 Copy 时，该方法	才有效
	- get_mut: 针对于没有实现Copy的类型T, 返回可变借用 
	- set：允许用户修改内部的值，即使该值位于某个不可变引用的后面. 这个方法的 self 参数是以非 mut 引用的形式传入的

	```rust
	use std::cell::Cell;
	struct Foo {
	    x: u32,
	    y: Cell<u32>
	}
	fn main(){
	   let foo = Foo { x: 1 , y: Cell::new(3)};
	   assert_eq!(1, foo.x);
	   assert_eq!(3,foo.y.get());
	   foo.y.set(5);
	   assert_eq!(5,foo.y.get());
	}
	```

	`Cell<T>`没有运行时开销, 但不推荐用它包裹大的结构体.
- RefCell<T>：提供了类型的**内部可变性**，并且不需要实现 Copy 特征. 它用于**运行时**的锁定以确保安全性

    > 它是在运行时而不是编译时检查借用, 因此即使错误也可能编译通过, 比如使用了2次`borrow_mut()`, 可编译, 但运行崩溃.

	与 Cell<T> 类似， RefCell<T> 是只包含一个 T 类型值的泛型类型. 但与 Cell 不同， RefCell 支持借用它的 T 类型值的引用.

	为某个非 Copy 类型支持 Cell 的功能

	RefCell 类型提供了以下方法:
	- new : 创建一个新 RefCell，将 value 转移到其中
	- borrow : 回一个 Ref<T>，基本上是对 ref_cell 中值的共享引用. 如果这个值已经被可修改地借用了，这个方法会panic
	- borrow_mut : 返回一个 RefMut<T>，基本上是对 ref_cell 中值的可修改引用。如果这个值已经被借用了，这个方法会panic.

	上述两个 borrow 方法之所以会panic，是因为试图破坏 Rust 中 mut 引用是排他引用的规则. 即`.borrow()和.borrow_mut()`可以做与&和&mut相同的事情, 规则都是一样的:
    - 多个不可变借用可以
    - 一个可变的借用可以
    - 但可变和不可变借用在一起是不行的

	唯一的不同是，常规情况下把引用保存到变量， Rust结构体会通过编译时检查来确保安全地使用它。如果检查失败，编译器会报错。而 RefCell 会通过**运行时借用检查器**检查强制应用相同的规则(即有运行时开销)。因此如果开发者破坏了规则，就会收到panic

    多线程使用Mutex 和 RwLock.

和 Rc 类似，Cell/RefCell 也绕过了 Rust 编译器的静态检查，允许在运行时，对某个只读数据进行可变借用即内部可变性.

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    { // 因为根据所有权规则，在同一个作用域下, 不能同时有活跃的可变借用和不可变借用. 通过这对花括号, 明确地缩小了可变借用的生命周期，不至于和后续的不可变借用冲突
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!("data: {:?}", data.borrow());
}
```

```rust
// 可编译, 但运行会panic, 说明RefCell时运行时检查
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    
    let mut v = data.borrow_mut();
    *v += 1;
    
    println!("data: {:?}", data.borrow());
}
```

Cell和 RefCell，以及包含它们的任何类型，都不是线程安全的. 为此， Rust 不会同时允许多个线程访问它们. 它们本质上不属于智能指针, 只是可以提供内部可变性（ Interior Mutability ）的容器.

`Cell<T>和RefCell<T>`使用最多的场景就是配合只读引用来使用, 比如`＆T或Rc<T>`.

`Rc<T>和Arc<T>`多用于gui编程. Cell和RefCell提供了共享可变性, 此时会将借用检查从编译时移动到运行时. 这是通过内部可变性实现的.

> 内部可变性：在这种可变性中，即使你有一个引用某种类型的&SomeStruct，如果其中的字段类型为 Cell<T>或 RefCell<T>，那么仍然可以修改其字段.

> 用let mut 或 &mut声明时, 编译器可以在编译时进行严格地检查, 保证只有可变的值或引用, 才能修改值内部的数据, 这被称作外部可变性（exterior mutability）. 外部可变性通过 mut 关键字声明.

Rust使用as用于类型转换, 前提是编译器认为是合理的转换.

> [std::mem::transmute](https://practice-zh.course.rs/type-conversions/others.html) 是一个 unsafe 函数，可以把一个类型按位解释为另一个类型，其中这两个类型必须有同样的位数( bits ). transmute 相当于将一个类型按位移动到另一个类型，它会将源值的所有位拷贝到目标值中，然后遗忘源值, 该函数跟 C 语言中的 memcpy 函数类似.

智能指针(Smart Point)的功能并非rust独有的, 它源自C++语言.

Rust 中的值默认被分配到栈内存. 通过 `Box <T>`将值装箱(在堆内存中分配). `Box<T>` 是指向T类型的堆内存分配值的智能指针. 当 `Box<T>` 超出作用域范围时, 将调用其析构函数, 销毁内部对象, 并自动动释放堆中的内存. 通过解引用操符可获取`Box<T>`中的T.

`Box<T>`的行为像引用, 并且可以自动释放内存，所以称其为智能指针.

智能指针是因为它们还具有与之相关联的额外元数据和代码, 它们会在创建和销毁指针时被调用和执行. 智能指针超出作用域时能够自动释放底层资源是采用它们的主要原因之一.
智能指针的大部分特性要归功于两个特征Drop 和 Deref:
- Drop: 释放资源, 通常由Rust编译器在编译后的代码中每个作用域结束的位置插入 drop 方法调用, 类似C++中的析构函数.

	它包含一个 drop 方法, 当对象超出作用域时就会被调用。该方法将&mut self 作为参数。使用 drop 释放值是以LIFO 的方式进行的.

    大部分场景无需为数据结构提供 Drop trait，系统默认会依次对数据结构的每个域做 drop。但有两种情况可能需要手工实现 Drop:
    1. 希望在数据结束生命周期的时候做一些事情，比如记日志
    1. 需要对资源回收的场景, 比如说锁资源`MutexGuard<T>`的释放, 因为编译器并不知道你额外使用了哪些资源，也就无法帮助开发者 drop 它们.

            当 MutexGuard 结束时，Mutex 会做 unlock，这样用户在使用 Mutex 时，可以不必关心何时释放这个互斥锁

            MutexGuard的应用见[r2d2连接池](https://github.com/sfackler/r2d2/blob/master/src/lib.rs#L611)

    Copy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。这其实很好理解：Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而 Drop 恰恰是为了释放额外的资源而生的
- Deref: 它定义了一个名为 Deref 的方法，并会通过引用获取 self 参数，然后返回对底层类型的不可变引用, 即让指针反映封装值的类型

    DerefMut继承了 Deref，只是它额外提供了一个 deref_mut 方法，用来获取可变的解引用.

	DerefMut可提供对底层类型的可变引用.


    数据结构 Buffer 包裹住了 Vec，但这样一来，原本 Vec 实现了的很多方法就无法使用了, 可以实现 Deref 和 DerefMut, 这样在解引用的时候，直接访问到 buf.0，省去了代码的啰嗦和数据结构内部字段的隐藏.
    ```rust
    use std::ops::{Deref, DerefMut};

    #[derive(Debug)]
    struct Buffer<T>(Vec<T>);

    impl<T> Buffer<T> {
        pub fn new(v: impl Into<Vec<T>>) -> Self {
            Self(v.into())
        }
    }

    impl<T> Deref for Buffer<T> {
        type Target = [T];

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl<T> DerefMut for Buffer<T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }

    fn main() {
        let mut buf = Buffer::new([1, 3, 2, 4]);
        // 因为实现了 Deref 和 DerefMut，这里 buf 可以直接访问 Vec<T> 的方法
        // 下面这句相当于：(&mut buf).deref_mut().sort()，也就是 (&mut buf.0).sort()
        buf.sort();
        println!("buf: {:?}", buf);
    }
    ```


Deref 和 DerefMut 特型的设计初衷是为了实现智能指针类型（如 Box、Rc 和 Arc），以及某些会频繁通过引用来使用的类型的所有者版本（如 Vec<T> 和 String 就是 [T] 和 str 的所
有者版本）。如果目的仅仅是让 Target 类型的方法自动在类型上可见（就像 C++ 中让基类的方法在子类上可见那样），则不应该实现 Deref 和 DerefMut。这样并不能保证始终有效，
一旦出问题则很难发现.

打印类型:
```rust
fn print_type_of<T>(_: &T) {
		println!("{}", std::any::type_name::<T>())
}

fn main() {
    let x = 32;
    print_type_of(&x);
  	// 输出：i32
}
```

## 泛型
每一个编程语言都有高效处理重复概念的工具. 在 Rust 中其工具之一就是 泛型（generics）. 泛型是具体类型或其他属性的抽象替代.

泛型允许开发者编写一些在使用时才制定类型的代码. rust编译器会在编译期间自动为具体类型生成实现代码, 即采用单态化（monomorphization）实现.

泛型就是把一个泛化的类型作为参数.

> C++ 语言中用"模板"来实现泛型. 泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等.

与枚举类型额函数一样,结构体名称旁边的`<T>`叫做泛型声明. 泛型只有被声明之后才可以实现.

```rust
struct Point<T> { x: T, y: T}
impl<T> Point<T> {
    fn new(x: T,y: T) -> Self {
        Point{x:x, y:y}
    }
}
fn main() {
    let p1 = Point::new(1,2);
    let p1 = Point::new("1","2");   
}
```

在定义数据结构时，对于额外的、暂时不需要的泛型参数，用 PhantomData 来“拥有”它们，这样可以规避编译器的报错.

impl后没有`<T>`时, Rust会认为T是一个具体的类型, 因此它不能省略. 比如:
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl Point<f32> { // 是针对 impl 的特化
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point{x: 5f32, y: 10f32};
    println!("{}",p.distance_from_origin())
}
```

### const泛型参数
Const 泛型是针对值的泛型.

const 泛型参数只能使用以下形式的实参:
一个单独的 const 泛型参数
一个字面量 (i.e. 整数, 布尔值或字符).
一个具体的 const 表达式( 表达式中不能包含任何 泛型参数)

```rust
fn foo<const N: usize>() {}

fn bar<T, const M: usize>() {
    foo::<M>(); // ok: 符合第一种
    foo::<2021>(); // ok: 符合第二种
    foo::<{20 * 100 + 20 * 10 + 1}>(); // ok: 符合第三种
    
    foo::<{ M + 1 }>(); // error: 违背第三种，const 表达式中不能有泛型参数 M
    foo::<{ std::mem::size_of::<T>() }>(); // error: 泛型表达式包含了泛型参数 T
    
    let _: [u8; M]; // ok: 符合第一种
    let _: [u8; std::mem::size_of::<T>()]; // error: 泛型表达式包含了泛型参数 T
}
```

```rust
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

// 隐含: 传入的类型必须是 编译期已知 大小的
fn check_size<T>(val: T)
where
    Assert<{ core::mem::size_of::<T>() < 768 }>: IsTrue, // 大括号里边是一个表达式, 返回一个bool. 当返回true的时候，也就是Assert<true>才实现了IsTrue.
{
    print_type_of(&val);
    //...
}

fn main() {
    check_size([0u8; 767]); // 数组在编译器已知长度
    check_size([0i32; 191]);
    check_size(["hello你好"; 47]); // &str is a string reference, containing a pointer and string length in it, so it takes two word long, in x86-64, 1 word = 8 bytes
    check_size([(); 31].map(|_| "hello你好".to_string()));  // String is a smart pointer struct, it has three fields: pointer, length and capacity, each takes 8 bytes
    check_size(['中'; 191]); // A char takes 4 bytes in Rust
}

pub enum Assert<const CHECK: bool> {} // 编译器能确定`const CHECK`的值

pub trait IsTrue {}

impl IsTrue for Assert<true> {}

fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}
```

## trait
在开发复杂系统的时候，常常会强调接口和实现要分离, 这是一种良好的设计习惯，它把调用者和实现者隔离开，双方只要按照接口开发，彼此就可以不受对方内部改动的影响. 接口就是这样, 是对不同数据结构中相同行为的一种抽象.

接口是一个软件系统开发的核心部分，它反映了系统的设计者对系统的抽象理解。作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性.

很多编程语言都有接口的概念，允许开发者面向接口设计，比如 Java/go 的 interface、Elixir 的 behaviour、Swift 的 protocol 和 Rust 的 trait.

当在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力. 在运行时，一旦使用了关于接口的引用，变量原本的类型被掩藏，此时需要一个胖指针获取这个引用具备什么样的能力, 即在生成这个引用的时候，需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表, 这个列表，就是熟知的虚表（virtual table）.

trait 同样也不是 Rust 独有的概念, 它借鉴了Haskell的Typeclass.

trait定义了一组类型可以选择性实现的`契约`或共享行为.

trait是在行为上对类型的约束即对类型行为的抽象, 是Rust实现零成本抽象的基石，它有如下机制：
- trait是Rust唯一的接口抽象方式
- 可以静态分发，也可以动态分发
- 可以当做标记类型拥有某些特定行为的"标签"来使用

rust没有传统面向对象编程语言中的继承概念. Rust通过 trait 将类型和行为明确地进行了区分, 充分贯彻了组合优于继承和面向接口编程的编程思想.

在 Rust 里, 数据的行为通过 trait 来定义. 一般用 impl  关键字为数据结构实现 trait, 但 Rust 贴心地提供了派生宏（derive macro）, 可以大大简化一些标准接口的定义. 比如`#[derive(Debug)]` 为数据结构实现了 Debug trait, 提供了 debug 能力，这样可以通过`{:?}/{:#?}`(后者会按字段换行, 适合更多字段的数据结构), 用`println!`打印出来.

> Clone / Copy trait: 约定了数据被深拷贝和浅拷贝的行为

> 和 Clone trait 不同的是，Copy trait 没有任何额外的方法，它只是一个标记 trait（marker trait）. Copy trait 虽然没有任何行为，但它可以用作 trait bound 来进行类型安全检查，所以管它叫标记 trait.

> Clone 让数据结构可以被复制，而 Copy 则让数据结构可以在参数传递的时候自动按字节拷贝.

>  Clone 类型的不可变引用转换为自有值(owned values)，即 &T -> T。Clone 没有对这种转换的效率做出承诺，所以它可能是缓慢和昂贵的。为了快速地在一个类型上实现 Clone, 可以使用派生宏.

> ToOwned 是 Clone 的一个更通用的版本. Clone 允许把一个 &T 变成一个 T，但 ToOwned 允许把一个 &Borrowed 变成一个 Owned，其中 `Owned: Borrow<Borrowed>`. 换句话说就是，不能把一个 &str 克隆成一个 String，或者把一个 &Path 克隆成一个 PathBuf，或者把一个 &OsStr 克隆成一个 OsString，因为 clone 方法签名不支持这种跨类型克隆，而这正是 ToOwned 的用途.

trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能. 可以通过 trait 以一种抽象的方式定义共享的行为. 可以使用 trait bounds 指定泛型是任何拥有特定行为的类型.

**rust支持trait的默认实现**: 有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的, 但明确定义该方法可覆盖其默认实现. 如果trait没有默认实现, 那么实现该trait的类型必须提供自己的实现.

> Clone 宏让数据结构可以被复制，而 Copy 则让数据结构可以在参数传递的时候自动按字节拷贝

```rust
// `<T: Debug>`表示有trait限定(trait bound)的泛型, 即只有实现了Debug trait的类型才适用. 只有实现了Debug trait的类型才拥有使用`{:?}`格式化打印的行为
fn match_opton<T: Debug>(o: Option<T>) {
    match o {
        ...
    }
}

struct Duck;
trait Fly {
    fn fly(&self) -> bool;
}
impl Fly for Duck{
    fn fly(&self) -> bool {
        return true;
    }
}
fn fly_static<T: Fly>(s: T) -> bool {
    s.fly()
}

fn fly_static(s: &Fly) -> bool {
    s.fly()
}

fn main(){
    let duck = Duck;
    fly_static::<Duck>(duck); // 静态分发, rust编译器会为`fly_static::<Duck>(duck)`这个具体类型的调用生成特殊化的代码. 即对编译器而言,该中抽象并不存在, 它在编译阶段即可将泛型展成具体类型的代码
    fly_dyn(&Duck) // 动态分发, 它会在运行时查找对应类型的方法, 需一定的运行时开销(很小). 与golang的接口类似
}
```

rust的trait符合c++之父提出的零开销原则: 如果不使用某个抽象, 就不用为它付出开销(静态分发); 如果确实需要使用该抽象, 可以保证这是开销最小的使用方式(动态分发).

trait 和 trait bound 让开发者使用泛型类型参数来减少重复，并仍然能够向编译器明确指定泛型类型需要拥有哪些行为. 因为向编译器提供了 trait bound 信息，它就可以检查代码中所用到的具体类型是否提供了正确的行为. 在动态类型语言中，如果尝试调用一个类型并没有实现的方法，会在运行时出现错误. Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复错误. 另外，开发者也无需编写运行时检查行为的代码，因为在编译时就已经检查过了，这样相比其他那些不愿放弃泛型灵活性的语言有更好的性能.

> 使用 async_trait(含有 async fn 的 trait) 的代价是每次调用会发生额外的堆内存分配，但绝大多数应用场景下，这并不会有性能上的问题.

从语义上来说, trait 是在行为上对类型的约束, 这种约束可以让 trait 有如下4种用法:
1. 接口抽象: 接口是对类型行为的统一约束

	接口抽象特点:
	- 接口中定义方法, 并支持默认实现
    - 接口中不能实现另一个接口, 但是接口间可以继承
    - 同一个接口可以同时被多个类型实现, 但不能被同一个类型实现多次
    - 使用trait关键字来定义接口
    - 使用impl关键字为类型实现接口方法

    ## 关联类型
    关联类型（associated types）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型. trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型.
    **rust很多操作符都是基于trait来实现的.**, 比如加法操作符:
    ```rust
    // 特型 Add<T> 代表给自己的类型加上一个 T 值的能力
    pub trait Add<RHS = Self> { // `Add<RHS = Self>`表示参数类型RHS默认为Self, Self是每个trait都带有的隐式类型参数, 代表实现当前trait的具体类型. 因此RHS也可以是其他类型
        type Output; // 关联类型. Output是一个占位类型, trait的实现者会指定 Output的具体类型.
        fn add(self, rhs: RHS) -> Self::Output;
    }

    1+2 // =>`1.add(2)` 代码中出现`+`时, rust就会自动调用操作符左侧的操作数对应的add()方法去实现具体的操作, 即`+`操作与调用`add()`等价.
    // 可看rust源码为u32实现的Add trait(用宏完成的).
    ```

    > RHS 是 Right Hand Side（右手边）的简写形式.

    > 在 Rust 中, 表达式 lhs * rhs 是 Mul::mul(lhs, rhs) 的简写形式

    在语义层面上, 使用关联类型增强了trait表示行为的语义, 因为它表示了和某个行为(trait)相关联的类型. 在工程上, 也体现出了高内聚的特点.

    ```rust
    // 泛型 trait Add可以在需要的时候，对同一种类型的同一个 trait，有多个实现
    use std::ops::Add;

    #[derive(Debug)]
    struct Complex {
        real: f64,
        imagine: f64,
    }

    impl Complex {
        pub fn new(real: f64, imagine: f64) -> Self {
            Self { real, imagine }
        }
    }

    // 对 Complex 类型的实现
    impl Add for Complex {
        type Output = Self;

        // 注意 add 第一个参数是 self，会移动所有权
        fn add(self, rhs: Self) -> Self::Output {
            let real = self.real + rhs.real;
            let imagine = self.imagine + rhs.imagine;
            Self::new(real, imagine)
        }
    }

    // 如果不想移动所有权，可以为 &Complex 实现 add，这样可以做 &c1 + &c2
    impl Add for &Complex {
        // 注意返回值不应该是 Self 了，因为此时 Self 是 &Complex
        type Output = Complex;

        fn add(self, rhs: Self) -> Self::Output {
            let real = self.real + rhs.real;
            let imagine = self.imagine + rhs.imagine;
            Complex::new(real, imagine)
        }
    }

    // 因为 Add<Rhs = Self> 是个泛型 trait，我们可以为 Complex 实现 Add<f64>
    impl Add<f64> for &Complex {
        type Output = Complex;

        // rhs 现在是 f64 了
        fn add(self, rhs: f64) -> Self::Output {
            let real = self.real + rhs;
            Complex::new(real, self.imagine)
        }
    }

    fn main() {
        let c1 = Complex::new(1.0, 1f64);
        let c2 = Complex::new(2 as f64, 3.0);
        println!("{:?}", &c1 + &c2);
        println!("{:?}", &c1 + 5.0);
        println!("{:?}", c1 + c2);
    }
    ```

    [tower::Service](https://docs.rs/tower/0.4.13/tower/trait.Service.html)是一个第三方库，它定义了一个精巧的用于处理请求，返回响应的经典 trait.

    这个 trait 允许某个 Service 能处理多个不同的 Request. 在 Web 开发中使用该 trait 的话，每个 Method+URL 可以定义为一个 Service，其 Request 是输入类型.
    ```rust
    pub trait Service<Request> {
        type Response;
        type Error;
        type Future: Future // Future 类型受 Future trait 约束
        where
            <Self::Future as Future>::Output == Result<Self::Response, Self::Error>;

        fn poll_ready(
            &mut self, 
            cx: &mut Context<'_>
        ) -> Poll<Result<(), Self::Error>>;
        fn call(&mut self, req: Request) -> Self::Future;
    }
    ```

    ## trait一致性
    孤儿原则(Orphan Rule): trait 和实现 trait 的数据类型，至少有一个是在当前 crate 中定义的，也就是说，你不能为第三方的类型实现第三方的 trait. 该规则同样可理解为impl块要么与trait的声明在同一个crate中, 要么与类型的声明在同一个crate中. 其可限制代码被破坏性改写, 导致出现难以预料的bug.

    同理匿名impl必须与类型本身在同一个crate中.

    ## trait继承
    rust不支持传统面向对象的继承, 但支持trait继承. 子 trait 可以继承父 trait 中定义或实现的方法.

    比如 trait B: A ，是说任何类型 T，如果实现了 trait B，它也必须实现 trait A. 即trait B 在定义时可以使用 trait A 中的关联类型和方法。

    ```rust
    trait Paginatge: Page + PerPage { // 用冒号表示继承其他trait.
        ...
    }
    impl <T: Page + PerPage>Paginate for T{

    }
    ```
1. 泛型约束: 泛型行为被 trait 限定在更有限的范围内

	> Rust 编程的哲学是组合优于继承.

	trait限定(trait bound) : 泛型的行为被trait限定在更有限的范围内, 多个trait限定用`+`连接.

	impl Trait 实际上是一种较长形式语法的`trait bound`语法糖, 它作为返回值形参时只能返回同一种类型.

    ```rust
    fn notify(item: impl Summary + Display) // 使用 impl 特征语法`impl Summary + Display`
    fn notify<T: Summary + Display>(item: T) // 等价于同上, trait bound形式

    fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U)
    fn some_function<T, U>(t: T, u: U) -> i32 // 等价于同上
    where T: Display + Clone,
          U: Clone + Debug
    ```

    ```rust
    use std::fmt::Debug;
    fn dump<I>(iter: I)
        where I: Iterator, I::Item: Debug // =  I: Iterator<Item=String>
    {
        ...
    }
    ```

    ```rust
    use std::ops::Add;
    // 表示sum函数的参数必须实现Add trait
    fn sum<T: Add<T, Output=T>>(a: T, b:T) -> T{ // Add<T, Output=T>: Add表示和T类型相加, 并将产生T类型作为输出即输入输出具有相同类型. T 是实现此特征的类型别名
        a+b
    }
    fn foo<T, K, R>(a: T, b:K, c:R) where T: A, K:B+C, R:D {...}// where用于为泛型增加较多的trait限定, 提高代码可读性.

    #[derive(Default, Debug, PartialEq, Copy, Clone)]
    struct Complex<T> {
        //实部
        re: T,
        //虚部
        im: T
    }
    impl<T> Complex<T> {
        fn new(re: T, im: T) -> Self {
            Complex { re, im }
        }
    }

    impl<T: Add<T, Output=T>> Add for Complex<T> { // T:Add 表示必须实现 Add trait. 如果没有实现, 那么无法对`T`使用`+`运算符
        type Output = Complex<T>;
        fn add(self, rhs: Complex<T>) -> Self::Output {
            Complex { re: self.re + rhs.re, im: self.im + rhs.im }
        }
    }

    let a = Complex::new(1,-2);
    let b = Complex::default();
    let res = a + b;
    ```

    类型上的泛型约束:
    ```rust
    use std::fmt::Display;
    struct Foo<T: Display> {
        bar: T
    }

    struct Bar<F> where F: Display {
        inner: F
    }
    ```

    有条件实现方法:
	```rust
	struct A<T> {}

	impl<T: B + C> A<T> { // 声明了 A<T> 类型必须在 T 已经实现 B 和 C 特性的前提下才能有效实现此 impl 块
	    fn d(&self) {}
	}
	```

    不推荐在类型上使用泛型约束， 因为它对类型自身施加了限制. 通常, 希望类型尽可能是泛型，从而允许使用任何类型创建实例.

    trait限定给予了开发者更大的自由度, 因为不再需要类型间的继承, 也简化了编译器的检查操作. 包含trait限定的泛型属于**静态分发**, 在编译期通过单态化分别生成具体类型的实例, 所以调用trait限定中的方法也都是运行时零成本的, 因为不需要在运行时再进行方法查找.

    通过使用带有 trait bound 的泛型参数的 impl 块，可以有条件地只为那些实现了特定 trait 的类型实现方法:
    ```rust
    use std::fmt::Display;

    struct Pair<T> {
        x: T,
        y: T,
    }

    impl<T> Pair<T> {
        fn new(x: T, y: T) -> Self {
            Self {
                x,
                y,
            }
        }
    }

    impl<T: Display + PartialOrd> Pair<T> {
        fn cmp_display(&self) {
            if self.x >= self.y {
                println!("The largest member is x = {}", self.x);
            } else {
                println!("The largest member is y = {}", self.y);
            }
        }
    }
    ```

    对任何满足特定 trait bound 的类型实现 trait 被称为覆盖实现(blanket implementations), 它们被广泛的用于 Rust 标准库中. 例如，标准库为任何实现了 Display trait 的类型实现了 ToString trait: `impl<T: Display> ToString for T {}`.
1. 抽象类型: 在运行时作为一种间接的抽象类型去使用, 动态地分发给具体的类型

	对于抽象类型而言, 编译器可能无法确定其确切的功能和所占的空间大小, 所以 Rust目前有两种方法来处理抽象类型: trait 对象和 impl Trait.

	```rust
	pub fn trait_object() {
	    #[derive(Debug)]
	    struct Foo;
	    trait Bar {
	        fn baz(&self);
	    }
	    impl Bar for Foo {
	        fn baz(&self) { println!("{:?}", self) }
	    }
	    fn static_dispatch<T>(t: &T) where T:Bar {
	        t.baz();
	    }
	    fn dynamic_dispatch(t: &Bar) {
	        t.baz();
	    }
	    let foo = Foo;
	    static_dispatch(&foo);
	    dynamic_dispatch(&foo);
	}
	```

	TraitObject 包括两个指针: data 指针和vtabl 指针. data指针指向 trait 对象保存的类型数据T, vtable指针指向包含为T实现的 Trait的Vtable(Virtual Table虚表). 虚表本质是一个结构体, 包含了析构函数 、大小、对齐和方法等信息.

	TraitObject根据虚表指针从虚表中查出正确的指针, 然后再进行动态调用, 这也是将 trait 对象称为动态分发的原因.

	并不是每个 trait 都可以作为 trait 对象被使用，这依旧和类型大小是否确定有关系. 每个trait 都包含一个隐式的类型参数 Self, 代表实现 trait 的类型, 其默认有一个隐式的trait限定`?Sized`, 表示任意大小的类型. rust 中大部分类型都默认是可确定大小的类型即`<T: Sized>`, 这也是泛型代码可以正常编译的原因.

	trait 对象在运行期进行动态分发时, 也必须确定大小, 否则无法为其正确分配内存空间. 所以必须同时满足以下两条规则的 trait 才可作为 trait 对象使用:
	1. trait 的Sefl类型参数不能被限定为Sized

		trait 对象本身是动态分发的, 编译期根本无法确定Self具体是哪个类型.
	1. trait 中所有的方法都必须是对象安全的

		对象安全的本质就是为了让 trait 对象可以安全地调用相应的方法.

		对象安全的方法必须满足以下3点之一:
		1. 方法受 `Self:Sized` 约束
		1. 方法签名同时满足以下3点:
			1. 必须不包含任何泛型参数. 如果包含泛型 trait对象在Vtable中查找方法时将不确定该调用哪个方法
			1. 第一个参数必须为 Self 类型或可以解引用为 Self 的类型

				也就是说, 必须有接收者, 比如`self, &self, ＆mut self, self:Box<Self>`, 没有接收者的方法对trait 对象来说毫无意义.
			1. Self 不能出现在除第一个参数之外的地, 包括返回值中.

				这是因为如果出现 Self,就意味着`Self和self, &self和&mut self`的类型相匹配. 但是对于 trait 对象来说, 根本无法做到保证类型匹配, 因此这种情况下的方法是对象不安全的.

			这三点可总结为一句 ：没有额外 Self 类型参数的非泛型成员方法.
		1. trait 不能包含关联常量(Associated Constant). 但从Rust 2018开始 trait 中可以增加默认的关联常量了.

	满足这两条规则的 trait 就是对象安全的 trait.

	在Rust 2018 入了可静态分发的抽象类型 impl Trait. 如果说 trait 对象是装箱抽象类型（Boxed Abstract Type ）, 那 impl Trait 就是拆箱抽象类型(Unboxed Abstract Type).

	> “装箱”代表将值托管到堆内, 而“拆箱” 是在栈内存中生成新的值. 总之，装箱抽象类型代表动态分发，拆箱抽象类型代表静态分发.

	目前 impl Trait 只可以在输入的参敬和返回值这两个位置使用.

    使用特征作为函数返回值时, 里面的`if...else`应该返回相关的类型, 否则使用`Box<dyn xxx>`.

	```rust
	pub fn impl_trait(){
	    use std::fmt::Debug;
	    pub trait Fly {
	        fn fly(&self) -> bool;
	    }
	    #[derive(Debug)]
	    struct Duck;
	    #[derive(Debug)]
	    struct Pig;
	    impl Fly for Duck {
	        fn fly(&self) -> bool {
	            return true;
	        }
	    }
	    impl Fly for Pig {
	        fn fly(&self) -> bool {
	            return false;
	        }
	    }
	    fn fly_static(s: impl Fly+Debug) -> bool {
	        s.fly()
	    }
	    fn can_fly(s: impl Fly+Debug) -> impl Fly {
	        if s.fly(){
	            println!("{:?} can fly", s);
	        }else{
	            println!("{:?} can't fly", s);
	        }
	        s
	    }
	    fn dyn_can_fly(s: impl Fly+Debug+'static) -> Box<dyn Fly> { // ’static 是一种生命周期参数. 它限定了 impl Fly+Debug 抽象类型不可能是引用类型，因为这里出现引用类型可能会引发内存不安全
	        if s.fly(){
	            println!("{:?} can fly", s);
	        }else{
	            println!("{:?} can't fly", s);
	        }
	        Box::new(s)
	    }
	    let pig = Pig;
	    assert_eq!(fly_static(pig), false);
	    let duck = Duck;
	    assert_eq!(fly_static(duck), true);

	    let pig = Pig;
	    can_fly(pig);
	    let duck = Duck;
	    can_fly(duck);

	    let duck = Duck;
	    dyn_can_fly(duck);
	}
	```

	将impl Trait 用于返回值位置的时候，实际上等价于给返回类型增加一种 trait 限定范围.

	Rust 2018 版本中，为了在语义上和 impl Trait 语法相对应, 专门为动态分发的 trait对象增加了 dyn Trait. impl Trait 表静态分发, dyn Trait 代表动态分发.

    ```rust
    trait Draw {
        fn draw(&self) -> String;
    }

    impl Draw for u8 {
        fn draw(&self) -> String {
            format!("u8: {}", *self)
        }
    }

    impl Draw for f64 {
        fn draw(&self) -> String {
            format!("f64: {}", *self)
        }
    }

    fn main() {
        let x = 1.1f64;
        let y = 8u8;

        // draw x
        draw_with_box(Box::new(x));

        // draw y
        draw_with_ref(&y);
    }

    fn draw_with_box(x: Box<dyn Draw>) {
        x.draw();
    }

    fn draw_with_ref(x: &dyn Draw) {
        x.draw();
    }
    ```
1. 标签 trait. 对类型的约束, 可以直接作为一种`标签`使用

	对类型的约束, 即直接作为一种"标签"使用.

	Rust 一共提供了5个重要的标签 trait, 都被定义在标准库 std::marker 模块中. 它们分别是：
	- Sized trait: 用来标识编译期可确定大小的类型

        在使用泛型参数时，Rust 编译器会自动为泛型参数加上 Sized 约束.

		目前 Rust 中的动态类型有 trait和[T], 其中[T]代表一定数量的T在内存中依次排列，但不知道具体的数量

	- Unsize trait: 目前该 trait 为实验特性，用于标识动态大小类型(DST)
	- Copy trait: 用来标识 以按位复制其值的类型

		Copy trait 用来标记可以按位复制其值的类型, 按位复制等价于C语言中的 memcpy.

		Clone trait 继承自 Sized时，意味着要实现 Clone trait 对象必须是 Sized 类型. 其默认实现是调用 clone 方法, 因此想让一个类型实现 Copy trait, 就必须同时实现 Clone trait.

		Rust 很多基本数据类型实现了 Copy trait ，比如常用的数字类型、字符（ har ）、布尔类型、单元值、不可变引用等.

		检测类型是否实现了 Copy trait:
		```rust
		fn test_copy<T:Copy>(i: T){
			println!("test")
		}
		```

		Copy 的行为是一个隐式的行为, 开发者不能重载 Copy 行为, 它永远都是一个简单的位复制. Copy 隐式行为发生在执行变量绑定、函数参数传递、函数返回等场景中，因为这些场景是开发者无法控制的，所以需要编译器来保证.

		Clone trait 是一个显式的行为，任何类型都可以实现 Clone trait ，开发者可以自由地按需实现 Copy 行为.

		并非所有类型都可以实现 Copy trait 对于自定义类型来说，必须让所有的成员都实现Copy trait, 这个类型才有资格实现Copy trait. 如果是数组类型, 且其内部元素都是Copy类型, 则数组本身就是 Copy 类型；如果是元组类型，且其内部元素都是Copy 类型，则该元组会自动实现 Copy; 如果是结构体或枚举类型, 只有当每个内 部成员都实 Copy时, 它才可以 Copy ，并不会像元组那样自动实 Copy.

	- Send trait: 用来标识可以跨线程安全通信的类型

		实现了 Send 类型, 可以安全地在线程间传递值, 也就是说可跨线程传递所有权
	- Sync trait: 用来标识可以在线程 安全共享 引用的类型

		实现了 Sync 类型， 可以跨线程安全 传递共享（ 不可变）引用.

        一个类型 T 满足 Sync trait，当且仅当 &T 满足 Send trait.

	除此之外， ust 标准库还在增加新的标签 trait 以满足变化的需求.

	Rust 提供了 Send, Sync 两个标签 trait, 它们是 Rust 无数据竞争并发的基石.

	Rust 把所有类型归为两类：可以安全跨线程传递的值和引用, 以及不可以跨线程传递的值和引用. 再配合所有权机制, 因此Rust够在编译期就检查出数据竞争的隐患, 而不是等到运行时再排查.

	Send, Sync 标签 trait和前面所说的 Copy,Sized 一样, 内部没有具体的方法实现, 它们仅仅是标记.

    标准库中，不支持 Send / Sync 的数据结构主要有:
    - `裸指针 *const T / *mut T`: 它们是不安全的，所以既不是 Send 也不是 Sync
    - UnsafeCell<T> 不支持 Sync. 也就是说，任何使用了 Cell 或者 RefCell 的数据结构不支持 Sync
    - 引用计数 Rc 不支持 Send 也不支持 Sync。所以 Rc 无法跨线程

    > Rust 中另一个常见的非固定大小类型是对特型目标的引用. Rust 不能在变量中存储非固定大小的值，也不能将它们作为参数传递, 比如只能通过 &str 或 Box<Write> 这样本身是固定大小的指针来使用它们.

    `?Sized`表示不一定是 Sized.
    动态大小类型不能随意使用，还需要遵循如下3条限制规则：
	1. 只可以通过胖指针来操作 Unsize 类型 ，比如`&[T]或&Trait`
	1. 变量、参数和 枚举变量不能使用动态大小类型
	1. 结构体中只有最后一个字段可以使用动态大小类型, 其他字段不可以使用.

	所以当使用`?Sized`限定时, 应该想想这3条规则.


rust规定函数在参数传递, 返回值传递中类型必须是编译阶段可确定大小的, 而trait的大小在编译时是不固定的, 因此它无法作为实例变量, 参数, 返回值, 这与go的interface不同.

Rust 同一个类可以实现多个特性，每个 impl 块只能实现一个.

默认trait: 接口只能规范方法而不能定义方法，但特性可以定义方法作为默认方法，因为是"默认"，所以对象既可以重新定义方法，也可以不重新定义方法使用默认的方法. 这是trait与接口的不同点

### trait不足
trait 不足主要包括以下三点:
1. 孤儿规则的局限性

	对于下游的子crate 来说，如果想要避免孤儿规则的影响，还必须使用NewType模式或者其他方式将远程类型包装为本地类型.

	可在类型定义上方标识了`#[fundamental]`, 该属性的作用就是告诉编译器, 其享有“特权”, 不必遵循孤儿规则.
1. 代码复用的效率不高

	Rust 还遵循另外一条规则, 重叠(Overlap)规则 : 该规则规定了不能为重叠的类型实现同一个trait.

	为了缓解重叠规则带来的问题， Rus 引入了特化Specialization. 特化功能暂时只能用于 impl 实现，所以也称为 impl 特化.
1. 抽象表达能力有待改进

	选代器在 Rust 中应用广泛，但是它目前有一个缺陷：在迭代元 的时候，只能接值进行迭代，有的时候必须重新分配数据，而不能通过引用来复用原始的数据.

	为了解决这个问题，就必须允许法代器支持引用类型。只有支持引用类型，才可以重用内部缓存区，而不需要重新分配新的内存. 所以，就必须实现一种更高级别的类型多态性即泛型关联类型 Generic Associated Type, GAT).

### 常见trait
- std::ops 模块的 Add : 允许使用`+`运算符将两个复数相加。
- std::convert 模块的 Into 和 From : 使用户能够根据其他类型创建复数类型。

    **From 和 Into 是配对的**，只要实现了前者，那后者就会自动被实现：只要实现了 impl From<T> for U， 就可以使用以下两个方法: let u: U = U::from(T) 和 let u:U = T.into()，前者由 From 特征提供，而后者由自动实现的 Into 特征提供. 同时使用 into 时，需要进行显式地类型标注，因为编译器很可能无法推导出所需的类型.

    当执行错误处理时，为自定义的错误类型实现 From 特征是非常有用。这样就可以通过 ? 自动将某个错误类型转换自定义的错误类型:
    ```rust
    use std::fs;
    use std::io;
    use std::num;

    enum CliError {
        IoError(io::Error),
        ParseError(num::ParseIntError),
    }

    impl From<io::Error> for CliError {
        fn from(error: io::Error) -> Self {
            CliError::IoError(error)
        }
    }

    impl From<num::ParseIntError> for CliError {
        fn from(error: num::ParseIntError) -> Self {
            CliError::ParseError(error)
        }
    }

    fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {
        // ? automatically converts io::Error to CliError
        let contents = fs::read_to_string(&file_name)?;
        // num::ParseIntError -> CliError
        let num: i32 = contents.trim().parse()?;
        Ok(num)
    }

    fn main() {
        println!("Success!")
    }
    ```

    类似于 From 和 Into, TryFrom 和 TryInto 也是用于类型转换的泛型特征. 但TryFrom 和 TryInto 可以对转换后的失败进行处理，然后返回一个 Result.

- Display : 使用户能够输出人类可读版本的复数类型

     Debug和Display定义相同, 但Debug 是为开发者调试打印数据结构所设计的，而 Display 是给用户显示数据结构所设计的. 这也是为什么 Debug trait 的实现可以通过派生宏直接生成，而 Display 必须手工实现.
- Default: 为类型提供缺省值

Rust 标准库针对输入和输出的特性是通过 3 个特型，即 Read、BufRead 和 Write, 见[字符串操作 - 《Rust程序设计 - 18 输入与输出》]()

## 类型转换
在 Rust 中, 将一个值从一种类型转换为另一种类型通常需要显式转换. 类型转换使用 as.

Rust中的隐式类型转换基本上只有自动解引用. 自动解引用的目的主要是方便开发者使用智能指针. 自动解引用虽然是编译器来做的，但自动解引用的行为可以由开发者来定义.

不过，有些涉及引用类型的转换非常简单直接，根本不需要显式进行:
- 把一个 mut 引用转换为非 mut 引用
- &String 类型的值会自动转换为 &str 类型
- &Vec<i32> 类型的值会自动转换为 &[i32]
- &Box<Chessboard> 类型的值会自动转换为 &Chessboard

上述的后3种转换被称为“解引用强制转换”（deref coercion），因为它们适应于实现了内置的 Deref特型的类型。比如`&Box<Chessboard>`解引用强制转换的目的是让 Box 这种智能指针类型看起来尽可能像它后面的值.

Deref 包含关联类型 Target, 它表示解引用之后的目标类型. 实现 Deref 的目的只有一个, 就是简化编程.

手动解引用: 当某类型和其解引用目标类型中包含了相同的方法时需要开发者明确指明.

## as
as 操作符最常用的场景就是转换 Rust 中的基本数据类型. as 不支持重载.

无歧义完全限定语法(Full Qualified Syntax for Disambiguation):
```rust
pub fn fqsfd(){
    struct S(i32);
    trait A {
        fn test(&self, i: i32);
    }
    trait B {
        fn test(&self, i: i32);
    }
    impl A for S {
        fn test(&self, i: i32) {
            println!("From A: {:?}", i);
        }
    }
    impl B for S {
        fn test(&self, i: i32) {
            println!("From B: {:?}", i+1);
        }
    }

    let s = S(1);
    A::test(&s, 1);
    B::test(&s, 1);
    <S as A>::test(&s, 1); // 无歧义完全限定语法
    <S as B>::test(&s, 1);
}
```

as 转换还可用于类型和子类型之间的转换. Rust中没有标准定义中的子类型, 比如结构体继承之类的, 但是生命周期标记可看作子类型, 比如`＆' static str` 是`&a str`的子类型:
```rust
let  a: &'static str  = "hello";  // &'static str
let  b: &str = a as &str; // &str
let  c: &'static str = b as &'static str; // &'static str
```

### From和Into
From Into 是定义于 std::convert 模块中的两个 trait. 它们定义了 from和into 两个方法, 这两方法互为反操作.

关于 Into 有一条默认的规则: 如果类型U实现了 `From<T>`, 则T类型实例调用 into方法就可以转换为类型U. 这是因为 Rust 标准库内部有一个默认的实现.

在标准库中 还包含了 TryFrom和TryInto 两种 trait, 是 From和Into的错误处理版本, 因为类型转换是有可能发生错误的，所以在需要进行错误处理的时候可以使用它们.

标准库中还包含了 AsRef和AsMut 两种 rait, 可以将值分别转换为不可变引用和可变引用. AsRef和标准库的另外一个Borrow trait 功能有些类似，但 AsRef 更轻量级, 
它只是简单地将值转换为引用, 而 Borrow trait 可以用来将某个复合类型抽象为拥有借用语义的类型.

对值类型的转换和对引用类型的转换，Rust 提供了两套不同的 trait:
1. 值类型到值类型的转换：`From<T> / Into<T> / TryFrom <T>/ TryInto<T>`
1. 引用类型到引用类型的转换：`AsRef<T> / AsMut<T>`

    - AsRef 用于从一个类型向另一个类型提供引用

## 流程控制
主流编程语言都会有常用的流程控制语句:条件语句和循环语句. Rust也有但叫做流程控制表达式.

满足某个条件时会跳转, Rust 支持
- 分支跳转: `if/else`
- 模式匹配: Rust 的模式匹配可以通过匹配表达式或者值的某部分的内容，来进行分支跳转
	
	需要根据表达式**所有可能**的值进行匹配, 并进行相应的处理.

	`match expr {}`或`if let pat = expr {}`. `if let`是match的简写, 表示仅关心一种模式匹配的情况而忽略其他情况, 不加`else{}`分支时即放弃了穷举可能性.

	Rust 的模式匹配吸取了函数式编程语言的优点，强大优雅且效率很高. 它可以用于 struct / enum 中匹配部分或者全部内容. 同时match必须返回相同的类型.

	```rust
	use std::str::FromStr;
	/// 解析字符串s，格式为一对坐标值，如"400x600"或"1.0,0.5"
	///
	/// 特别地， s的格式应该是"<左值><分隔符><右值>"的形式，其中<分隔符>
	/// 就是separator参数传入的字符，而<左值>和<右值>都是字符串，可以通过
	/// T::from_str来解析
	///
	/// 如果s的格式没错，就返回Some<(x, y)>。如果解析出错，则返回None
	fn parse_pair<T: FromStr>(s: &str, separator: char) -> Option<(T, T)> {
		match s.find(separator) {
			None => None,
			Some(index) => {
				match (T::from_str(&s[..index]), T::from_str(&s[index + 1..])) {
					(Ok(l), Ok(r)) => Some((l, r)),
					_ => None
				}
			}
		}
	}

	#[test]
	fn test_parse_pair() {
		assert_eq!(parse_pair::<i32>(",10", ','), None);
		assert_eq!(parse_pair::<i32>("10,20", ','), Some((10, 20)));
		assert_eq!(parse_pair::<f64>("0.5x1.5", 'x'), Some((0.5, 1.5)));
	}
	```

	```rust
	match balloon.location {
		Point { x: 0, y: height } => // 匹配x=0的情况, 不能放在`Point { x: x, y: y }`后避免`unreachable pattern`
			println!("straight up {} meters", height),
		Point { x: x, y: y } =>
			println!("at ({}m, {}m)", x, y)
	}
	```

    ```rust
    fn match_colours(rbg: (i32, i32, i32)) {
        match rbg {
            (r, _, _) if r < 10 => println!("Not much red"),
            (_, b, _) if b < 10 => println!("Not much blue"),
            (_, _, g) if g < 10 => println!("Not much green"),
            _ => println!("Each colour has at least 10"),
        }
    }

    fn main() {
        let first = (200, 0, 0);
        let second = (50, 50, 50);
        let third = (200, 50, 0);

        match_colours(first);
        match_colours(second);
        match_colours(third);

    }
    ```

    用@给match的表达式的值起一个名字即将一个与模式相匹配的值绑定到新的变量上，然后就可以使用它:
    ```rust
    fn match_number(input: i32) {
        match input {
        number @ 4 => println!("{} is an unlucky number in China (sounds close to 死)!", number),
        number @ 13 => println!("{} is unlucky in North America, lucky in Italy! In bocca al lupo!", number),
        _ => println!("Looks like a normal number"),
        }
    }

    fn main() {
        match_number(50);
        match_number(13);
        match_number(4);
    }

    enum Message {
        Hello { id: i32 },
    }

    fn main() {
        let msg = Message::Hello { id: 5 };

        match msg {
            Message::Hello {
                id:  id@3..=7,
            } => println!("id 值的范围在 [3, 7] 之间: {}", id),
            Message::Hello { id: newid@(10 | 11 | 12) } => { // @后的括号不能丢
                println!("id 值的范围在 [10, 12] 之间: {}", newid)
            }
            Message::Hello { id } => println!("Found some other id: {}", id),
        }
    }
    ```

    ```rust
    enum MyEnum {
        Foo,
        Bar
    }

    fn main() {
        let mut count = 0;

        let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
        for e in v {
            if matches!(e , MyEnum::Foo) { // 使用`if e == MyEnum::Foo`报错: an implementation of `PartialEq` might be missing for `MyEnum`. 其他解决方法: 为MyEnum添加`#[derive(PartialEq)]`. enum比较需要实现PartialEq的原因: enum的值不像c那样都是整数, 比如[如何理解PartialEq过程宏 for enum的实现 ？](https://rustcc.cn/article?id=1bad1c3c-03e0-437a-b90f-e0793d7023b2)
                count += 1;
            }
        }

        assert_eq!(count, 2);
    }
    ```

- 错误跳转: 在错误跳转中，当调用的函数返回错误时，Rust 会提前终止当前函数的执行，向上一层返回错误

	`expr?`, 比如`fs::write("/tmp/1.log", b"hello")?;`

	```rust
	let output = File::create(filename)?;
	// 同上
	let output = match File::create(filename) {
		Ok(f) => f
		Err(e) => return Err(e)
	};
	```
- 异步跳转: 在 Rust 的异步跳转中, 当 async 函数执行 await 时, 程序当前上下文可能被阻塞, 执行流程会跳转到另一个异步任务执行, 直至 await 不再阻塞.

	`expr.await`, 比如`socket.write(data).await?`

Rust 编译器使用流敏感（flow-sensitive）分析控制流:
- Rust 检查贯穿函数的每条路径，确保返回值为正确类型。为了正确地完成这个检查， 它需要知道是否可能到达函数末尾。
- Rust检查局部变量永远不会在未始终化时被使用。因此必须检查贯穿函数的每一条路径，以确保不会抵达一个变量尚未经过初始化就被使用的地方。
- Rust 会对无法抵达的代码给出警告。如果贯穿函数的路径没有一条能抵达， 那么相应的代码就是无法抵达的

在强制执行这些规则时，语言必须在简单（simplicity）和机巧（cleverness）之间取得平衡。前者可以让程序员有时候更容易明白编译器在说什么，后者有助于减少误报及避免拒
绝实际上非常安全的程序。 Rust 追求简单，其流敏感分析压根不会检查循环条件，而只是假设程序中的任何条件不是 true 就是 false, 因此下述代码会报错:
```rust
fn wait_for_process(process: &mut Process) -> i32 {
	while true {
		if process.wait() {
			return process.exit_code();
		}
	}
} // 错误：并非所有控制路径都返回值
```

而loop 表达式就是作为解决这个问题的“心口如一”的方案给出的.

如果把这个规则强加给以 break 或 return 表达式结尾的块、无穷 loop、对 panic!()或 std::process::exit() 的调用，则是不明智的。这些表达式共有的特点是它们都不以
惯常的方式结束，不返回值. 因此在 Rust 中，这些表达式没有常规的类型。不正常结束的表达式通常被指定为特殊类型 !(!表示永远也不会返回, 即它是一个发散函数（divergent function）)，它们不受其他类型需要遵从的规则的约束.

### 条件表达式
表达式一定会有值, 所以if表达式的分支必须返回同一个类型的值才可以. if表达式的求值规 和块表达式一致.

代码中的条件表达式必须产生一个bool类型的值，否则就会触发编译错误. 不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值.

变量绑定支持if表达式. `if ... else if ... else`: `let x = if condition {} else {}`. 这也是Rust没有三元操作符`?:`的原因.

### 循环表达式
Rust 的循环和大部分语言都一致, 支持死循环`loop {}`、条件循环`while expr {}/while let pattern = expr{}`，以及对迭代器的循环`for x in iter {}`. 循环可以通过 break 提前终止，或者 continue 来跳到下一轮循环.

```rust
fn fib_loop(n: u8) {
    let mut a = 1;
    let mut b = 1;
    let mut i = 2u8;
    
    loop {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
        
        if i >= n {
            break;
        }
    }
}

fn fib_while(n: u8) {
    let (mut a, mut b, mut i) = (1, 1, 2);
    
    while i < n {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
    }
}

fn fib_for(n: u8) {
    let (mut a, mut b) = (1, 1);
    
    for _i in 2..n {
        let c = a + b;
        a = b;
        b = c;
        println!("next val is {}", b);
    }
}

fn main() {
    let n = 10;
    fib_loop(n);
    fib_while(n);
    fib_for(n);
}
```

rust break还能返回值:
```rust
fn main() {
    let mut counter = 5;
    let my_number = loop {
        counter +=1;
        if counter % 53 == 3 {
            break counter;
        }
    };
    println!("{}", my_number);
}
```

> 在 C 语言中 for 循环使用三元语句控制循环，但是 Rust 中没有这种用法，需要用 while 循环来代替. 且没有 do-while 的用法(do 被规定为保留字)

> loop 循环可以通过 break 关键字类似于 return 一样使整个循环退出并给予外部一个返回值.

> 可在loop/while/for 循环前面加上`生命周期标识符`(该标识符以单引号开头), 其在内部的循环中可以使用 break/continue 语句来选择跳出到哪一层.

> 如果一个 loop 永远不返回，那么它的类型就是“发散类型”. 编译器可以判断出发散类型, 其后代码是永远不会执行的死代码.

> `loop{}`和`while true{}` 循环有何区别, 为什么 Rust 设计了loop, 难道不是完全多余的吗？实际上不是, 主要原因在于, 相比于其他的许多语言, Rust 要做更多的静态分析. 它俩在运行时是没有什么区别, 它们主要是会影响编译器内部的静态分析. `let x; loop { x = 1; break; }`可以执行, `let x; while true { x = 1; break ; }`会报错, 因为编译器认为while语句的执行跟条件表达式在运行阶段的值有关, 因此不确定x是否一定会初始化而报错. 本质是Rust编译器在对while循环做流分析(Flow Sensitive ）时, 不会检查循环
条件, 编译器会认为 while 循环条件可真可假，所以循环体里的表达式也会被忽略. 这一切都是因为 CTFE 功能的限制, while达式无法作为编译器常量来使用, 同理`if true`在只有一条分支的情况下 ，也会发生类情况.

> for 循环的主要用处是利用迭代器对包含同样类型的多个元素的容器执行遍历，如数组,链表,HashMap,HashSet等.

Rust 的 for 循环可以用于任何实现了  IntoIterator trait 的数据结构(它可以把数据结构的所有权转移到 Iterator 中). 在执行过程中，IntoIterator 会生成一个迭代器，for 循环不断从迭代器中取值，直到迭代器返回 None 为止。因而，**for 循环实际上只是一个语法糖，编译器会将其展开使用 loop 循环对迭代器进行循环访问，直至返回 None**

通过斐波那契数列, 使用 if 和 loop / while / for 这几种循环，来实现程序的基本控制流程:
```rust

fn fib_loop(n: u8) {
    let mut a = 1;
    let mut b = 1;
    let mut i = 2u8;
    
    loop {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
        
        if i >= n {
            break;
        }
    }
}

fn fib_while(n: u8) {
    let (mut a, mut b, mut i) = (1, 1, 2);
    
    while i < n {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
    }
}

fn fib_for(n: u8) {
    let (mut a, mut b) = (1, 1);
    
    for _i in 2..n { // 2…n == `2<= x < n`. Range 的下标上标都是 usize 类型，不能为负数. 如果`for _i in 2..=n`那么是`2<= x <= n`
        let c = a + b;
        a = b;
        b = c;
        println!("next val is {}", b);
    }
}

fn main() {
    let n = 10;
    fib_loop(n);
    fib_while(n);
    fib_for(n);
}
```

当有多层循环时，你可以使用 continue 或 break 来控制外层的循环:
```rust
fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count >= 20 {
                // This would break only the inner1 loop
                break 'inner1; // `break` is also ok 
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count >= 30 {
                // This breaks the outer loop
                break 'outer;
            }

            // This will continue the outer loop
            continue 'outer;
        }
    }

    assert!(count == 30)
}
```

### match 表达式与模式匹配
match 用于匹配各种情况, 有点类似其他编程语言中的switch或case.

match 也支持使用模式匹配(Pattern Matching). match表达式要求所有的分支都必须返回相同的类型,且如果是一个单独的match表达式而不是赋值给变量时，每个分支必须返回()类型.

match 分支左边就是模式，右边就是执行代码. 模式匹配同时也是一个表达式, 和 if 表达式类似，所有分支必须返回同一个类型. 但是左侧的模式可以是不同的。

使用操作符＠可以将模式中的值绑定给一个变量, 供分支右侧的代码使用，这类匹配叫绑定模式(Binding Mode). match 表达式必须穷尽每一种可能，所以一般情况下，使用通配符`_`来处理剩余的情况.

除了 match 表达式，还有 let 绑定、函数参数、for 循环等位置都用到了模式匹配.

Rust 的模式匹配被广泛应用在状态机处理、消息处理和错误处理中.

> rust不支持switch, 而是使用match. 很多语言摒弃 switch 的原因都是因为 switch 容易存在因忘记添加 break 而产生的串接运行问题，Java 和 C# 这类语言通过安全检查杜绝这种情况出现.

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::South | Direction::North  => { // matching South or North here
            println!("South or North");
        },
        _ => println!("West"),
    };
}

// matches! 看起来像 match, 但是它可以做一些特别的事情
fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    // fill the blank with `matches!` to make the code work
    for ab in alphabets {
        assert!(matches!(ab, 'a'..='z' | 'A'..='Z' | '0'..='9'))
    }
}
```

匹配守卫（match guard）是一个位于 match 分支模式之后的额外 if 条件，它能为分支模式提供更进一步的匹配条件:
```rust
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) if x < split => assert!(x < split),
        Some(x) => assert!(x >= split),
        None => (),
    }
}
```

使用 `..` 忽略一部分值:
```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        (first,..,last) => {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }
}
```

使用模式 &mut V 去匹配一个可变引用时，需要格外小心，因为`匹配出来的 V 是一个值，而不是可变引用`, 因此需要用`ref mut`去修饰:
```rust
fn main() {
    let mut v = String::from("hello,");
    let r = &mut v; // &mut String

    print_type_of(&r);

    // println!("{}", v); // 报错: cannot borrow `v` as immutable because it is also borrowed as mutable. 同时存在可变的r,v

    match r { // 不被转移所有权. 
       &mut ref mut value => {
           // r.push_str("t"); // 同时存在value和r, 生命周期不出问题: 推测, 在match r代码块, 编译器认为里面还是在使用r, value是r的变形, 没有多出其他可变引用
           value.push_str(" world!") // 把`&mut ref mut value`看作`&mut X`, value匹配到v, ref mut用于修饰value, 因此这里就是创建了一个可变引用`&mut String`即value
       }
    }

    match *r { // String
       ref mut value => value.push_str(" world!") // 不被转移所有权. value匹配到v, ref mut修饰value, 因此这里就是创建了一个可变引用`&mut String`即value
    }

    match r { // 匹配到&mut String
       value => { // 转移r的所有权: 发生移动是因为 `r` 的类型为 `&mut String`, 它没有实现 `Copy` 特征
            print_type_of(&value);
            value.push_str(" world!") 
       }
    }


    // println!("{}", r); // 报错: match已经拿走r的值的所有权
    println!("{}", v); // 能打印, 说明所有权还在
}

fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}
```

### if let while let 达式
Rust 还提供了 if let和while let 表达式 用来在某些场合替 match 表达式.

if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值. 在 if let 中可包含一个 else, else 块中的代码与 match 表达式中的 `_` 分支块中的代码相同.

```rust
fn main() {
    let o = Some(7);

    // 移除整个 `match` 语句块，使用 `if let` 替代
    match o {
        Some(i) => {
            println!("This is a really long string and `{:?}`", i);
        }
        _ => {}
    };
}

fn main() {
    let o = Some(7);

    if let Some(i) = o {
        println!("This is a really long string and `{:?}`", i);
    }
}
```

## 生命周期
编译器通过生命周期来确保所有的借用都是合法的.

```rust
struct City<'a> {
    name: &'a str,
    date_founded: u32,
}
```
上面`'a`含义: 如果name的生命期至少与City一样长, 才接受name的输入.

```rust
struct Adventurer<'a> {
    name: &'a str,
    hit_points: u32,
}

impl Adventurer<'_> {
    fn take_damage(&mut self) {
        self.hit_points -= 20;
        println!("{} has {} hit points left!", self.name, self.hit_points);
    }
}
```

`<'_>`被称为 "匿名生命期", 表示正在使用引用的标记, 是为了不必总是写诸如impl<'a> Adventurer<'a>这样的东西，因为类型上已经显示了生命期.

Rust 生命周期机制是与所有权机制同等重要的资源管理机制, 引入这个概念主要是应对复杂类型系统中资源管理的问题.

在 Rust 中, 堆内存的生命周期会默认和其栈内存的生命周期绑定在一起, 并保留leaked机制, 显式通过`Box::leak() / Box::into_raw() / ManualDrop`等动作, 让堆内存在需要的时候, 可以有超出帧存活期的生命周期. 

生命周期区别:
- 分配在堆和栈上的内存有其各自的作用域, 它们的生命周期是动态的
- 全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text段，然后在加载时，装入内存, 因此它们的生命周期和进程的生命周期一致，所以是静态的.

    函数指针的生命周期也是静态的，因为函数在 Text 段中.

生命周期用于处理引用, 即Rust 中的所有**引用**都附加了生命周期信息. 生命周期定义了引用相对值的原始所有者的生存周期，以及引用
作用域的范围.

> 引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算. 但引用往往导致极其复杂的资源管理问题.

大多数情况下它是隐式的, 编译器通过分析代码来确定变量的生命周期. 在某些情况下(跨词法作用域的借用), 编译器却不能确定变量的生命周期而需要开发者指明.

Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域. 大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样. 但当引用的生命周期可能以一些不同方式相互关联时，Rust 需要开发者使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的.

它是一类允许开发者向编译器提供引用如何相互关联的泛型. Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性. 它是 Rust 最与众不同的功能.

**生命周期纯粹是一个编译期构造**, 它可以帮助编译器确定某个引用有效的作用域, 并确保它遵循借用规则. 它可以跟踪诸如引用的来源，以及它们是否比借用值生命周期更长
这类事情. Rust 中的生命周期能够确保引用的存续时间不超过它指向的值.

Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的.

Rust 的借用检查器使用显式的生命周期标注来确定一个引用的合法范围.

生命周期标注的目的是，在参数和返回值之间建立联系或者约束. 调用函数时, 传入的参数的生命周期需要大于等于（outlive）标注的生命周期.

生命周期的主要目的: 避免悬垂引用.

#### 生命周期注解语法
生命周期注释是描述引用生命周期的办法.

**生命周期注解并不改变任何引用的生命周期的长短**. 与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用. 生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期.

生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短. `'a` 是大多数人默认使用的名称. 生命周期参数注解位于引用的 & 之后，并有一个空格来将引用类型与生命周期注解分隔开.
```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

example:
```rust
fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str { // 让函数返回值的生命周期将与两个参数的生命周期一致
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}

fn main() {
    let r;
    {
        let s1 = "rust";
        let s2 = "ecmascript";
        r = longer(s1, s2);
        println!("{} is longer", r);
    }
}
```

单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的.

泛型、特性与生命周期协同:
```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**生命周期也是泛型**.

#### 词法作用域（生命周期）
match、for、loop、while、if let、while let、花括号、函数、闭包都会创建新的作用域，相应绑定的所有权会被转移.

函数体本身是独立的词法作用域：
- 当复制语义类型作为函数参数时，会按位复制
- 如果是移动语义作为函数参数，则会转移所有权

借用规则： 借用方的生命周期不能长于出借方的生命周期.

rust 2018开始引入了非词法作用域生命周期(Non-Lexical Lifetime，NLL)来降低rust开发难度.

编译器在作用域结束之前判断不再使用引用的能力称为 非词法生命周期（简称 NLL ）. 有了这种能力，编译器就知道最后一次使用引用是什么时候，并根据这些知识优化借用规则.

```rust
fn main() {
    let mut data = 10;
    let ref1 = &mut data;
    let ref2 = &mut *ref1;

    *ref2 += 2;    
    *ref1 += 1;

    println!("{}", data);
}
```

#### 生命周期参数
编译器的借用检查机制无法对跨函数的借用进行检查，因为当前借用的有效性依赖于词法作用域. 所以，需要开发者显式的对借用的生命周期参数进行标注.

显式生命周期参数:
- 生命周期参数必须是以单引号开头；
- 参数名通常都是小写字母，例如：'a；
- 生命周期参数位于引用符号`&`后面，并使用空格来分割生命周期参数和类型

标注生命周期参数是由于borrowed pointers导致的. 因为有borrowed pointers，当函数返回borrowed pointers时，为了保证内存安全，需要关注被借用的内存的生命周期(lifetime).

标注生命周期参数并不能改变任何引用的生命周期长短，它只用于编译器的借用检查，来防止悬垂指针. 即：生命周期参数的目的是帮助借用检查器验证合法的引用，消除悬垂指针.

编译器确保数据不会在其引用离开作用域之前离开该作用域.

##### 函数签名中的生命周期参数
生命周期参数是为了帮助借用检查器验证非法借用. 函数间传入和返回的借用必须相关联, 并且返回的借用生命周期**必须不长于**出借方的生命周期.

函数签名中的生命周期参数与函数逻辑无关, 与其函数签名有关.

就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中.

下文的`'a`的实际含义是 foo 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致(即作用域相重叠的那一部分). 这就是开发者告诉 Rust 需要其保证的约束条件. 记住通过在函数签名中指定生命周期参数时， 并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝.

当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中. 这是因为 Rust 能够分析函数中代码而不需要任何协助，不过当函数引用或被函数之外的代码引用时，让 Rust 自身分析出参数或返回值的生命周期几乎是不可能的. 这些生命周期在每次函数被调用时都可能不同. 这也就是为什么需要手动标记生命周期.

```rust
fn foo<'a>(s: &'a str, t: &'a str) -> &'a str;
```
函数名后的<'a>为生命周期参数的声明. 函数或方法参数的生命周期叫做输入生命周期（input lifetime），而返回值的生命周期被称为输出生命周期（output lifetime）.

规则：
- 禁止在没有任何输入参数的情况下返回引用，因为会造成悬垂指针

    ```rust
    fn return_str<'a>() -> &'a str{
        let s = String::from("rust")
        &s[..]
    }
    ```
- 从函数中返回（输出）一个引用，其生命周期参数必须与函数的参数（输入）相匹配，否则，标注生命周期参数也毫无意义.

    ```rust
    fn return_str<'a>(x: &'a str, y: &'a str) -> &'a str{
        let s = String::from("rust")
        s.as_str()
    }
    ```

对于多个输入参数的情况，也可以标注不同的生命周期参数.

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result); // 报错, 因为string2较长时, 到println!时, string2已被释放.
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

正确:
```rust
fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str { // 让函数返回值的生命周期将与两个参数的生命周期一致
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}

fn longer2<'a, 'b: 'a>(s1: &'a str, s2: &'b str) -> &'a str { // `'b: 'a`是指泛型生命周期参数`'b`存活时间长于泛型生命周期参数`'a`
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}

fn main() {
    let s1 = String::from("Rust");
    let s1_r = &s1;
    {
        let s2 = "ecmascript";
        let res = longer(s1_r, &s2); // res是借用方
        println!("{} is longer", res);

        let res2 = longer2(s1_r, &s2);
        println!("{} is longer", res2);
    }
}
```

当从函数返回一个引用，**返回值的生命周期参数需要与一个参数的生命周期参数相匹配**. 如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域. 比如:
```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

针对这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用， 这样函数调用者就需要负责清理这个值了.

##### 方法定义中的生命周期参数
结构体中包含引用类型成员时，需要标注生命周期参数，则在impl关键字之后也需要声明生命周期参数，并在结构体名称之后使用.

```rust
impl<'a> Foo<'a> {
    fn split_first(s: &'a str) -> &'a str {
        …
    }
}

struct Decoder<'a, 'b, S, R> {
    schema: &'a S,
    reader: &'b R
}

impl<'a, 'b, S, R> Decoder<'a, 'b, S, R>
    where 'a: 'b { // 'a:'b表示'a 的生命周期比'b 长
}
```

在添加生命周期参数'a之后，结束了输入引用的生命周期长度要长于结构体Foo实例的生命周期长度.

##### 结构体定义中的生命周期参数
结构体在含有引用类型成员的时候也需要标注每一个引用的生命周期参数，否则编译失败.

```rust
struct Foo<'a> {
    part: &'a str,
    ...
}
```

struct的生命周期参数标记，实际上是和编译器约定了一个规则：结构体实例的生命周期应短于或等于任意一个成员的生命周期.

> 注：枚举体和结构体对生命周期参数的处理方式是一样的

##### 静态生命周期参数
静态生命周期 'static：是Rust内置的一种特殊的生命周期. **'static生命周期存活于整个程序运行期间**. 所有的字符串字面量都有生命周期，类型为`& 'static str`

字符串字面量是全局静态类型，他的数据和程序代码一起存储在可执行文件的数据段中，其地址在编译期是已知的，并且是只读的，无法更改.

```rust
fn main() {
    let x = "hello Rust";
    let y = x; // 按位复制
    assert_eq!(x, y);
}
```

从Rust 2018 开始, 使用 const和static 定义字符串字面量时, 都可以省掉`'static`静态生命周期参数.

##### 省略生命周期参数
满足以下三条规则时，可以省略生命周期参数. 该场景下，是将其硬编码到Rust编译器中，以便编译期可以自动补齐函数签名中的生命周期参数

生命周期省略规则：
1. 每一个是引用的参数都有它自己唯一的生命周期参数
2. 如果只有一个输入生命周期参数（无论是否省略），则该生命周期都将分配给输出生命周期参数
3. 如果有多个输入生命周期参数，而其中包含 &self 或者 &mut self，那么所有输出生命周期参数被赋予 self 的生命周期. 针对这条真正能够适用的就只有方法签名

上述规则1适用于输入生命周期, 规则2和3适用于输出生命周期.

举例:
```rust
fn first_word(s: &str) -> &str { // 原始
fn first_word<'a>(s: &'a str) -> &str { // 编译器应用第一条规则，也就是每个引用参数都有其自己的生命周期
fn first_word<'a>(s: &'a str) -> &'a str { // 对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的. 第二条规则表明输入参数的生命周期将被赋予输出生命周期参数. 现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期

fn longest(x: &str, y: &str) -> &str { // 原生
fn longest<'a,'b>(x: &'a str, y: &'b str) -> &str { // 应用1成功, 之后无法应用2和3, 因此需要手动标记.
```

如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误.

> 被编码进 Rust 引用分析的模式被称为 生命周期省略规则（lifetime elision rules）


```rust
impl<'a> Reader for BufReader<'a> {
    // 'a 在以下方法中不使用
}

// 可以写为：
impl Reader for BufReader<'_> {
    
}

// ---
// Rust 2015
struct Ref<'a, T: 'a> {
    field: &'a T
}

// Rust 2018
struct Ref<'a, T> {
    field: &'a T
}
```

##### 生命周期限定

生命周期参数可以向trait那样作为泛型的限定，有以下两种形式：

`T: 'a`表示T类型中的任何引用都要“获得”和'a一样长。
`T: Trait + 'a`表示T类型必须实现Trait这个trait，并且T类型中任何引用都要“活的”和'a一样长


```rust
use std::fmt::Debug; // 特征约束使用

#[derive(Debug)]
struct Ref<'a, T: 'a>(&'a T);
// `Ref` 包含对泛型类型 `T` 的引用，该泛型类型具有
// 未知的生命周期 `'a`. `T` 是约定任何
// 引用在 `T` 必须大于 `'a` 。此外，在生命周期
// 里 `Ref` 不能超过 `'a`。

// 使用 `Debug` 特征打印的通用函数。
fn print<T>(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// 这里引用 `T` 使用 where `T` 实现
// `Debug` 和所有引用 `T` 都要比 `'a` 长
// 此外，`'a`必须要比函数声明周期长
fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&x);

    print_ref(&ref_x);
    print(ref_x);
}
```

trait 对象和生命周期有默认遵循的规则：
1. trait 对象的生命周期默认是 `'static`
1. 如果实现 trait 的类型包含`＆'a X` 或`＆'a mut X`, 则默认生命周期就是`'a`
1. 如果实现 trait 的类型只有`T:'a`, 则默认生命周期就是`'a`
1. 如果实现 trait 的类型包含多个类似`T:'a`的从句, 生命周期需要明确指定

##### 高阶生命周期
ref:
- [谈一谈rust里的一个黑魔法语法HRTBs](https://dengjianping.github.io/2019/07/09/%E8%B0%88%E4%B8%80%E8%B0%88rust%E9%87%8C%E7%9A%84%E4%B8%80%E4%B8%AA%E9%BB%91%E9%AD%94%E6%B3%95%E8%AF%AD%E6%B3%95HRTBs.html)

Rust还提供了高阶生命周期（Higher-Ranked Lifetime）方案，该方案也叫高阶trait限定（Higher-Ranked Trait Bound，HRTB）, 引入HRTBs大部分原因是因为闭包. 该方案提供了for<>语法.

for<>语法整体表示此生命周期参数只针对其后面所跟着的“对象”.

错误:
```rust
fn call_on_ref_zero<'a, F>(f: F) where F: Fn(&'a i32) { // `'a`定义在call_on_ref_zero上, f的入参生命周期要`'a`
    let zero = 0; // zero 在call_on_ref_zero里绑定的, 因此&zero 的生命周期是短于 'a, 导致编译器报错
    f(&zero);
}

fn main() {
    println!("Success!")
}
```

正确:
```rust
fn call_on_ref_zero<F>(f: F) where for<'a> F: Fn(&'a i32) { // 接受一个闭包作为参数，闭包显示地标明了参数的生命周期. 其实函数参数接受单个引用，是可以省略生命周期的，因为编译器可以自动推导出来，这个时候也可以省略for<’a>
    let zero = 0;
    f(&zero);
}

fn main() {
    println!("Success!")
}
```

## 并发安全与所有权
如果类型T实现了Send： 就是告诉编译器该类型的实例可以在线程间安全传递所有权.
如果类型T实现了Sync：就是向编译器表明该类型的实例在多线程并发中不可能导致内存不安全，所以可以安全的跨线程共享.

## 函数
函数是编程语言的基本要素，它是对完成某个功能的一组相关语句和表达式的封装。函数也是对代码中重复行为的抽象.

在Rust中，函数定义以fn关键字开始并紧随函数名称(按小写字母以下划线分割)与一对圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方. 使用函数名加圆括号的方式来调用函数.

> 函数体由一系列的语句和一个可选的结尾表达式构成.

> Rust不关心在何处定义函数，只要这些定义对于使用区域是可见的即可, 这与go相同, 与c不同.

在函数签名中，必须声明每个参数的类型. 函数不支持自动返回值类型判断, 如果没有明确声明函数返回值的类型, 函数将被认为是"纯过程"即不允许产生返回值, 因此return 后面不能有返回值表达式.

> **参数变量和传入的具体参数值有自己分别对应的名称parameter和argument, 即形参和实参**.

rust并不对返回值命名，但要在`箭头（->）`后声明它的类型.
**在 Rust 中，函数的返回值等同于函数体最后一个表达式的值, 因此rust允许省略return**.
rust不支持多返回值, 但可以利用元组来返回多个值.

```rust
fn main() {
    let x = plus_one(5);
}
fn plus_one(x: i32) -> i32 {
    x + 1
}
// 错误: 在包含 x + 1 的行尾加上一个分号，把它从表达式变成语句. 语句并不会返回值，使用空元组 () 表示不返回值. 因为不返回值与函数定义相矛盾，从而出现一个错误.
// fn plus_one(x: i32) -> i32 {
//     x + 1;
// }
```

函数的第一个参数如果是Self相关的类型, 且命名为`self`, 那么这个参数就是receiver. 有receiver的函数即为方法(method), 用`变量实例.方法名`来调用.
没有receiver参数的函数是静态函数(static function), 通过类型加`::`的方式调用.

### 函数参数
- 当函数参数按值传递时，会转移所有权或者执行复制（Copy）语义
- 当函数参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数（符合规则时不需要显示的标明）

### 函数参数模式匹配
- ref ：使用模式匹配来获取参数的不可变引用
- ref mut ：使用模式匹配来获取参数的可变引用
- 除了ref和ref mut，函数参数也可以使用通配符来忽略参数

对于引用, Rust 支持两种模式: ref 模式和 `&`模式. 前者借用匹配值的元素, 后者匹配引用.

### 泛型函数
函数参数并未指定具体的类型，而是用了泛型T，对T只有一个Mult trait限定，即只有实现了Mul的类型才可以作为参数，从而保证了类型安全.

泛型函数并未指定具体类型，而是靠编译器来进行自动推断的。如果使用的都是基本原生类型，编译器推断起来比较简单。如果编译器无法自动推断，就需要显式的指定函数调用的类型。

### 函法和函数
方法代表某个实例对象的行为，函数只是一段简单的代码，它可以通过名字来进行调用。方法也是通过名字来进行调用，但它必须关联一个方法接受者。

方法是在结构体的上下文中被定义(或者是枚举或 trait 对象的上下文).

#### 方法
impl 块的另一个有用的功能是: 允许在 impl 块中定义不以 self (即self/&self/&mut self)作为参数的函数, 这被称为 关联函数（associated functions, 在主流的编程语言中, 这也被称为静态方法）, 因为它们与结构体相关联. 它们仍是函数而不是方法, 因为它们并不作用于一个结构体的实例. 比如`String::from`关联函数. 它类似于面向对象编程语言中的静态方法. 这些方法在类型自身上即可调用, 并且不需要类型的实例来调用, 调用方法是`<类型名>::<函数名>`

> 结构体允许拥有多个 impl 块.

impl实例方法的变体, 根据限制由少到多排列的:
- &self 作为第一个参数, 此方法仅提供对类型实例的读取访问权限

    `&self`实际上是 `self: &Self` 的缩写或者说语法糖
- &mut self 作为第一个参数, 此方法提供对类型实例的可变访问
- self 作为第一个参数, 这些方法拥有调用它的实例的**所有权**，并且类型在后续调用时将失效

### 高阶函数
高阶函数是指以函数作为参数或返回值的函数，它是函数式编程语言最基础的特性

## 闭包(closure)
闭包通常是指词法闭包，是一个持有外部环境变量的匿名函数. 闭包是一种匿名类型，一旦声明，就会产生一个新的类型，但这个类型无法被其它地方使用。在 Rust 里，闭包产生的匿名数据类型，格式和 struct 是一样的，会包含所有捕获的变量.

闭包的大小跟参数、局部变量都无关，只跟捕获的变量有关. [结合 rust-gdb, 闭包捕获变量的顺序，和其内存结构的顺序是一致, 且闭包是存储在栈上，并且除了捕获的数据外，闭包本身不包含任何额外函数指针指向闭包的代码](https://time.geekbang.org/column/article/424009).

> Rust 为每个闭包生成一个新的类型，又使得调用闭包时可以直接和代码对应，省去了使用函数指针再转一道手的额外消耗.
```rust
use std::{collections::HashMap, mem::size_of_val};
fn main() {
    // 长度为 0
    let c1 = || println!("hello world!");
    // 和参数无关，长度也为 0
    let c2 = |i: i32| println!("hello: {}", i);
    let name = String::from("tyr");
    let name1 = name.clone();
    let mut table = HashMap::new();
    table.insert("hello", "world");
    // 如果捕获一个引用，长度为 8
    let c3 = || println!("hello: {}", name);
    // 捕获移动的数据 name1(长度 24) + table(长度 48)，closure 长度 72
    let c4 = move || println!("hello: {}, {:?}", name1, table);
    let name2 = name.clone();
    // 和局部变量无关，捕获了一个 String name2，closure 长度 24
    let c5 = move || {
        let x = 1;
        let name3 = String::from("lindsey");
        println!("hello: {}, {:?}, {:?}", x, name2, name3);
    };

    println!(
        "c1: {}, c2: {}, c3: {}, c4: {}, c5: {}, main: {}",
        size_of_val(&c1),
        size_of_val(&c2),
        size_of_val(&c3),
        size_of_val(&c4),
        size_of_val(&c5),
        size_of_val(&main),
    )
}
```

闭包是可以保存进变量或作为参数传递给其他函数的匿名函数, 闭包相当于 Rust 中的 Lambda 表达式.

Rust 闭包的效率非常高。首先闭包捕获的变量，都储存在栈上，没有堆内存分配。其次因为闭包在创建时会隐式地创建自己的类型，每个闭包都是一个新的类型。通过闭包自己唯一的类型，Rust 不需要额外的函数指针来运行闭包，所以闭包的调用效率和函数调用几乎一致.

> 和其他语言的闭包比较: 大多数编程语言闭包的性能要远低于函数调用, 是因为使用闭包就意味着: 额外的堆内存分配、潜在的动态分派（很多语言会把闭包处理成函数指针）、额外的内存回收. 根本原因是变量的多重引用导致生命周期不明确, 它们的归属和生命周期处理起来很麻烦.  Rust 从一开始就消灭了这个问题:
1. 如果不使用 move 转移所有权，闭包会引用上下文中的变量，这个引用受借用规则的约束，所以只要编译通过，那么闭包对变量的引用就不会超过变量的生命周期，没有内存安全问题
1. 如果使用 move 转移所有权，上下文中的变量在转移后就无法访问，闭包完全接管这些变量，它们的生命周期和闭包一致，所以也不会有内存安全问题

> 在性能上，唯有 C++ 的 lambda 和 Rust 闭包类似，不过 C++ 的闭包还有[一些场景](https://www.elbeno.com/blog/?p=1068)会触发堆内存分配.

闭包主要用作高阶函数的参数。 高阶函数是一个以另一个函数或闭包作为参数的函数.

在大多数语言中，闭包是分配在堆上，动态分派，然后由垃圾回收程序负责回收的. Rust的闭包不会被分配到堆上，除非把它们装到 Box、Vec 或其他容器里, Rust 编译器知道所调用闭包的类型会将该闭包的代码行内化.

> 闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

外部环境是指闭包定义时所在的词法作用域.

外部环境变量，在函数式编程范式中也被称为自由变量，是指并不是在闭包内定义的变量.

**将自由变量和自身绑定的函数就是闭包**.

> 闭包的大小在编译期是未知的.

Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数. 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算. 不同于函数，闭包允许捕获调用者作用域中的值.

### 闭包的基本语法
闭包由管道符（两个对称的竖线）和花括号（或圆括号）组成:
```rust
|参数1, 参数2, ...| -> 返回值类型 {
    // 函数体
}
```

具体是:
- 管道符里是闭包函数的参数，可以向普通函数参数那样在冒号后添加类型标注，也可以省略

    例如：let add = |a, b| -> i32 { a + b };

- 花括号里包含的是闭包函数执行体，花括号和返回值也可以省略。

    例如：let add = |a, b| a + b;

- 当闭包函数没有参数只有捕获的自由变量时，管道符里的参数也可以省略

    例如： let add = || a + b;

**如果尝试对同一闭包使用不同类型则会得到类型错误**.

**闭包不要求像 fn 函数那样在参数和返回值上注明类型(但允许自行标注类型)**. 函数中需要类型注解是因为它们是暴露给用户的显式接口的一部分. 严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的,  但是闭包并不用于这样暴露在外的接口：它们储存在变量中并被使用，不用命名他们或暴露给库的用户调用.

闭包通常很短，并只关联于小范围的上下文而非任意情境. 在这些有限制的上下文中，编译器能可靠的推断参数和返回值的类型.

闭包还有一种并不少见，但可能不太容易理解的用法：为它实现某个 trait，使其也能表现出其他行为，而不仅仅是作为函数被调用。比如说有些接口既可以传入一个结构体，又可以传入一个函数或者闭包. 比tonic的[Interceptor](https://docs.rs/tonic/0.5.2/src/tonic/service/interceptor.rs.html#41-53), 它有一个 call 方法，它可以让 gRPC Request 被发送出去之前被修改，一般是添加各种头，比如 Authorization 头

### 闭包的实现
闭包是一种语法糖. 闭包不属于Rust语言提供的基本语法要素，而是在基本语法功能之上又提供的一层方便开发者编程的语法.

闭包和普通函数的差别就是闭包可以捕获环境中的自由变量.

闭包可以作为函数参数，这一点直接提升了Rust语言的抽象表达能力. 当它作为函数参数传递时，可以被用作泛型的trait限定，也可以直接作为trait对象来使用.

> 在函数外部，一个闭包可以在Fn、FnMut和FnOnce之间自行决定，但在函数内部你必须选择一个.

闭包无法直接作为函数的返回值，如果要把闭包作为返回值，必须使用trait对象.

### 闭包与所有权
闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用. 即闭包表达式会由编译器自动翻译为结构体实例，并为其实现Fn、FnMut、FnOnce三个trait中的一个:
- `FnOnce`：会转移方法接收者的所有权。没有改变环境的能力，只能调用一次。

    FnOnce 需要**取得其参数的所有权**，只能调用一次.

    从执行环境中获取数据的所有权的闭包实现了 FnOnce 特征. 该名称表示此闭包只能被调用一次。因此，相关的变量只能使用一次。这是构造和使用闭包最不推荐的方法，因为后续不能使用其引用的变量

    ```rust
    fn main() {
        let mut a = Box::new(23);
        let call_me = || {
            let c = a;
            _ = c;
        };
        call_me(); // 成功
        // call_me(); // 报错
    }

    fn main() {
        let range = 0..10;
        let get_range_count = || range.count();
        assert_eq!(get_range_count(), 10); // ✅
        get_range_count(); // ❌
    }
    ```

    FnOnce 有一个关联类型 Output, 是闭包返回值的类型；还有一个方法 call_once, 要注意的是 call_once 第一个参数是 self，它会转移 self 的所有权到 call_once 函数作用域中.
- FnMut:会对方法接收者进行可变借用。有改变环境的能力，可以多次调用。

    FnMut 只需要**取得可变的引用**，可以多次调用: 因为FnMut的call_mut() 传入 &mut self, 它不移动 self，所以 FnMut 可以被多次调用.
    
    当编译器检测出闭包改变了执行环境中引用的某个值时，它实现了 FnMut 特征.

    FnMut 可以在任何可以使用 FnOnce 的地方使用: 因为 FnOnce 是 FnMut 的 super trait，所以，一个 FnMut 闭包，可以被传给一个需要 FnOnce 的上下文，此时调用闭包相当于调用了 call_once().

    ```rust
    fn main() {
        let mut a = String::from("Hey!");
        let mut fn_mut_closure = || {
            a.push_str("Alice");
        };
        fn_mut_closure();
        println!("Main says: {}", a);
    }
    ```
- Fn:会对方法接收者进行不可变借用。没有改变环境的能力，可以多次调用。

    Fn只需要不可变的引用并可多次调用, 且不改变它从环境中捕获的任何变量, 即 Fn 闭包没有副作用或无状态.

    Fn 可以用在任何可以使用 FnMut 的地方，包括可以使用 FnOnce 的地方: 它继承了 FnMut，或者说 FnMut 是 Fn 的 super trait。这也就意味着任何需要 FnOnce 或者 FnMut 的场合，都可以传入满足 Fn 的闭包.

    仅为读取访问变量的闭包实现 Fn 特征。它们访问的任何值都是引用类型（ &T）。这是使用闭包的默认模式.

    ```rust
    fn main() {
        let a = String::from("Hey!");
        let fn_closure = || {
            println!("Closure says: {}", a);
        };
        fn_closure();
        println!("Main says: {}", a);
    }
    ```

如果要实现Fn，就必须实现FnMut和FnOnce
如果要实现FnMut，就必须实现FnOnce
如果要实现FnOnce，就不需要实现FnMut和Fn

实际上，Fn() 是 FnMut() 的子特型，而 FnMut() 又是 FnOnce() 的子特型。于是 Fn 就成了最专一且最强大的类别。FnMut 和 FnOnce 则是包含使用限制的更广泛的类别.

由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce. 那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 FnMut, 而不需要对被捕获的变量进行可变访问的闭包则也实现了 Fn.

如果希望强制闭包获取其使用的环境值的所有权, 可以在参数列表前使用 **move 关键字. 这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用**.

#### 捕获环境变量的方式
- 对于复制语义类型，以不可变引用（&T）来进行捕获
- 对于移动语义类型，执行移动语义，转移所有权来进行捕获
- 对于可变绑定，并且在闭包中包含对其进行修改的操作，则以可变引用（&mut T）来进行捕获

Rust使用move关键字来强制让闭包所定义环境中的自由变量转移到闭包中.

#### 规则总结
- 如果闭包中没有捕获任何环境变量，则默认自动实现Fn
- 如果闭包中捕获了复制语义类型的环境变量，则：

    - 如果不需要修改环境变量，无论是否使用move关键字，均会自动实现Fn
    - 如果需要修改环境变量，则自动实现FnMut

- 如果闭包中捕获了移动语义类型的环境变量，则：

    - 如果不需要修改环境变量，而且没有使用move关键字，则会自动实现FnOnce
    - 如果不需要修改环境变量，而且使用move关键字，则会自动实现Fn
    - 如果需要修改环境变量，则自动实现FnMut

- 使用 move 关键字，如果捕获的变量是复制语义类型的 ，则闭包会自动实现Copy/Clone; 否则不会自动实现Copy/Clone.

#### 高阶生命周期
Rust 为此提供了高阶生命周期 Higher-Ranked Lifetime, 也叫高阶 trait 限定(Higher-Ranked Trait Bound, HRTB), 该方案提供了了`for＜＞`语法用于标注生命周期参数, 表示此生命周期参数只针对其后面所跟的`对象`.

## 迭代器/iterator
迭代器定义了对集合数据的各种各样的访问操作.

> Iterator的逻辑是先返回当前项, 再调用next()更新当前项, 依次重复该过程.

迭代器模式允许对一个序列的项进行某些处理. 迭代器（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑, 是一种高效访问集合类型元素的方法.

> 在 Rust 中，**迭代器和迭代器适配器是 惰性的（lazy）**, 这意味着在调用方法使用迭代器之前它都不会有效果, 仅在需要时对集合中的元素进行求值或访问, 而之前的部分不过是在不断地生成新的结构, 来累积处理逻辑而已. 比如:

```rust
fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec
        .iter()
        .map(|number| { println!("A {:?}", number);number+1})
        .map(|number| { println!("B {:?}",number); number+2})
        .filter(|v| {println!("C {:?}",v); *v>4})
        .take({println!("D");2})
        .collect::<Vec<i32>>();   
        
    println!("{:?}", double_vec);
}
// output:
// D
// A 2
// B 3
// C 5
// A 4
// B 5
// C 7
// [5, 7]


fn main() {
    // 这里 Vec<T> 在调用 iter() 时被解引用成 &[T]，所以可以访问 iter()
    let result = vec![1, 2, 3, 4]
        .iter()
        .map(|v| v * v)
        .filter(|v| *v < 16)
        .take(1)
        .collect::<Vec<_>>(); // 直到运行到 collect 时才真正开始执行

    println!("{:?}", result);
}
实际执行:
1. 在 collect() 执行的时候，它实际试图使用 FromIterator 从迭代器中构建一个集合类型，这会不断调用 next() 获取下一个数据
1. 此时的 Iterator 是 Take，Take 调自己的 next()，也就是它会调用 Filter 的 next()
1. Map 的 next() 会调用其内部的 iter 取 next() 然后执行 map 函数。而此时内部的 iter 来自 Vec<i32>
1. Filter 的 next() 实际上调用自己内部的 iter 的 find()，此时内部的 iter 是 Map，find() 会使用 try_fold()，它会继续调用 next()，也就是 Map 的 next()

这种函数式编程的写法，代码是漂亮了，然而这么多无谓的函数调用，性能肯定很差吧？毕竟，函数式编程语言的一大恶名就是性能差. 实际 Rust 大量使用了 inline 等优化技巧, 这样非常清晰友好的表达方式，性能和 C 语言的 for 循环差别不大.
```

迭代器都实现了一个叫做 Iterator 的定义于标准库的 trait. next 是 Iterator 实现者被要求定义的唯一方法. next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None.

iterator trait 有大量的方法，但绝大多数情况下，只需要定义它的关联类型 Item 和 next() 方法:
- Item 定义了每次从迭代器中取出的数据类型
- next() 是从迭代器里取下一个值(返回Option)的方法。当一个迭代器的 next() 方法返回 None 时，表明迭代器中没有数据了

选择迭代器:
- iter() 引用的迭代器, 生成一个不可变引用的迭代器
- iter_mut() 可变引用的迭代器
- into_iter() 值的迭代器(不是引用), 获取所有权并返回拥有所有权的迭代器

<table>
<thead>
<tr>
<th><code>Vec&lt;T&gt;</code> 方法</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.iter()</code></td>
<td><code>Iterator&lt;Item = &amp;T&gt;</code></td>
</tr>
<tr>
<td><code>.iter_mut()</code></td>
<td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td>
</tr>
<tr>
<td><code>.into_iter()</code></td>
<td><code>Iterator&lt;Item = T&gt;</code></td>
</tr>
</tbody>
</table>

这些调用 next 方法的方法被称为 消费适配器（consuming adaptors），因为调用它们会消费迭代器.

Iterator trait 中定义了另一类方法，被称为 迭代器适配器（iterator adaptors），允许开发者将当前迭代器变为不同类型的迭代器, 可以链式调用多个迭代器适配器. 不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果.

```rust
let v1: Vec<i32> = vec![1, 2, 3];
// v1.iter().map(|x| x + 1); // 指定的闭包从未被调用过: 因为迭代器适配器是惰性的必须有消费
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect(); // 调用 collect 方法消费新迭代器
```

Rust 的 for 循环可以用于任何实现了  IntoIterator trait 的数据结构.

在执行过程中，IntoIterator 会生成一个迭代器，for 循环不断从迭代器中取值，直到迭代器返回 None 为止。因而，for 循环实际上只是一个语法糖，编译器会将其展开使用 loop 循环对迭代器进行循环访问，直至返回 None.

Rust使用的是外部迭代器，也就是for循环. 外部迭代器：外部可以控制整个遍历过程.

Rust中使用了trait来抽象迭代器模式. Iterator trait是Rust中对迭代器模式的抽象接口.

迭代器主要包含：
- next方法：迭代其内部元素
- 关联类型Item
- size_hint方法：返回类型是一个元组，该元组表示迭代器剩余长度的边界信息

Iter类型迭代器，next方法返回的是Option<&[T]>或Option<&mut [T]>类型的值. for循环会自动调用迭代器的next方法. for循环中的循环变量(是引用)则是通过模式匹配，从next返回的Option<&[T]>或Option<&mut [T]>类型中获取&[T]或&mut [T]类型的值.

IntoIter类型的迭代器的next方法返回的是Option<T>类型，在for循环中产生的循环变量是值，而不是引用.

> 迭代器可能比循环快的原因: 它`展开(unroll)`了循环. 展开是一种移除循环控制代码的开销并替换为每个迭代中的重复代码的优化.

### IntoIterator trait
如果想要迭代某个集合容器中的元素，必须将其转换为迭代器才可以使用.

Rust提供了FromIterator和IntoIterator两个trait，他们互为反操作:
- FromIterator ：可以从迭代器转换为指定类型
- IntoIterator ：可以从指定类型转换为迭代器

Intoiter可以使用IntoIter即into_iter方法来获取一个迭代器. into_iter的参数时self，代表该方法会转移方法接收者的所有权.

而还有其他两个迭代器不用转移所有权:
- Iter ：获取不可变借用，对应&self
- IterMut ：获得可变借用，对应&mut slef

### 哪些实现了Iterator的类型？
只有实现了Iterator的类型才能作为迭代器.

实现了IntoIterator的集合容器可以通过into_iter方法来转换为迭代器.

实现了IntoIterator的集合容器有：
- `Vec<T>`
- `&'a [T]`
- `&'a mut [T] => 没有为[T]类型`实现IntoIterator

### 迭代器适配器
Iterator 特型就会提供大量可供选择的适配器方法，或简称适配器（adapter）.

通过适配器模式可以将一个接口转换成所需要的另一个接口. 适配器模式能够使得接口不兼容的类型在一起工作. 适配器也叫包装器(Wrapper).

迭代器适配器，都定义在std::iter模块中：
- Map ：通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器。
- Chain ：通过连接两个迭代器来创建一个新的迭代器。
- Cloned ：通过拷贝原始迭代器中全部元素来创建新的迭代器。
- Cycle ：创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代。
- Enumerate ：创建一个包含计数的迭代器，它返回一个元组（i,val），其中i是usize类型，为迭代的当前索引，val是迭代器返回的值。
- Filter ：创建一个机遇谓词判断式过滤元素的迭代器。
- FlatMap ：创建一个类似Map的结构的迭代器，但是其中不会包含任何嵌套。
- FilterMap ：相当于Filter和Map两个迭代器一次使用后的效果. 它允许闭包在迭代过程中要么转换项（像 map 那样），要么删除项
- Fuse ：创建一个可以快速遍历的迭代器。在遍历迭代器时，只要返回过一次None，那么之后所有的遍历结果都为None。该迭代器适配器可以用于优化。
- Rev ：创建一个可以反向遍历的迭代器
- Scan: 类似于 map，区别在于它会传给闭包一个可修改的值，而且可以选择提前终止迭代
- take 和 take_while : 用于在取得一定项数之后或闭包决定中断时终止迭代

    - take 迭代器在产生最多 n 项后返回 None
    - take_while 迭代器对每一项应用 predicate，在遇到第一个 predicate 返回 false 的项时返回None，后续每次调用 next 也都返回 None
- skip 和 skip_while : 是对 take 和 take_while 的补充，它们从迭代开始清除一定数量的项，或者一直清除到闭包发现一个可以接受的项，然后将剩余项原封不动返回

    - skip_while 适配器使用闭包来决定清除序列开头的多少项
- peekable : 可以让代码在不消费下一项的情况下探测下一项
- fuse : 可以将任何适配器转换为第一次返回 None 之后始终继续返回 None 的迭代器
- zip : 将两个适配器组合为一个适配器，产生之前两个迭代器项的项对，就像拉链把分开的两边拼在一起一样

    ```rust
    let v: Vec<_> = (0..).zip("ABCD".chars()).collect();
    assert_eq!(v, vec![(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]);
    ```
- inspect : 可以方便地用于迭代器适配器管道的调试
- cloned : 将一个产生引用的迭代器转换为产生基于引用克隆的值的迭代器。自然地，引用值的类型必须实现 Clone
- cycle : 返回一个无休止重复底层迭代器的迭代器。底层迭代器必须实现 std::clone::Clone，以便 cycle 可以保存其初始状态并在每次循环开始时重用

Rust可以自定义迭代器适配器

### 消费器
迭代器不会自动发生遍历行为，需要调用next方法去消费其中的数据. 最直接消费迭代器数据的方法就是使用for循环.

Rust提供了for循环之外的用于消费迭代器内数据的方法，叫做消费器（Consumer）.

Rust标准库std::iter::Iterator中常用的消费器：
- any ：可以查找容器中是否存在满足条件的元素, 匹配到一个就停止
- fold ：该方法接收两个参数，第一个为初始值，第二个为带有两个参数的闭包。其中闭包的第一个参数被称为累加器即初始值，它会将闭包每次迭代执行的结果进行累计，并最终作为fold方法的返回值

    fold等同于其他语言的reduce或inject.
- collect ：专门用来将迭代器转换为指定的集合类型
- `all`
- `for_each`
- `position`: 返回None或一个带有位置号的Option
- max_by 和 min_by : 根据提供的自定义比较方法返回迭代器产生的最大值和最小值
- count 方法从一个迭代器中取, 直到它返回 None，然后返回这个迭代器包含多少项
- max 和 min : 分别返回迭代器产生项的最大值和最小值。迭代器的项类型必须实现 std::cmp::Ord，这样项与项之间才能比较
- max_by_key 和 min_by_key : 可以根据应用到每一项的闭包选择最大或最小的项。闭包可以选择项的某个字段，或者对每一项执行某些计算
- any 和 all : 给迭代器产生的每一项应用闭包，如果闭包对其中一项或全部项返回 true, 才返回 true
- position : 给迭代器产生的每一项应用闭包，返回闭包返回 true 的第一项的索引。更精确地说，position 返回一个索引的 Option：如果闭包对任何项都没有返回 true，则返回None。只要闭包返回 true，position 就停止取值
- nth : 接收一个索引值 n，然后跳过迭代器中相应的项，返回索引对应的项；如果序列在此之前结束，则返回 None
- last : 消费每一项，直到迭代器返回 None，然后返回最后一项。如果迭代器不产生任何项，则 last 返回 None
- find : 从迭代器中取得第一个闭包返回 true 的值，或者如果没有找到合适的项则返回None
- extend: 如果类型实现了 std::iter::Extend 特型，那么它的 extend 方法可以将一个迭代器的项添加到集合中
- partition : 把一个迭代器的项分成两个集合，然后使用闭包决定哪一项属于哪个集合
- cycle : 永远不会结束, 一直循环迭代
- sum: 把所有的东西加在一起
- chunks(N): 将Vec切分为最多N个值的子Vec
- windows(N): 将从0开始取N个值组成一个Vec, 直到Vec包含最后一个值
- match_indices() : 把 String 或 &str 里面所有匹配到的东西都提取出来，并给出索引

## 错误处理
Rust 没有异常, 而是将错误分为两个主要类别:
1. 可恢复错误（recoverable）

    可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件

    处理方案:
    - `Option<T>` :  解决有值和无值的问题

            ```rust
            enum Option<T> {
                None,
                Some(T),
            }
            ```

            Option支持`is_some()/is_none()/and_then()/and()`

            > and_then() : 输入是一个 Option，输出也是一个 Option

            > and() : 类似`&&`, 返回None或最后一个Some(T)
    - `Result<T,E>`

            ```rust
            enum Result<T, E> {
                Ok(T),
                Err(E),
            }
            ```

            Result支持`is_some()/is_none()/is_ok()/is_err()`

    > 可用类似 thiserror  的库定义好项目中主要的错误类型，并随着项目的深入，不断增加新的错误类型，让系统中所有的潜在错误都无所遁形

    > Rust 借鉴 Haskell, 构建了对标 Maybe 的 Option 类型和 对标 Either 的 Result 类型.

    > Result 类型声明时还有个 must_use 的标注，编译器会对有 must_use 标注的所有类型做特殊处理：如果该类型对应的值没有被显式使用，则会告警. 这样，保证错误被妥善处理.
1. 不可恢复错误（unrecoverable）

    不可恢复错误通常是 bug 的同义词, 比如尝试访问超过数组结尾的位置.

    处理方案:
    - panic
    - abort

> 为了提供更加方便和工程性的错误处理方案, Rust 社区有error-chain和failure等第三方crate. 目前官方比较推荐的是failure.

Option表示是否有值.

Option:
```rust
use std::collections::HashMap;

fn main() {
	let mut map = HashMap::new();
	map.insert("one", 1);
	map.insert("two", 2);

	let incremented_value = match map.get("one") {
		Some(val) => val + 1,
		None => 0
	};
	println!("{}", incremented_value);

	let incremented_value2 = if let Some(v) = map.get("one") {
		v + 1
	} else {
		0
	};
	println!("{}", incremented_value2);

	let incremented_value3 = map.get("three").unwrap() + 1; // 会panic
	println!("{}", incremented_value3);
}
```

另一种不太安全的方法是在 Option 上调用解压缩方法，即`unwrap()和expect()`(panic时, expect可传递信息)。如果返回的结果是 Some，那么调用这些方法后将提取内部的值；如果返回
的结果是 None，则会发生异常。仅当我们确定 Option 值确实包含某个值时，才推荐使用这些方法.

Result 和 Option 类似，但具有一些额外的优点，即能够存储和错误上下文有关的任意异常值，而不只是 None.

Result把错误封装在  `Result<T, E>` 类型中, 同时提供了`?`操作符(即`try!`宏)来传播错误而不是就地处理错误, 方便开发. `Result<T, E>` 类型是一个泛型数据结构，T 代表成功执行返回的结果类型, E 代表错误类型.

注意: 在不同的错误类型之间是无法直接使用的, 需要实现 From trait 在二者之间建立起转换的桥梁, 这会带来额外的麻烦. 而 anyhow 实现了 anyhow::Error 和任意符合 Error trait  的错误类型之间的转换，因此可以使用 ? 操作符而不必再手工转换错误类型

`?`可用于展开Result:
- 如果是Ok, 返回Result里面的内容
- 如果是Err, 则将错误传回

`?`内部被展开成类似这样的代码:
```rust
match result {
  Ok(v) => v,
  Err(e) => return Err(e.into())
}

// 比如
let mut f = OpenOptions::new().write(true).open("hello.txt")?;
// =
let f = OpenOptions::new().write(true).open("hello.txt");
let mut f = match f{
 Ok(file) => file,
 Err(e) => return Err(e),
};
```

Result:
```rust
fn main() {
	let _my_result: Result<_, ()> = Ok(64);
	// or
	let _my_result = Ok::<_, ()>(64);

	// 同样，我们可以创建 Err 类型的变量
	let _my_err = Err::<(), f32>(345.3);
	let _other_err: Result<bool, String> = Err("Wait, what ?".to_string());
}
```

Option 和 Result 类型之间的转换:
- ok:  Result -> Option, 丢弃Err
- ok_or/ok_or_else: Option -> Result

rust中的错误处理是通过返回Result<T, E>类型的方式进行的. Result<T, E>类型是Option<T>类型的升级版本.

main 函数也可返回一个 Result 类型:
```rust
fn main() -> Result<(), std::io::Error> {
    let f = File::open("bar.txt")?; // ?是一个错误处理的语法糖, 只适用返回Result的函数, 它会自动在出现错误的情况下返回std::io::Error. ?是通过std::convert::From的from方法进行错误类型的转换.
}
```

> `Box<dyn Error>`表示所有可能的错误.

Result<T, E> 类型定义了很多辅助方法来处理各种情况:
- is_ok/is_error: 返回 bool 值，表明result 是成功的结果还是错误的结果
- ok: 返回Option<T>类型的成功值（如果有的话）。如果result是一个成功的结果，就返回 Some(success_value)；否则，返回 None，而丢弃错误值
- err: 返回 Option<E> 类型的错误值（如果有的话）
- unwrap : 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值; 如果 Result 是成员 Err，unwrap 会调用 panic!
- unwrap_or(fallback): 返回成功值，如果 result 是成功的结果的话。否则，它返回 fallback，丢弃错误值

    这是对 .ok() 的一个完美替代，因为返回类型是 T 而非 Option<T>. 当然，只有在存在适当后备值的情况下才可以使用这个方法
- unwrap_or_else(): 只是传入的不是后备值，而是一个函数或闭包。这个方法适合计算后备值如果用不上会造成浪费的情况。只有在返回错误结果时才会调用 fallback_fn
- expect : expect 与 unwrap 的使用方式一样. 但expect 在调用 panic! 时使用的错误信息将是传递给 expect 的参数，而不像 unwrap 那样使用默认的 panic! 信息
- as_ref: 将 Result<T, E> 转换为 Result<&T, &E>，即借用现有 result 中成功或错误值的引用
- result.as_mut() : 类似as_ref, 只是借用了可修改引用, 返回类型为 Result<&mut T, &mut E>


当编写一个其实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理, 这被称为 传播（propagating）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误.

这种传播错误的模式在 Rust 中很常见，以至于 Rust 提供了 ? 问号运算符来使其更易于处理. ? 运算符可被用于返回值类型为 Result 的函数.

`?`的实际作用是将 Result 类非异常的值直接取出, 如果有异常就将异常 Result 返回出去. 所以, `?`仅用于返回值类型为 Result<T, E> 的函数，其中 E 类型必须和 ? 所处理的 Result 的 E 类型一致.

example:
```rust
fn f(i: i32) -> Result<i32, bool> {
    if i >= 0 { Ok(i) }
    else { Err(false) }
}

fn g(i: i32) -> Result<i32, bool> {
    let t = f(i)?; // 出现error时, ?已将异常 Result 返回了
    Ok(t) // 因此确定 t 不是 Err, t 在这里已经是 i32 类型
}

fn g2(i: i32) -> Result<i32, bool> { // 等价于g
    let t = f(i);

    match t {
        Ok(i) => Ok(i),
        Err(b) => Err(b)
    }
}

fn main() {
    let r = g(10000);
    if let Ok(v) = r {
        println!("Ok: g(10000) = {}", v);
    } else {
        println!("Err");
    }
}
```

match 表达式与`?`运算符所做的有一点不同：? 运算符所收到的错误值被隐式传递给了 from 函数，它定义于标准库的 From trait 中，其用来将错误从一种类型转换为另一种类型. 当 ? 运算符调用 from 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型. 这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败. 只要每一个错误类型都实现了 from 函数来定义如何将自身转换为返回的错误类型，? 运算符会自动处理这些转换.

?运算符消除了大量样板代码并使得函数的实现更简单, 甚至可以在 ? 之后直接使用链式方法调用来进一步缩短代码.

panic场景选择:
- 示例、代码原型和测试都非常适合 panic
- 当开发者比编译器知道更多的情况

    `let home: IpAddr = "127.0.0.1".parse().unwrap();`, 确定`127.0.0.1`是一个有效的 IP 地址, 无需处理`Result`

判断 Result 的 Err 类型，获取 Err 类型的函数是`kind()`:
```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_text_from_file(path: &str) -> Result<String, io::Error> {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

fn main() {
    let str_file = read_text_from_file("hello.txt");
    match str_file {
        Ok(s) => println!("{}", s),
        Err(e) => {
            match e.kind() {
                io::ErrorKind::NotFound => {
                    println!("No such file");
                },
                _ => {
                    println!("Cannot read the file");
                }
            }
        }
    }
}
```

`std::error::Error`方法:
- err.description() : 返回 &str 类型的错误消息
- err.cause() : 返回一个 Option<&Error>，这是触发 err 的底层错误（如果有的话）

### panic
panic是线程级别的, 是安全的, 它不违反 Rust 的任何安全规则.

rust是基于RAII机制来管理资源的, 在异常抛出时, 利用栈回退(Stack Unwind)机制来确保在栈内构造的局部变量或指针的析构函数都可以被一一调用.

std::panic::catch_unwind(作用和其它语言的 try {…} catch {…} 一样) 会接收一个闭包并处理其中发生的灾难性故障. 它不会阻止灾难性故障的发生，它只是停止发生灾难性故障
的线程中的堆栈展开. 且catch_unwind 不是 Rust 中处理错误的推荐方案, 因为它不能确保捕获所有灾难性故障， 例如abort触发的故障.

发生灾难性故障后默认的展开行为会导致内存开销过于昂贵的极端情况, 单片机禁用该展开的方法是在Cargo.toml添加属性:
```toml
[profile.release]
panic = "abort"
```

展开栈是程序沿调用栈开始反向清理.

展开栈是默认的诧异行为，但在两种情况下 Rust 不会展开栈:
1. 如果在 Rust 展开第一个函数之后的清理期间 .drop() 方法触发了第二个诧异，那么这个panic会被认为是致命的. Rust 会停止展开并中止整个进程。
2. Rust 的panic行为是可自定义的。如果编译时加上 -C panic=abort，那么编译后程序中的第一个panic就会立即中止进程.

    编译时加上这个选项， Rust 则无须知道如何展开栈，因此能够减少编译后代码的大小.

> 当出现 panic 时，程序默认会开始 展开（unwinding），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作. 另一种选择是直接 终止（abort），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理. 如果需要项目的最终二进制文件越小越好, panic 时通过在 Cargo.toml 的 [profile] 部分增加 panic = 'abort'，可以由展开切换为终止.

> 设置 RUST_BACKTRACE(`=1/full`)环境变量来得到一个 backtrace. backtrace 是一个执行到目前位置所有被调用的函数的列表. Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件, 这就是问题的发源地. 这一行往上是代码所调用的代码；往下则是调用该代码的代码.

> 为了获取backtrace信息, 必须启用 debug 标识. 当不使用 --release 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用.

## 宏
ref:
- [Writing macros](https://github.com/Dhghomon/easy_rust?tab=readme-ov-file#writing-macros)

    [编写宏(翻译版)](https://github.com/kumakichi/easy_rust_chs?tab=readme-ov-file#%E7%BC%96%E5%86%99%E5%AE%8F)
- [内置宏 from <<rust程序设计>> 第20章 20.2]()
- [调试宏 from <<rust程序设计>> 第20章 20.2]()
- [<<The Little Book of Rust Macros>>]
	深入宏

元编程是改变程序中指令和数据方式的一种编程技术. 它允许像处理任何其他数据那样通过指令生成新的代码. 许多语言都支持元编程，例如 Lisp 的宏、 C 的#define 构造及 Python 的元类.

元编程技术大概可以分为以下几类:
- 简单文本替换 : 比如C/C++中的宏定义, 在编译期直接进行文本替换
- 类型模板 : 比如 C++ 支持模板元编程
- 反射 : 比如Ruby, Java, Go, Rust 等或多或少都支持反射, 在运行时或编译时获取程序的内部信息

    反射(Reflect)机制一般是指程序自我访, 检测和修改其自身状态或行为的能力.

    Rust标准库提供了 std::any::Any 来支持运行时反射. 该 trait 不能被非静态生命周期的类型实现.

    get_type_id 方法返回 TypeId 类型,  代表Rust某个类型的全局唯一标识, 它是在编译时生成的, 每个 Id 都是一个"黑盒", 不能检查其内部内容, 但是允许复制、比较、打印等其他操作.

    Any也提供了 downcast_ref和downcast_mut 两个成对的泛型方法, 用于将泛型T向下转换为具体类型, 返回值分别为 `Option<&T>`和`Option<&mut T>`, 其 downcast_ref将类型T转换为不可变引用, 而 downcast_mut 将类型T转换为可变引用.

- 语法扩展 : 比如Ruby, Elixir, Rust 等语言可以对抽象语法树进行操作而扩展语言的语法

    比如 rust的derive 属性
- 代码自动生 : 比如Go提供 go generate 命令来根据指定的注释自动生成代码

rust宏和c/c++中的宏完全不是一个概念. 它是一种安全版的编译期语法扩展, 之所以使用宏, 而不是函数, 是因为宏可以完成编译期格式检查, 更加安全. 在编译期间，在检查类型和生成任何机器码之前，每个宏调用都会被扩展（expanded）.

> 函数则不具备字符串格式化的静态检查功能，如果出现了不匹配的情况, 只能是运行期报错.

> `format!, write!`最终还是调用`std::io`模块提供的一些函数来完成的. 如果用户需要更精细地控制标准输出操作, 也可以直接调用标准库来完成.

> derive可以根据名称实现一个或多个特征, 是一个过程宏，它只是简单地为实现它的类型的 impl 块生成代码, 并实现特征方法或任何
关联函数.

> todo: 类似unimplemented, 效果是代码能编译, 但执行到则会panic. 类似unreachable, 但它是针对永远不会用的代码.

> column!():输出那一列
> file!():输出文件名称
> line!():输出行号
> module_path!():输出模块的位置

一般的经验法则是，宏可以在函数无法提供所需解决方案的情况下使用，其中的代码具有相当的重复性，或者在需要检查类型结构体并在编译期生成代码的情况下使用宏.

同时应该谨慎地使用宏，它们会使代码难以维护和理解. 同时大量使用宏会导致性能损失, 因为会产生大量重复的代码，这会影响 CPU 指令缓存.

rust支持的宏:
1. 声明式宏

	这些是宏的最简单形式。它们是使用 macro_rules!宏创建的，其本身就是一个宏。它们提供与调用函数类似的功能，但是很容易通过名称末尾的!予以区
分。它们是在项目中快速编写小型宏的首选方法. 此时不需要考虑如何生成代码，因为 DSL 会替代劳.

    声明宏在展开后, 不会污染原来的词法作用域, 具有这种特性的宏叫卫生宏(Hygienic Macro). Rust 的声明宏具有部分卫生性.
1. 过程宏

    过程宏是编译器语法扩展的方式之一. Rust 允许通过特定的语法编写编译器插件.

	过程宏是宏的一种更高级形式，可以完全控制代码的操作和生成。这些宏没有任何 DSL 支持，并在某种意义上是程序性的，你必须为给定的标记树输入编
写如何生成或转换代码的指令。其缺点是实现起来很复杂，需要对编译器的内部机制，以及程序如何在编译器的内存中表示有一些了解。 macro_rules!宏可以在项目
的任何位置定义， 而过程宏需要通过将 Cargo.toml 文件中的属性设置为 proc−macro= true 来生成独立的软件包

macro_rules! 是 Rust 中定义宏的主要方式. 并非所有的宏都是以这种方式定义的. 比如 file!、line! 和 macro_rules!，本身是内置在编译器中的。

使用 macro_rules! 定义的宏完全基于模式匹配实现逻辑。宏的主体就是一系列规则的`( 模式1 ) => ( 模板1 );`.

具体到宏使用的语法形式又分为以下两种:
- 调用宏 : 比如`println!, assert_eq!, thread_local!, dbg!等可以当作函数调用的宏. 这种形式的宏通常由声明宏来实现, 也可以通过过程宏实现.

    dbg!是 println! 的一个很好的替代品，因为它的输入速度更快，提供的信息更多
- 属性宏 : 也就是形如`#[derive(Debug)]或#[cfg]`这种形式的语法. 这种形式的宏可以通过过程宏来实现, 也可通过编译器插件来实现

按宏的来源，可以分为以下两类:
- 内置宏 : 指 Rust 本身内量的一些宏, 包括两种: 一种由标准库中具体的代码实现; 一种属于编译器固有行为.
- 自定义宏 : 由开发者自己定义的声明宏或者过程宏等

### 属性
属性是 Rust 中写给编译器看的各种指令和建议的普适语法.

Rust 代码中的属性是指元素的注释. 属性通常是编译器内置的，不过也可以由用户通过编译器插件创建。它们指示编译器为其下显示的元素注入额外的代码或含义.

属性:
- `#[<name>]`：这适用于每个元素，通常显示在它们定义的上方
- `#![<name>]`：这适用于每个软件包. 它通常位于用户软件包根目录的最顶端部分
- 其他属性

    - `#[cfg(test)]`: 此属性添加在测试模块之上，以提示编译器有条件地编译模块，但仅在测试模式下有效

常见属性:
- `#[repr(C)]` : 要求 Rust 以兼容 C 和 C++ 的方式在内存中存储结构体

    与 C 和 C++ 不同, Rust 不保证结构体的字段或元素在内存中会以某种顺序存储, 但保证把字段的值直接存储在结构体的内存块中.
- `#[allow(unused_variables)]`: 允许存在未使用的变量

### 调试宏
调试宏代码基本有两种办法：
1. 使用编译器命令来输出展开后的代码
1. 在Nightly 版本下使用`#![feature(trace_macros)]`属性来跟踪宏展开过程

### 编译器插件
Rust中最强大的元编程工具非编译器插件莫属, 在Nightly 版本配合`#![feature(plugin_register)]`, 可以实现编译器插件.

编译器插件由内置的 librustc_plugin 包提供, 该包对外公开了八种方法供开发者编写不同功能的编译器插件:
- register_syntax_extension : 可以通过它实现任意语法扩展
- register_custom_derive 是对 register_syntax_extension 的包装, 用于实现自定义派生属性
- register_macro : 是对 register_syntax_extension 的包装, 用于实现 Bang 宏
- register_attribu : 实现编译器属性
- 其他4种与llvm相关

## 代码管理
rust支持使用mod 来组织代码.

使用方法: 在项目的入口文件`lib.rs/main.rs`里, 用 mod 来声明要加载的其它代码文件. 如果模块内容比较多, 可以放在一个目录下, 再在该目录下放一个 mod.rs 引入该模块的其它文件, mod.rs 和 Python 的 `__init__.py` 有异曲同工之妙.

在 Rust 里, 一个项目也被称为一个 crate. crate 可以是可执行项目，也可以是一个库.

在一个 crate 下，除了项目的源代码，单元测试和集成测试的代码也会放在 crate 里. Rust 的单元测试一般放在和被测代码相同的文件中，使用条件编译  #[cfg(test)] 来确保测试代码只在测试环境下编译.

集成测试一般放在 tests 目录下，和 src 平行. 和单元测试不同，**集成测试只能测试 crate 下的公开接口，编译时编译成单独的可执行文件**. 在 crate 下，如果要运行测试用例，可以使用`cargo test`.

当代码规模继续增长，把所有代码放在一个 crate 里就不是一个好主意了，因为任何代码的修改都会导致这个 crate 重新编译，这样效率不高. 此时可以使用 workspace, 一个 workspace 可以包含一到多个 crates，当代码发生改变时，只有涉及的 crates 才需要重新编译. 当要构建一个 workspace  时，需要先在某个目录下生成一个 Cargo.toml，包含 workspace 里所有的 crates，然后再通过  cargo new 生成对应的 crates.

workspace Cargo.toml例子:
```toml
[workspace]

members = [
	"core",
	...
	"server",
]
```

## test
Rust 的单元测试一般放在和被测代码相同的文件中，使用条件编译  #[cfg(test)] 来确保测试代码只在测试环境下编译.

集成测试一般放在 tests 目录下，和 src 平行. 和单元测试不同, 集成测试只能测试 crate 下的公开接口，编译时编译成单独的可执行文件.

Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的. 测试函数体通常执行如下三种操作：
1. 设置任何所需的数据或状态
1. 运行需要测试的代码
1. 断言其结果是我们所期望的

Rust 社区倾向于根据测试的两个主要分类来考虑问题：单元测试（unit tests）与 集成测试（integration tests）. 单元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口. 而集成测试对于开发者的库来说则完全是外部的. 它们与其他外部代码一样，通过相同的方式使用开发者的代码，只测试公有接口而且每个测试都有可能会测试多个模块.

在编写代码方面, 编写集成测试和单元测试没有太大的区别, 唯一的区别是目录结构和其中的项目需要公开, 开发人员已经根据软件包的设计原则公开了这些项目.

Rust 的私有性规则确实允许你测试私有函数.

Rust 二进制项目的结构明确采用 src/main.rs 调用 src/lib.rs 中的逻辑的方式: 因为通过这种结构，集成测试 就可以 通过 extern crate 测试库 crate 中的主要功能了, 根本原因是只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数, 而二进制 crate 只意在单独运行.

### 单元测试
单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块.

测试模块的 #[cfg(test)] 注解告诉 Rust 只在执行 cargo test 时才编译和运行测试代码，而在运行 cargo build 时不这么做.

cfg 属性代表 configuration ，它告诉 Rust 其之后的项只应该被包含进特定配置选项中, 通常用于条件编译，但不限于测试代码, 比如它可以为不同体系结
构或配置标记引用或排除某些代码. 通常配置选项是 test，即 Rust 所提供的用于编译和运行测试的配置选项. 通过使用 cfg 属性，Cargo 只会在我们主动使用 cargo test 运行测试时才编译测试代码.

### 集成测试
在 Rust 中，集成测试对于需要测试的库来说完全是外部的. 同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作. 一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的. 为了创建集成测试，需要先创建一个 tests 目录, 与 src 同级. Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译.

> tests 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中, 但可将其作为模块以便在任何集成测试文件中使用.

集成测试不需要将任何代码标注为`#[cfg(test)]`. tests 文件夹在 Cargo 中是一个特殊的文件夹， Cargo 只会在运行 cargo test 时编译这个目录中的文件.

可以通过指定测试函数的名称作为 cargo test 的参数来运行特定集成测试.

也可以使用 cargo test 的 --test 后跟文件的名称来运行某个特定集成测试文件中的所有测试, 比如`cargo test --test integration_test`, 只运行了 tests 目录中指定的文件 integration_test.rs 中的测试.

### 测试函数
作为最简单例子，Rust 中的测试就是一个带有 test 属性注解的函数. 属性（attribute）是关于 Rust 代码片段的元数据.

为了将一个函数变成测试函数，需要在 fn 行之前加上`#[test]`.

assert! 宏由标准库提供，在希望确保测试中一些条件为 true 时非常有用. 因此需要向 assert! 宏提供一个求值为布尔值的参数.

测试功能的一个常用方法是将需要测试代码的值与期望值做比较，并检查是否相等. 可以通过向 assert! 宏传递一个使用 == 运算符的表达式来做到。不过这个操作实在是太常见了，以至于标准库提供了一对宏来更方便的处理这些操作 —— assert_eq! 和 assert_ne!, 这两个宏分别比较两个值是相等还是不相等.


> `assert!(a == b)`中的`==`, 实际上会转变成一个方法调用`a.eq(&b)`, eq 方法来自特征 PartialEq. PartialEq 定义了
局部排序，而 Eq 需要全局排序.

> assert_eq! 和 assert_ne! 宏在底层分别使用了 == 和 !=。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必需实现了 PartialEq 和 Debug trait.

> debug_assert!: 类似assert!, 仅在debug模式中, 主要用于代码运行时，对应该保存的任何契约或不变性进行断言的情况, 有助于在调试模式下运行代码时捕获断言异常. 类似的还有debug_assert_eq!和 debug_assert_ne!.

还可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个可选的失败信息参数， 以便在测试失败时将自定义失败信息一同打印出来.

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`", result
        );
    }
}
```

属性`#[should_panic]`在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败. 还,可给 should_panic 属性增加一个可选的 expected 参数, 测试工具会确保错误信息中包含其提供的文本.

```rust
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!("Guess value must be greater than or equal to 1, got {}.",
                   value);
        } else if value > 100 {
            panic!("Guess value must be less than or equal to 100, got {}.",
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

可以使用 Result<T, E> 编写测试. 但不能对这些使用 Result<T, E> 的测试使用 #[should_panic] 注解, 相反应该在测试失败时直接返回 Err 值.

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

`#[ignore]`: 使用#[ignore]属性标记告知测试工具在执行 cargo test 命令时忽略此类测试功能, 然后可以向测试工具或 cargo test 命令传递`--ignored` 参数来单独运行这些测试.

### 执行测试
`rustc --test first_unit_test.rs`即测试first_unit_test.rs, 默认测试都是并行的, 除非设置了`RUST_TEST_THREADS=1`.

cargo test 在测试模式下编译代码并运行生成的测试二进制文件， 但可以指定命令行参数来改变 cargo test 的默认行为. cargo test 生成的二进制文件的默认行为是并行的运行所有测试，并截获测试运行过程中产生的输出, 这与golang类同.

当运行多个测试时， Rust 默认使用线程来并行运行. `cargo test -- --test-threads=1`可传递 --test-threads 参数和希望使用线程的数量给测试二进制文件, 这里将测试线程设置为 1，告诉程序不要使用任何并行机制.

如果希望能看到通过的测试中打印的值，截获输出的行为可以通过 --nocapture 参数来禁用, 比如` cargo test test_with_fixture --
--nocapture`, test_with_fixture是测试函数.

可以向 cargo test 传递任意测试的名称来只运行这个测试, 比如`cargo test one_hundred`.

指定部分测试的名称，任何名称匹配这个名称的测试会被运行, 比如`cargo test add`, 只运行了所有名字中带有 add 的测试.

可以使用 ignore 属性来标记耗时的测试并排除他们. 当需要运行 ignored 的测试时，可以执行`cargo test -- --ignored`.

### 基准测试
`cargo bench`

基准测试基于:
1. 函数上方的#[bench]注释，这表示该函数是一个基准测试
1. 内部编译器软件包 libtest 包含一个 Bencher 类型，基准函数通过它在多次迭代中运行相同的基准代码，此类型是针对编译器内部的，只适用于测试模式

```rust
// bench_example/src/lib.rs
#![feature(test)]
extern crate test;

use test::Bencher;

pub fn do_nothing_slowly() {
    print!(".");
    for _ in 1..10_000_000 {};
}

pub fn do_nothing_fast() {
}

#[bench]
fn bench_nothing_slowly(b: &mut Bencher) {
    b.iter(|| do_nothing_slowly());
}

#[bench]
fn bench_nothing_fast(b: &mut Bencher) {
    b.iter(|| do_nothing_fast());
}
```

在标有#[bench]注释的函数内部， iter 的参数是一个没有参数的闭包函数.

输出格式是每次迭代花费的时间，括号内的数字表示每次运行之间的差异. 性能较差的实现的运行速度非常慢, 并且运行时间不固定（用+/−符号所示）.

criterion-rs可生成比内置基准测试框架更多的统计报告, 并使用 gnuplot 生成实用的图形和报表, 使用户更容易理解, 使用方法是:
```
# cat Cargo.toml
...
[dev-dependencies]
criterion = "0.1"

[[bench]]
name = "fibonacci"
harness = false
...

# cat criterion_demo/benches/fibonacci.rs
#[macro_use] // 意味着要使用来自此软件包的任何宏时，我们需要使用此属性来选择它，因为默认情况下它们是非公开的
extern crate criterion;
extern crate criterion_demo;

use criterion_demo::{fast_fibonacci, slow_fibonacci};
use criterion::Criterion;

fn fibonacci_benchmark(c: &mut Criterion) { // c可保存基准代码的运行状态
    c.bench_function("fibonacci 8", |b| b.iter(|| slow_fibonacci(8)));
}

criterion_group!(fib_bench, fibonacci_benchmark); // 将fib_bench 的基准名称分配给基准组
criterion_main!(fib_bench);
```
添加了一个名为`[[bench]]`的新属性， 它向 Cargo 表明我们有一个名为 fibonacci的新基准测试，并且它不使用内置的基准测试工具（ harness=false）, 因为我们正在使用
criterion 软件包的测试工具.

## trait
ref:
- [Rust 的标准库 Trait 之旅](https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/)

所有的 trait 中都有一个隐藏的类型 Self，代表当前这个实现了此 trait 的具体类型. trait 中定义的函数，也可以称作关联函数（ associated function). 函数的第一个参数如果是 Self 相关的类型，且命名为 self（小写），这个参数可以被称为“receiver ”（接收者）. 具有 receiver 参数的函数，称为“方法”（method), 可以通过变量实例使用小数点来调用. 没有 receiver 参数的函数，称为“静态函数”（static function ），可以通过类型加`::`的方式来调用.

特殊的关键字Self 和 self:
- Self 代表当前的类型，比如 File 类型实现了 Write, 那么实现过程中使用到的 Self 就指代 File
- self 在用作方法的第一个参数时，实际上是 self: Self 的简写，所以 &self 是 self: &Self, 而 &mut self 是 self: &mut Self

```rust
trait T { 
	fn methodl(self: Self); 
	fn method2(self: &Self); 
	fn method3 (self: &mut Self); 
}
// 上下两种写法是完全一样的
trait T { 
	fn methodl (self) ; 
	fn method2(&self); 
	fn method3(&mut self); 
}
```

直接对它 impl 来增加成员方法, 无须 trait 名字, 比如：
```rust
impl Circle { 
	fn get radius(&self) -> f64 { self.radius } 
}
```
可以把这段代码看作是为 Circle 类型 impl 了一个匿名的 trait. 用这种方式定义的方法叫作这个类型的`内在方法`（ inherent methods).

> 结构体方法的第一个参数必须是 &self，不需声明类型，因为 self 不是一种风格而是关键字. 而在调用结构体方法的时候不需要填写 self, 这是出于对使用方便性的考虑.

> 结构体关联函数: 在 impl 块中却没有 &self 参数, 这种函数不依赖实例，但是使用它需要声明是在哪个 impl 块中的, 比如`String::from`.

trait 中可以包含方法的默认实现, 如果需要针对特殊类型作特殊处理，也可以选择重新实现来`override`默认的实现方式.

impl 的对象甚至可以是 trait, 如下:
```rust
trait Shape { 
	fn area(&self) -> f64;
}

trait Round { 
	fn get_radius(&self) -> f64;
}

struct Circle { 
	radius: f64, 
}

impl Round for Circle {
	fn get_radius(&self) -> f64 { self.radius } 
}

// impl Trait for Trait 
impl Shape for dyn Round {
	fn area(&self) -> f64 { 
		std::f64::consts::PI * self.get_radius() * self.get_radius() 
	}
}

fn main() { 
	let  c =Circle { radius : 2f64}; 
	// build err
	// c. area ( ) ; 

	let b = Box::new(Circle {radius : 4f64}) as Box<dyn Round>;
	b.area();
}
```

上面的`impl Shape for Round`和`impl<T: Round> Shape for T`是不一样的, 在前一种写法中, self 是`&Round`类型, 它是一个 trait object ，是胖指针. 在后一种写法中, self 是&T, T是具体类型 前一种写法是为 trait object增加一个成员方法; 而后一种写法是为所有的满足`T: Round`的具体类型增加一个成员方法. 所以上面的示例中，我们只能构造一个 trait object 之后才能调用 area()成员方法.

在运行时想让某个具体类型，只表现出某个 trait 的行为, 可将其赋值给一个特型类型（如 writer）的引用(无论是 &dyn T(在栈上)，还是 Box<dyn T>(在堆上)，还是 Arc<dyn T>)，该引用称为特型目标（trait object）. 特型目标是一个胖指针, 包含指向值本身的指针(原有的类型已被抹去)和指向表示该值类型的表的指针, 类似go的`interface{}`. C++ 同样也有这种运行时类型信息，其被称为虚拟表（virtual table）或 vtable.

一般情况下，不介意泛型参数带来的稍微复杂的代码结构，愿意用开发时的额外付出，换取运行时的高效；但有时候，当泛型参数过多，导致代码出现了可读性问题，或者运行效率并不是主要矛盾的时候，可以通过使用 trait object 做动态分发，来降低代码的复杂度.

> generics 依然最快，但使用 &dyn Executor 和 Box<dyn executor> 也不过只比它慢了 1% 和 2%

> 在编译 dyn T 时，Rust 会为使用了 trait object 类型的 trait 实现，生成相应的 vtable，放在可执行文件中（一般在 TEXT 或 RODATA 段）

> 在 Rust 里，函数或者方法的执行就是一次跳转指令，而 trait object 方法的执行还多一步，它涉及额外的内存访问，才能得到要跳转的位置再进行跳转，执行的效率要低一些. 此外，如果要把 trait object 作为返回值返回，或者要在线程间传递 trait object，都免不了使用 Box<dyn T> 或者 Arc<dyn T>，会带来额外的堆分配的开销.

与 Java 和 C# 的接口类似，特型目标不支持静态方法. 此时想要使用特型目标就必须修改特型, 给每个静态方法都添加`where Self: Sized`绑定, 让Rust知道该特型目标不支持该静态方法, 但可使用其他方法.

trait 对象给了我们运行时的多态性. Trait 对象是不确定大小的，所以它们必须总是在指针后面.

并非所有的 trait 都可以转换为 trait 对象, 在[官方文档](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)中有详细讨论。如果一个 trait 满足这些要求，它就是对象安全的:
1. trait 不需要 Self: Sized。
1. 所有 trait 的方法都是对象安全的

	如果 trait 方法满足这些要求，它就是对象安全的:
	- 方法需要 Self: Sized 或
	- 该方法只在接收器位置使用 Self 类型

> 如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object:
> 1. 不允许返回 Self，是因为 trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道
> 1. 不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化，而 trait object 是运行时的产物，两者不能兼容.

```rust
trait MyTrait {
    fn f(&self) -> Self;
}

impl MyTrait for u32 {
    fn f(&self) -> u32 { 42 }
}

impl MyTrait for String {
    fn f(&self) -> String { self.clone() }
}

fn my_function(x: impl MyTrait) -> impl MyTrait  {
    x.f()
}

fn main() {
    my_function(13_u32);
    my_function(String::from("abc"));
}

// ---
trait MyTrait {
    fn f(&self) -> Box<dyn MyTrait>;
}

impl MyTrait for u32 {
    fn f(&self) -> Box<dyn MyTrait> { Box::new(42) }
}

impl MyTrait for String {
    fn f(&self) -> Box<dyn MyTrait> { Box::new(self.clone()) }
}

fn my_function(x: Box<dyn MyTrait>) -> Box<dyn MyTrait> {
    x.f()
}

fn main() {
    my_function(Box::new(13_u32));
    my_function(Box::new(String::from("abc")));
}
```

**Rust 2018 edition开始, trait object 的语法会被要求加上 dyn 关键字即`impl Shape for dyn Round`**, 2015可用`impl Shape for Round`.

dyn(动多态, 类似golang的接口):
```rust
use std::fmt::Debug;

#[derive(Debug)]
struct Square(f32);
#[derive(Debug)]
struct Rectangle(f32, f32);

trait Area: Debug {
	fn get_area(&self) -> f32;
}

impl Area for Square {
	fn get_area(&self) -> f32 {
		self.0 * self.0
	}
}

impl Area for Rectangle {
	fn get_area(&self) -> f32 {
		self.0 * self.1
	}
}
fn main() {
	let shapes: Vec<&dyn Area> = vec![&Square(3f32), &Rectangle(4f32,2f32)]; //  `&dyn Area` 表示的，意味着它是指向 Area 某些实现的指针
	for s in shapes {
		println!("{:?}", s);
	}
}
```

```rust
use std::io::Write;
fn main() {
    let mut buf: Vec<u8> = vec![];
    let writer: &dyn Write = &mut buf;
}
```

trait依赖:
```rust
trait Vehicle {
	fn get_price(&self) -> u64;
}

trait Car: Vehicle {
	fn model(&self) -> String;
}
```

Car 特征指定了约束，任何实现特征的类型必须实现 Vehicle 特征.


trait形式:
1.  marker trait

	在 std::marker 模块中定义的特征被称为标记特征（ marker trait）。这种特征不包含任何方法，声明时只是提供特征名称和空的函数体.

	标准库中的示例包括 Copy、 Send、 Sync也是标记特征，因为它们用于简单地将类型标记为属于特定的组群，以获得一定程度的编译期保障.

	自动 trait 是指如果一个类型的所有成员都实现了这个 trait，那么这个 trait 就会被自动实现. 所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait. 自动trait有Send、 Sync.

    标记trait只应用于程序编译期, 而不是程序运行时.
1. 简单trait

	```rust
	trait Foo {
		fn foo();
	}
	```

	标准库中的一个示例是 Default 特征，它主要是针对可以使用默认值初始化的类型实现的.
1. 泛型trait

	```rust
	pub trait From<T> { // 将 T 转换为 Self
		fn from(T) -> Self;
	}

	trait Into<T> { // 将 Self 转换为 T
	    fn into(self) -> T;
	}
	```

	TryFrom 和 TryInto 是 From 和 Into 的不可靠版本.

	From和 Into 则是取得它们参数的所有权，转换类型，再把结果的所有权返回给调用者.
1. 关联类型trait

	当需要在函数签名中使用 Self 以外的其他类型, 但又希望类型由实现者选择, 而不是在 trait 声明中硬编码

	```rust
	trait Foo {
		type Out;
		fn get_value(self) -> Self::Out;
	}

	// ----
	trait Trait {
	    type AssociatedType;
	    fn func(arg: Self::AssociatedType);
	}

	struct SomeType;

	impl Trait for SomeType {
	    type AssociatedType = i8; // chooses i8
	    fn func(arg: Self::AssociatedType) {}
	}

	fn main() {
	    SomeType::func(-1_i8); // can only call func with i8 on SomeType
	}
	```

	它在trait中声明了相关类型.

    关联类型主要用于提升代码的可读性:
    ```rust
    struct Container(i32, i32);

    // 使用关联类型实现重新实现以下特征
    // trait Contains {
    //    type A;
    //    type B;

    trait Contains<A, B> {
        fn contains(&self, _: &A, _: &B) -> bool;
        fn first(&self) -> i32;
        fn last(&self) -> i32;
    }

    impl Contains<i32, i32> for Container {
        fn contains(&self, number_1: &i32, number_2: &i32) -> bool {
            (&self.0 == number_1) && (&self.1 == number_2)
        }
        // Grab the first number.
        fn first(&self) -> i32 { self.0 }

        // Grab the last number.
        fn last(&self) -> i32 { self.1 }
    }

    fn difference<A, B, C: Contains<A, B>>(container: &C) -> i32 {
        container.last() - container.first()
    }

    fn main() {
        let number_1 = 3;
        let number_2 = 10;

        let container = Container(number_1, number_2);

        println!("Does container contain {} and {}: {}",
            &number_1, &number_2,
            container.contains(&number_1, &number_2));
        println!("First number: {}", container.first());
        println!("Last number: {}", container.last());
        
        println!("The difference is: {}", difference(&container));
    }
    // --- 
    struct Container(i32, i32);

    // A trait which checks if 2 items are stored inside of container.
    // Also retrieves first or last value.
    trait Contains {
        // Define generic types here which methods will be able to utilize.
        type A;
        type B;

        fn contains(&self, _: &Self::A, _: &Self::B) -> bool;
        fn first(&self) -> i32;
        fn last(&self) -> i32;
    }

    impl Contains for Container {
        // Specify what types `A` and `B` are. If the `input` type
        // is `Container(i32, i32)`, the `output` types are determined
        // as `i32` and `i32`.
        type A = i32;
        type B = i32;

        // `&Self::A` and `&Self::B` are also valid here.
        fn contains(&self, number_1: &i32, number_2: &i32) -> bool {
            (&self.0 == number_1) && (&self.1 == number_2)
        }
        // Grab the first number.
        fn first(&self) -> i32 { self.0 }

        // Grab the last number.
        fn last(&self) -> i32 { self.1 }
    }

    fn difference<C: Contains>(container: &C) -> i32 {
        container.last() - container.first()
    }

    fn main() {
        let number_1 = 3;
        let number_2 = 10;

        let container = Container(number_1, number_2);

        println!("Does container contain {} and {}: {}",
            &number_1, &number_2,
            container.contains(&number_1, &number_2));
        println!("First number: {}", container.first());
        println!("Last number: {}", container.last());
        
        println!("The difference is: {}", difference(&container));
    }
    ```
1. trait依赖

	`trait Subtrait: Supertrait {}`: 所有实现 Subtrait 的类型都是所有实现 Supertrait 的类型的子集

	```rust
	trait Vehicle {
		fn get_price(&self) -> u64;
	}

	trait Car: Vehicle { // 实现者必须实现Car和Vehicle.
		fn model(&self) -> String;
	}
	```

	没有规定一个类型必须同时实现一个 subtrait 和一个 supertrait. 它可以在另一个类型的实现中使用其中一个类型的方法:
	```rust
		trait Supertrait {
	    fn super_method(&mut self);
	}

	trait Subtrait: Supertrait {
	    fn sub_method(&mut self);
	}

	struct CallSuperFromSub;

	impl Supertrait for CallSuperFromSub {
	    fn super_method(&mut self) {
	        println!("in super");
	    }
	}

	impl Subtrait for CallSuperFromSub {
	    fn sub_method(&mut self) {
	        println!("in sub");
	        self.super_method();
	    }
	}

	struct CallSubFromSuper;

	impl Supertrait for CallSubFromSuper {
	    fn super_method(&mut self) {
	        println!("in super");
	        self.sub_method();
	    }
	}

	impl Subtrait for CallSubFromSuper {
	    fn sub_method(&mut self) {
	        println!("in sub");
	    }
	}

	struct CallEachOther(bool);

	impl Supertrait for CallEachOther {
	    fn super_method(&mut self) {
	        println!("in super");
	        if self.0 {
	            self.0 = false;
	            self.sub_method();
	        }
	    }
	}

	impl Subtrait for CallEachOther {
	    fn sub_method(&mut self) {
	        println!("in sub");
	        if self.0 {
	            self.0 = false;
	            self.super_method();
	        }
	    }
	}

	fn main() {
	    CallSuperFromSub.super_method(); // prints "in super"
	    CallSuperFromSub.sub_method(); // prints "in sub", "in super"
	    
	    CallSubFromSuper.super_method(); // prints "in super", "in sub"
	    CallSubFromSuper.sub_method(); // prints "in sub"
	    
	    CallEachOther(true).super_method(); // prints "in super", "in sub"
	    CallEachOther(true).sub_method(); // prints "in sub", "in super"
	}
	```

### trait泛型参数
```rust
// trait declaration generalized with lifetime & type parameters
trait Trait<'a, T> {
    // signature uses generic type
    fn func1(arg: T);

    // signature uses lifetime
    fn func2(arg: &'a i32);

    // signature uses generic type & lifetime
    fn func3(arg: &'a T);
}

struct SomeType;

impl<'a> Trait<'a, i8> for SomeType {
    fn func1(arg: i8) {}
    fn func2(arg: &'a i32) {}
    fn func3(arg: &'a i8) {}
}

fn main() {
    SomeType::func1(-1_i8); // can only call func with i8 on SomeType
}
```

```rust
// make T = Self by default
trait Trait<T = Self> {
    fn func(t: T) {}
}

// any type can be used as the default
trait Trait2<T = i32> {
    fn func2(t: T) {}
}

struct SomeType;

// omitting the generic type will
// cause the impl to use the default
// value, which is Self here
impl Trait for SomeType {
    fn func(t: SomeType) {}
}

// default value here is i32
impl Trait2 for SomeType {
    fn func2(t: i32) {}
}

// the default is overridable as we'd expect
impl Trait<String> for SomeType {
    fn func(t: String) {}
}

// overridable here too
impl Trait2<String> for SomeType {
    fn func2(t: String) {}
}
```

### 泛型类型 vs 关联类型
泛型类型和关联类型都将决定权交给了实现者, 让他们决定在 trait 的函数和方法中应该使用哪种具体类型. 一般的经验法则是
1. 当每个类型只能有一个 trait 的实现时, 使用关联类型
1. 当每个类型可以有许多可能的 trait 的实现时, 使用泛型类型

关联类型:
```rust
trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -> Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -> Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

// 支持 Point + Point, 而不支持Point + i32
fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
```

泛型类型:
```rust
trait Add<Rhs> {
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add<Point> for Point {
    type Output = Self;
    fn add(self, rhs: Point) -> Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add<i32> for Point {
    type Output = Self;
    fn add(self, rhs: i32) -> Self::Output {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

// 将 Rhs 从关联类型重构为泛型类型 支持 Point + Point, 也支持Point + i32
fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
    
    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
```

允许Point+Point=Line:
```rust
trait Add<Rhs, Output> {
    fn add(self, rhs: Rhs) -> Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add<Point, Point> for Point {
    fn add(self, rhs: Point) -> Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add<i32, Point> for Point {
    fn add(self, rhs: i32) -> Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

struct Line {
    start: Point,
    end: Point,
}

impl Add<Point, Line> for Point {
    fn add(self, rhs: Point) -> Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3: Point = p1.add(p2);
    assert!(p3.x == 3 && p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert!(p3.x == 3 && p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let l: Line = p1.add(p2);
    assert!(l.start.x == 1 && l.start.y == 1 && l.end.x == 2 && l.end.y == 2)
}
```

### 作用域
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn main() -> Result<(), io::Error> {
    let mut file = File::open("Cargo.toml")?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer)?; // read_to_string(buf: &mut String) 由 std::io::Read trait 声明，并由 std::fs::File 结构体实现，但为了调用它，std::io::Read 必须在作用域内
    Ok(())
}
```

标准库中的 prelude 是标准库中的一个模块, 即 std::prelude::v1, 它在每个其他模块的顶部被自动导入即`use std::prelude::v1::*`. 因此, 相关 trait 总是在作用域内，永远不需要显式导入它们.


### 默认实现
```rust
trait Trait {
    fn method(&self) {
        println!("default impl");
    }
}

struct SomeType;
struct OtherType;

// use default impl for Trait::method
impl Trait for SomeType {}

impl Trait for OtherType {
    // use our own impl for Trait::method
    fn method(&self) {
        println!("OtherType impl");
    }
}

fn main() {
    SomeType.method(); // prints "default impl"
    OtherType.method(); // prints "OtherType impl"
}
```


```rust
use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -> bool;
}

impl<T> Even for T
where
    T: Rem<Output = T> + PartialEq<T> + Sized,
    u8: TryInto<T>,
    <u8 as TryInto<T>>::Error: Debug,
{
    fn is_even(self) -> bool {
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

impl Even for u8 { // 通用的全面实现和特定实现冲突. 因为rust保证了Trait 一致性即任何给定类型的 trait 最多存在一个实现的属性
    fn is_even(self) -> bool {
        self % 2_u8 == 0_u8
    }
}

#[test]
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
```

### Any
这个 trait 很少需要使用，因为在大多数情况下，参数化多态性要优于临时多态性，后者也可以用枚举来模拟，因为枚举的类型更安全，需要的迂回更少.

```rust
use std::any::Any;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&mut self) {
        self.x += 1;
        self.y += 1;
    }
}

fn map_any(mut any: Box<dyn Any>) -> Box<dyn Any> {
    if let Some(num) = any.downcast_mut::<i32>() {
        *num += 1;
    } else if let Some(string) = any.downcast_mut::<String>() {
        *string += "!";
    } else if let Some(point) = any.downcast_mut::<Point>() {
        point.inc();
    }
    any
}

fn main() {
    let mut vec: Vec<Box<dyn Any>> = vec![
        Box::new(0),
        Box::new(String::from("a")),
        Box::new(Point::default()),
    ];
    // vec = [0, "a", Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_any).collect();
    // vec = [1, "a!", Point { x: 1, y: 1 }]
}
```

### Operator Traits
ref:
- rust表达式小结 from `<<Rust程序设计>>#6.15 优先级与关联性`
- 表达式优先级 from `<<Rust编程之道>>#2.12 表达式优先级`
- [std::ops](https://doc.rust-lang.org/std/ops/index.html)

Rust 中的所有运算符都与 trait 相关, 如果想为自定义类型实现运算符，就必须实现相关的 trait.

<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>

所有的 PartialEq<Rhs> 实现必须确保相等是对称的和传递的。这意味着对于所有的 a, b, 和 c:
- 对称性: a == b => b == a
- 传递性: a == b && b == c => a == c

根据定义`trait Eq: PartialEq<Self> {}`, Eq 是一个标记 trait，是 PartialEq<Self> 的子 trait. 它还保证了自反性即 对所有 a都有a == a. 在这个意义上，Eq 完善了 PartialEq，因为它代表了一个更严格的相等性版本。如果一个类型的所有成员都是Eq 的，那么 Eq 实现就可以为该类型派生

几乎所有其他的 PartialEq 类型都是 Eq, 但浮点类型是 PartialEq 的，但不是 Eq 的，因为 NaN != NaN.

所有的 PartialOrd 实现必须确保比较是不对称的和传递的。这意味着对于所有的 a, b, 和 c:
- 不对称性 : a < b => !(a > b)
- 传递性: a < b && b < c => a < c

PartialOrd 是 PartialEq 的一个子 trait，它们的实现必须总是相互一致.

Ord在 PartialOrd 所要求的不对称性和传递性的基础上，还保证不对称性是完全的，即对于任何给定的 a 和 b，a == b 或 a > b 中只有一个是真的. 在这个意义上，Ord 完善了 Eq 和 PartialOrd，因为它代表了一个更严格的比较版本。如果一个类型实现了 Ord，就可以用这个实现来实现 PartialOrd、PartialEq 和 Eq.

PartialOrd 类型大都是 Ord, 但浮点数实现了 PartialOrd，但不是 Ord，因为 NaN < 0 == false 和 NaN >= 0 == false 同时为真.

## 面向对象
### 封装
封装就是对外显示的策略，在 Rust 中可以通过模块的机制来实现最外层的封装，并且每一个 Rust 文件都可以看作一个模块，模块内的元素可以通过 pub 关键字对外明示.

```rust
// --- second.rs
pub struct ClassName {
    field: i32,
}

impl ClassName {
    pub fn new(value: i32) -> ClassName {
        ClassName {
            field: value
        }
    }

    pub fn public_method(&self) {
        println!("from public method");
        self.private_method();
    }

    fn private_method(&self) {
        println!("from private method");
    }
}

// --- main.rs
mod second;
use second::ClassName;

fn main() {
    let object = ClassName::new(1024);
    object.public_method();
}
```

### 继承
继承是多态（Polymorphism）思想的实现, 多态指的是编程语言可以处理多种类型数据的代码. 在 Rust 中，通过特性（trait）实现多态.

总结地说，Rust 没有提供跟继承有关的语法糖，也没有官方的继承手段（完全等同于 Java 中的类的继承），但灵活的语法依然可以实现相关的功能.

## 并发
move:
```rust
use std::thread;

fn main() {
    let s = "hello";
   
    let handle = thread::spawn(move || {
        println!("{}", s);
    });

    handle.join().unwrap();
}
```

channel:
```rust
// 子线程获得了主线程的发送者 tx，并调用了它的 send 方法发送了一个字符串，然后主线程就通过对应的接收者 rx 接收到了
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

## 并发
常见并发模型是并行分叉-合并, 分叉（fork）就是启动一个新线程，而合并（join）就是等待线程完成.

> Rust使用的线程被称为`OS线程`.

```rust
use std::thread;
fn main() {
    let child = thread::spawn(|| {
        println!("Thread!");
        String::from("Much concurrent, such wow!")
    });
    print!("Hello ");
    let value = child.join().expect("Failed joining child thread");
    println!("{}", value);
}
```

对 spawn 的调用会创建线程并立即返回, 线程开始并发执行而不会阻塞后面的指令. 子线程是以分离状态创建的.

> spawn创建的线程是一个真实的操作系统线程, 有自己的栈, 与 C++、C# 和 Java 中的线程一样.

spawn 函数会返回一个 JoinHandle 类型的值, 可用于连接线程——换句话说就是等待它的终止.

调用 join 会阻塞当前线程，并在执行 join 调用之后的任何代码行之前等待子线程完成, 它返回一个 Result 值. 但如果一个线程正在连接自身或者遇到死锁，那么连接线程可能会失败, 在这种情况下，它会返回一个 Err 变量, 且里面返回的值是 Any 类型.

自定义线程:
```rust
use std::thread::Builder;
fn main() {
    let my_thread = Builder::new()
        .name("Worker Thread".to_string())
        .stack_size(1024 * 4);
    let handle = my_thread.spawn(|| {
        panic!("Oops!");
    });
    let child_status = handle.unwrap().join();
    println!("Child status: {:#?}", child_status);
}

/* output:
Child status: Err(
    Any { .. },
)
*/
```

上例使用了 Builder::new 方法, 调用 name 和 stack_size 方法为线程分配名称和设置堆栈大小(默认是2M).

标准库的 spawn 函数是一个重要的原语，但并不是专门为并行分叉–合并设计的. 当前社区已经有更好的分叉–合并 API 构建在其基础之上, 比如Rayon, 它还支持工作窃取（work-stealing）的技术动态地在线程间平衡负载.

其他并发库还有crossbeam.

### 并发模型
使用并发主要出于两个主要原因: 性能和容错.

并发按支持的实体分为如下两类:
1. 操作系统提供的进程和线程

    进程是资源分配的最小单元，线程是程序执行时的最小单元.
1. 编程语言内置的用户级线程

Rust 并不会倾向于使用任何固有的并发模型, 允许开发者使用自己的模型, 并根据需要使用第三方软件包来解决自己的问题.

Rust 内置了两种流行的并发模型：通过同步共享数据和通过消息传递共享数据.

并发状态下有三种常见的工作模式:
1. 自由竞争模式

    atomic / Mutex 解决了自由竞争模式下并发任务的同步问题，也能够很好地解决 map/reduce 模式下的同步问题
1. map/reduce 模式
1. DAG 模式

    可用Channel 用于处理并发任务之间的通讯


#### channel
Rust 提供了以下四种 Channel:
1. oneshot：这可能是最简单的 Channel，写者就只发一次数据，而读者也只读一次. 这种一次性的、多个线程间的同步可以用 oneshot channel 完成.

    由于 oneshot 特殊的用途，实现的时候可以直接用 atomic swap来完成
1. rendezvous：很多时候，只需要通过 Channel 来控制线程间的同步，并不需要发送数据。rendezvous channel 是 channel size 为 0 的一种特殊情况

    这种情况下，用 Mutex(保证条件在读写时互斥) + Condvar(控制线程的等待和唤醒) 实现就足够了，在具体实现中，rendezvous channel 其实也就是 Mutex + Condvar 的一个包装
1. bounded：bounded channel 有一个队列，但队列有上限。一旦队列被写满了，写者也需要被挂起等待。当阻塞发生后，读者一旦读取数据，channel 内部就会使用 Condvar 的 notify_one 通知写者，唤醒某个写者使其能够继续写入

    实现中，一般会用到 Mutex + Condvar + VecDeque 来实现；如果不用 Condvar，可以直接使用 thread::park + thread::notify 来完成（flume 的做法）；如果不用 VecDeque，也可以使用双向链表或者其它的 ring buffer 的实现
1. unbounded：queue 没有上限，如果写满了，就自动扩容

    Rust 的很多数据结构如 Vec 、VecDeque 都是自动扩容的

    unbounded 和 bounded 相比，除了不阻塞写者，其它实现都很类似

所有这些 channel 类型，同步和异步的实现思路大同小异，主要的区别在于挂起 / 唤醒的对象. 在同步的世界里，挂起 / 唤醒的对象是线程；而异步的世界里，是粒度很小的 task.


根据 Channel 读者和写者的数量，Channel 又可以分为:
1. SPSC：Single-Producer Single-Consumer，单生产者，单消费者。最简单，可以不依赖于 Mutex，只用 atomics 就可以实现
1. SPMC：Single-Producer Multi-Consumer，单生产者，多消费者。需要在消费者这侧读取时加锁
1. MPSC：Multi-Producer Single-Consumer，多生产者，单消费者。需要在生产者这侧写入时加锁
1. MPMC：Multi-Producer Multi-Consumer。多生产者，多消费者。需要在生产者写入或者消费者读取时加锁

在众多 Channel 类型中，使用最广的是 MPSC channel，多生产者，单消费者，因为往往希望通过单消费者来保证，用于处理消息的数据结构有独占的写访问.

各种并发原语的使用场景 Atomic、Mutex、RwLock、Semaphore、Condvar、Channel、Actor:
1. Atomic 在处理简单的原生类型时非常有用，如果可以通过 AtomicXXX 结构进行同步，那么它们是最好的选择
1. 当数据结构无法简单通过 AtomicXXX 进行同步，但又的确需要在多个线程中共享数据，那么 Mutex / RwLock 可以是一种选择。不过，需要考虑锁的粒度，粒度太大的 Mutex / RwLock 效率很低
1. 如果你有 N 份资源可以供多个并发任务竞争使用，那么，Semaphore 是一个很好的选择。比如要做一个 DB 连接池
1. 当需要在并发任务中通知、协作时，Condvar 提供了最基本的通知机制，而 Channel 把这个通知机制进一步广泛扩展开，于是可以用 Condvar 进行点对点的同步，用 Channel 做一对多、多对一、多对多的同步

#### 原子类型
std::sync::atomic 模块包含无锁并发编程要使用的原子类型. 这些类型基本上与标准 C++ 原子类型相同:
- AtomicIsize 和 AtomicUsize 是共享的整数类型，对应单线程的 isize 和 usize 类型
- AtomicBool 是一个共享的 bool 值
- `AtomicPtr<T>` 是不安全指针类型 *mut T 的共享值

Atomic相当于线程安全版本的`Cell<T>`

原子类型除提供基本的原子操作之外，还提供了内存顺序参数. 控制内存顺序实际上就是控制底层线程同步, 以便消除底层因为编译器优化或指令重排而可能引发的竞态条件.

rust提供的5种内存顺序, 实际上可以归为3大类:
1. 排序一致性顺序： Ordering::SeqCst

    SeqCst 是最严格的 ordering，除了 AcqRel 的保证外，它还保证所有线程看到的所有 SeqCst 操作的顺序是一致的
1. 自由顺序: Ordering::Relaxed

    最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序执行
1. 获取-释放顺序： Ordering::Release, Ordering::Acquire和Ordering::AcqRel

     AcqRel 是 Acquire 和 Release 的结合，同时拥有 Acquire 和 Release 的保证

Rust 支持的5种内存顺序与其底层的 LLVM 支持的内存顺序是一致的.

选择内存顺序和底层硬件环境也有关系, 一般情况议使用 Ordering::SeqCst. 在需要性能优化的情况下, 先调研并发程序运行的硬件环境, 再优先选择获取一释放顺序（按需选择）. 除非必要, 否则不要使用 Ordering::Relaxed.

#### 多线程内存模型
现代处理器和编程语的编译器为了性能都对程序进行了极度优化, 比如乱序执行和指令重排.

在多线程编程中, 只有保障顺序一致性, 才能保证程序的正确性. 所谓顺序一致性, 主要是约定了两件事:
1. 在单线程内部指令都是按程序确定的顺序来执行的
1. 多线程程序在执行过程中虽然是交替执行的, 但从全局来看, 也是按某种确定的顺序来执行的

在硬件层面并没有支持顺序一致性, 所要编程语言和计算机系统(包括编译器、 CPU 等）之间达成`契约`, 规定多线程访问同一个内存位置时的语义, 以及某个线程对内存位置的更新何时才能被其他线程看到,  这个契约就是多线程内存模型. 通过该内存模型, 开发者就可以使用编程语言提供的同步原语（比如C++和 Rust 提供的 Atomic)来保证多线程下的顺序一致性, 这也是无锁并发编程的基础.

rust语言层面支持并发工具:
- 线程管理 : 在 std::thread 模块中定义了管理线程的各种函数和一些底层同步原语

    直接使 tthread:spawn 生成的线程默认没有名称, 栈大小是2M. 可用 thread::Builder 自定义线程

    修改生成线程的栈大小默认值也可以通过指定环境变 RUST_MIN_STACK 来完成, 但会被Builder::stack_size 覆盖.

    线程本地存储(Thread Local Storage, TLS)是每个线程独有的存储空间, 可用thread_local!宏声明.

    std::thread 模块中还提供了一些函数, 用来支持底层同步原语, 主要包括 park/unpark和yield_now 函数:
    - park : 提供了阻塞线程的基本能力, 不会永久阻塞线程, 可用park_ timeout显式指定阻塞超时时间
    - unpark : 将阻塞的线程重启
    - yield_now : 主动出让当前线程时间片

- 线程同步 : 在 std::sync 模块中定义了锁、 channel 、条件变量和屏障

#### 同步共享数据
与 C++ 不同，Rust 中受保护的数据保存在 Mutex 内部. rust有互斥锁`Mutex<T>`和读写锁`RwLock<T>`:
- RwLock读写锁：是多读单写锁，也叫共享独占锁. 它允许多个线程读，单个线程写。但是在写的时候，只能有一个线程占有写锁；而在读的时候，允许任意线程获取读锁。读锁和写锁不能被同时获取

    它和RefCell一样，遵循这些规则:
    - 很多.read()变量可以
    - 一个.write()变量可以
    - 但多个.write()或.read()与.write()一起是不行的

    可使用std::mem::drop(mutex_changer)手动去除锁定
- Mutex互斥锁：只允许单个线程读和写

    Mutex在MutexGuard超出范围时就会被解锁, 但也可使用std::mem::drop(mutex_changer)手动超出MutexGuard范围.

> Mutex 的实现依赖于 CPU 提供的 atomic, 可以把 Mutex 想象成一个粒度更大的 atomic，只不过这个 atomic 无法由 CPU 保证，而是通过软件算法来实现.

> SpinLock 和 Mutex 最大的不同是，使用 SpinLock，线程在忙等（busy wait），而使用 Mutex lock，线程在等待锁的时候会被调度出去，等锁可用时再被调度回来.

> 在实践中，Condvar 往往和 Mutex 一起使用：Mutex 用于保证条件在读写时互斥，Condvar 用于控制线程的等待和唤醒

> 条件变量用来自动阻塞一个线程, 直到出现指定的条件, 通常和互斥锁配合使用. 在运行中每个条件变量每次只能和一个互斥体一起使用.

```rust
use std::sync::Arc;
use std::thread;
fn main() {
    let nums = Arc::new(vec![0, 1, 2, 3, 4]);
    let mut childs = vec![];
    for n in 0..5 {
        let ns = Arc::clone(&nums); // ns是一个包含所有权的 Arc<Vec<i32>>值, 该值引用相同的 Vec
        let c = thread::spawn(move || {
            println!("{}", ns[n]);
        });
        childs.push(c);
    }

    for c in childs {
        c.join().unwrap();
    }
}
/* output:
4
2
1
0
3
*/
```

通过 Arc 和 Mutex 实现共享可变性:
```rust
use std::sync::{Arc, Mutex};
use std::thread;
fn main() {
    let vec = Arc::new(Mutex::new(vec![]));
    let mut childs = vec![];
    for i in 0..5 {
        let v = vec.clone();
        let t = thread::spawn(move || {
            let mut v = v.lock().unwrap();
            v.push(i);
        });
        childs.push(t);
    }
    for c in childs {
        c.join().unwrap();
    }
    println!("{:?}", vec);
}
/* output:
Mutex { data: [0, 1, 2, 3, 4], poisoned: false, .. }
*/
```
#### 通过消息传递进行通信
不要通过共享内存来通信，而应该使用通信来共享内存.

基于消息通信的并发模型主要有两种 Actor 模型和 CSP 模型. Actor 模型的代表语言是Erlang, 而 CSP 模型的代表语言是Go. 这两种并发模型的区别如下:
- 在Actor 模型中, 主角是 Actor, Actor 之间直接发送、接收消息; 而在 CSP 模型中, 主角是 Channel 其并不关注谁发送消息、谁接收消息
- Actor 模型中, Actor 之间是直接通信的; 而 CSP 模型中, 依靠 Channel 来通信
- Actor 模型的耦合程度要高于 CSP 模型. 因为 CSP 模型不关注消息发送者和接收者

rust支持了CSP模型. CSP 模型的基本构造是 CSP 进程和通信通道.

std::sync::mpsc 模块提供了一个无锁定的**多生产者、单订阅者（消费者）的FIFO队列**, 作为希望彼此通信的线程的共享消息队列.

在标准库 std::sync::mpsc 模块中定义了以下3种类型的 CSP 进程：
- Sender : 用于发送异步消息
- SyncSender : 用于发送同步消息
- Receiver : 用于接收消息

mpsc 模块标准库包含两种通道:
1. channel：一个异步的无限缓冲通道

	使用默认的异步通道时, send 方法永远不会阻塞, 这是因为通道缓冲区是无限的(实际受限于内存).
1. sync_channel：一个同步的有界缓冲通道

	同步通道有一个有界缓冲区, 当它被填满时, send 方法会被阻塞, 直到通道中出现更多空间.

Sender和Receiver 之间的消息传递是原子操作. Channel 之间的发送或接收操作都会返回一个 Result 类型用于错误处理. 当 Channel 发生意外时会返回Err, 所以通常使用 unwrap 在线程间传播错误, 及早发现问题.

> 只有两个线程通信的 Channel, 叫流通道(Streaming Channel), 在流通道内部, 实际上 Rust 会默认使用单生产者单消费者队列(SPSC)来提升性能.

> 多生产者单消费者的 Channel 叫作共享通道(Sharing Channel).

> 在底层不管是 SPSC 还是 MPSC 队列, 甚至是同步 Channel 使用的内置独立的队列, 都是基于链表实现的

对于这两种通道类型，如果通道是空的，那么 recv 调用会返回 Err 值.

channel:
```rust
use std::sync::mpsc::channel;
use std::thread;
fn main() {
    let (tx, rx) = channel(); // tx 是包含 Sender<T>类型的发送端, rx 是包含 Receiver<T>类型的接收端
    let join_handle = thread::spawn(move || {
        while let Ok(n) = rx.recv() {
            println!("Received {}", n);
        }
    });
    for i in 0..10 {
        tx.send(i).unwrap();
    }
    join_handle.join().unwrap();
}
/* output:
Received 0
Received 1
Received 2
Received 3
Received 4
Received 5
Received 6
Received 7
Received 8
Received 9
*/
```

sync_channel:
```rust
use std::sync::mpsc;
use std::thread;
fn main() {
    let (tx, rx) = mpsc::sync_channel(1);
    let tx_clone = tx.clone();
    let _ = tx.send(0);
    thread::spawn(move || {
        let _ = tx.send(1);
    });
    thread::spawn(move || {
        let _ = tx_clone.send(2);
    });
    println!("Received {} via the channel", rx.recv().unwrap());
    println!("Received {} via the channel", rx.recv().unwrap());
    println!("Received {} via the channel", rx.recv().unwrap());
    println!("Received {:?} via the channel", rx.recv());
}
/* output:
Received 0 via the channel
Received 2 via the channel
Received 1 via the channel
Received Err(RecvError) via the channel
*/
```

#### 线程安全
线程安全指没有数据争用和其他未定义行为.

Rust 代码的彻底安全取决于两个内置特型`std::marker::Send`和`std::marker::Sync`:
- 实现 Send 的类型, 可以安全地在钱程间传递所有权, 即可跨线程移动.
- 实现 Sync 的类型, 可以安全地在结程间传递不可变借用, 即可跨线程共享.

这两个标记 trait 反映了rust看待线程安全的哲学: 多线程共享内存并非线程不安全问题所在, 问题在于错误地共享数据.

和 `Send/Sync` 相反的标记是`!Send/!Sync`, 表示不能在线程间安全传递的类型.

Send类型包含Sync类型.

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T + Send + 'static,
    T: Send + 'static,
```

spawn 是一个包含 F 和 T 的泛型函数, 并且会接收一个参数 f, 返回的泛型是JoinHandle<T>. 随后的 where 子句指定了多个trait限制:
- F:FnOnce() -> T + Send + 'static：这表示 F 实现了一个只能被调用一次的闭包. 换句话说， f 是一个闭包，通过值获取所有内容并移动从环境中引用的项. 同时表示闭包必须是发送型（ Send），并且必须具有'static 的生命周期，同时执行环境中闭包内引用的任何类型必须是发送型，必须在程序的整个生命周期内存活。
- T:Send + 'static：来自闭包的返回类型 T 必须实现 Send+'static 特征. `'static` 限定表示类型T只能是非引用类型即拥有所有权(除`&'static`之外), 因为使用引用无法保证生命周期.

> 使用支持 Send/Sync 的 Arc 和 Mutex 一起，可以构造一个可以在多线程间共享且可以修改的类型

Send 是一种标记性特征。它只用于类型级标记，意味着可以安全地跨线程发送值即在线程之间发送是安全的；并且大多数类型都是发送型。未实现 Send 特征的类型是指针、引用等。此外， Send 是自动
型特征或自动派生的特征。复合型数据类型，例如结构体，如果其中的所有字段都是 Send型，那么该结构体实现了 Send 特征.

在 Rust 中，编译器可保证在线程中安全使用和引用类型. 这些保证被实现为特征，即 Send 和 Sync 特征.

Send 类型可以安全地发送到多个线程，这表明该类型是一种移动类型. 非 Send 类型的是指针类型，例如&T，除非 T 是 Sync 类型.

如果某些类型是 Sync 类型，那么指向它的引用即相关的&T 是 Send 类型, 这意味着可以将对它的引用传递给多线程即在线程之间共享它的引用是安全的.

少数没有实现 Send 和 Sync 的类型主要用于在非线程安全的条件下提供可修改能力. 例如引用计数智能指针类型`std::rc::Rc<T>`. 当两个线程都会执行`(Rc<T>).clone()`增加共享引用计数, 但引用计数可能是不准确的, 因为出现了数据争用, 从而导致未定义行为.

几乎所有类型都是 Send 和 Sync 的, 唯一值得注意的 !Sync 是 Rc、Cell 和 RefCell. 如果需要一个 Rc 的 Send 版本, 可以使用 Arc. 如果需要 Cell 或 RefCell 的 Sync 版本，可以 Mutex 或 RwLock. 虽然使用 Mutex 或 RwLock 只是包裹一个原语类型，通常最好使用标准库提供的原子原语类型，如 AtomicBool、AtomicI32、AtomicUsize 等.

### async/await
异步编程的发展经历了三个阶段:
1. 第一个阶段 : 直接使用回调函数, 随之带来的问题是"回调地狱"
1. 第二个阶段 : 使用 Promise/Future 并发模型, 解决了回调函数的问题, 但是代码依旧有很多冗余

    Future 一种异步并发模式，它实际上是代理模式和异步开发的混合产物.

    Rust 对Future 异步并发模式做了一个完整的抽象, 包含在第三方库 futures-rs中, 该抽象主要包含三个部件:
    - Future : 基本的异步计算抽象单元
    - Executor : 异步计算调度层
    - Task : 异步计算执行层
1. 第三个阶段 : 利用协程实现 async/await 解决方案, 号称"异步的终极解决方案"

    如果要支持 async/await异步开发, 最好是能有协程的支持. 所以 Rust 第一步是实现了协程(Coroutine).

    协程一般分为两种: 其中一种是有栈协程（ Stackful ）; 另一种是 无栈协程( Stackless). 对于有栈协程的实现, 一般每个协程都自带独立的栈, 功能强大, 但是比较耗内存, 性能不如无栈协程. 无栈协程一般是基于状态机（ State Machine) 来实现, 不使用独立的栈, 具体的应用形式叫生成器(Generator) . 常见的有ES 6和Python 语言支持生成器. 这种形式的协程性能更好, 而功能要弱于有栈协程, 但够用. Rust 标准库实现了无栈协程, 其生成器语法像闭包，其实现原理也和闭包类似.

    Rust 当前以 async 关键字配合 await! 宏来提供 async/await 异步开发方案. 在不久的将来, await 会变成关键字.
    async/await实际上是一种语法糖. async_fu 会自动为开发者生成返回值是 impl Future类型的函数.

    只不过 JavaScript 的 Promise 和线程类似，一旦创建就开始执行，对 Promise await 只是为了“等待”并获取解析出来的值；而 Rust 的 Future，只有在主动 await 后才开始执行.

    一般而言，async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行. 大多数语言，包括 Rust，async/await 都是一个语法糖（syntactic sugar），它们使用状态机将 Promise/Future 这样的结构包装起来进行处理. rust 是 async 来方便地生成 Future，await 来触发 Future 的调度和执行

### 数据并行
并行分任务并行(Task Parallelism)和数据并行(Data Parallelism). 任务并行是指将所需要执行的任务分配到多个核上; 数据并行是指将需要处理的数据分配到多个核上. 数据并行处理起来比任务并行更加简单和实用.

编写 SIMD 数据并行的代码称为向量化（Vectorization). 这是因为向量（ Vector)是一个指令操作数, 包含一组打包到一维数组的数据元素. 大多数 SIMD 令都是对向量操作数进行操作的, 所以向量也被称为 SIMD 操作数或打包操作数. 数据并行意昧着可以同时对向量的所有数据元素执行变换操作. 所以将编写程序使用向量处理器的过程, 称为向量化、
矢量化或 SIMD 化. 向量化可以由编译器自动优化, 也可以由程序员手动指定.

Rust 通过标准库 std::arch和第三方库 stdsimd 结合的方式来支持 SIMD. 社区中还有很多 simd库, 其中比较突出的是 faster和simdeez, 相比于 stdsimd 做了更进一步的抽象, 对开发者友好.

rust除了手动使用内置的平台函数向量化代码, 还可以利用 LLVM 自动向量化.

## unsafe
Unsafe Rust是Safe Rust一个超集. 因此在 Unsafe Rust 中, 并不会禁用 Safe Rust 中的任何安全检查.

unsafe不过是把 Rust 编译器在编译器做的严格检查退步成为 C++ 的样子, 由开发者自己为其所撰写的代码的正确性做担保.

使用 unsafe 的场景，根据重要 / 常用程度，会依次介绍：实现 unsafe trait，主要是 Send / Sync 这两个 trait、调用已有的 unsafe 接口、对裸指针做解引用，以及使用 FFI.

>  unsafe 块是 Rust 提供的可选机制，专为安全责任自负的程序员使用高级语言特性提供

rust只允许少数几个地方用 unsafe 关键字进行标记:
- 函数和方法
- 不安全的代码块表达式，例如 unsafe{}
- 特征

	动机:
	1. 标记无法发送到线程或在线程之间共享的类型.
	1. 封装一系列类型可能具有未定义行为的操作
- 实现代码块

unsafe 块支持:
1. 可以调用 unsafe 函数和方法
1. 可以解引用原始指针

	原始指针本质上等价于 C 或 C++ 指针，有两种原始指针:
	- `*mut T` 是一个指向 T 且允许修改其引用目标的原始指针
	- `*const T` 是一个指向 T 但只允许读取其引用目标的原始指针

    原生指针具有以下特点:
    - 并不保证指向合法的内存, 比如很可能是空指针
    - 不能像智能指针那样自动清理内存. 需要像C语言那样手动管理
    - 没有生命周期的概念, 编译器不会对其提供借用检查
    - 不能保证线程安全

    原生指针是 Unsafi Rust 中最常用的, 它主要有以下两种用途:
    - 在需要的时候跳过 Rust 安全检查. 有些情况下, 程序逻辑完全不会有任何内存安全问题, 使用原生指针就可以避免那些不必要的安全检查, 从而提升性能
    - 与C语言"打交道", 需要使用原生指针

    标准库为原生指针内建了很多方法和函数, 常见有:
    - std::ptr::null 函数和 is_null 方法
    - offset 方法
    - read/write 方法
    - ep ce/swap 方法

	Rust 虽然会在各种情况下隐式解引用安全指针类型，但原始指针必须显式解引用.
1. 可以访问可变 static 变量
1. 可以访问通过 Rust 的外来函数接口声明的函数和变量. 即使是不可修改的，这些函数和变量也会被认为是不安全的. 因为它们对其他语言写的代码是可见的，而那些代码不一定遵守 Rust 的安全规则.

Unsafe Rust和Safe Rust 的区分带来以下三方面结果：
- Unsafe Rust 由于不需要安全检查, 意味着有一定的性能提升
- Unsafe Rust 内存安全完全交由开发者来保证, 否则会出现未定义行为
- 区分了编译器和开发者的职责, 如果代码出现了问题, 可以先排查 Unsafe Rust代码

unsafe用法:
- unsafe 关键字 : 用于标记（或者说声明）函数、方法和 trait
- unsafe 块 : 用于执行 Unsafe Rust 允许的操作

rust 社区的指导 Safe 和 Unsafe Rust 代码混合编程中保证内存安全三大原则:
- 不安全的组件不应该削弱其安全性，特别是公共的 API 数据结构
- 不安全的组件应该尽可能小，并与安全组件分离（隔离和模块化）
- 不安全的组件应该明确标记并轻松升级

### FFI(Foreign Function Interface, 外部函数接口)
FFI 技术的主要功能就是将一种编程语言的语义和调用约定与另一种编程语的语义和调用约定相匹配.

调用约定如何匹配, 与应用程序二进制 ABI 高度相关.

ABI是一个规范, 主要涵盖以下内容:
- 调用约定 : 一个函数的调用过程本质就是参数、函数、返回值如何传递. 编译器按照调用规则去编译, 把数据放到相应的堆栈中, 函数的调用方和被调用方（函数本身）都需要遵循这个统一的约定.
- 内存布局 : 规定了大小和对齐方式
- 处理器指令集 : 不同平台的处理器指令集不同
- 目标文件和库的二进制格式

ABI 规范由编译器、操作平台、硬件厂商等共同制定. ABI 是二进制层面程序兼容的契约, 只有拥有相同的 ABI , 来自不同 编译器间的库才可以相互链接和调用, 否则将无法链接, 或者即使可以链接, 也无法正确运行.

目前 C ABI 是唯一通用的稳定的标准ABI.

Rust 提供了 extern 语法使得 FFI 常便于使用:
- extern 关键字 : 通过 extern 关键字声明的函数, 可以 在Rust和C语言中自由使用
- extern : 如果在 Rust 中调用C代码, 则可以使用 extern块, 将外部的C函数进行逐个标记, 以 便Rust 内部调用.

编译器会根据 extern 自动在 Rust ABI和 C ABI 之间切换.

配合使用了`#[repr(C)]`属性是必需的, 它会告 Rust编译器生成和C语言一样的内存布局.

在Rust中调用C和C++的类型对照:
|C类型| 对应的std::os::raw类型|
|short| c_short|
|int |c_int|
|long |c_long|
|long long| c_longlong|
|unsigned short |c_ushort|
|unsigned、unsigned int| c_uint|
|unsigned long |c_ulong|
|unsigned long long |c_ulonglong|
|char |c_char|
|signed char |c_schar|
|unsigned char| c_uchar|
|float |c_float|
|double| c_double|
|`void *`、`const void *`| `*mut c_void`、`*const c_void`|

把 Rust 代码编译成 C 库, 在通过Rust shim来调用.

Rust shim 主要做四件事情:
1. 提供 Rust 方法、trait 方法等公开接口的独立函数。注意 C 是不支持泛型的，所以对于泛型函数，需要提供具体的用于某个类型的 shim 函数
1. 所有要暴露给 C 的独立函数，都要声明成 #[no_mangle]，不做函数名称的改写
1. 数据结构需要处理成和 C 兼容的结构
1. 要使用 catch_unwind 把所有可能产生 panic! 的代码包裹起来