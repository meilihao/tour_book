# rust  
#### trait 作为参数
impl Trait 语法适用于直观的例子，它实际上是一种较长形式语法的`trait bound`语法糖.

```rust
pub fn notify(item: impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// trait bound形式
pub fn notify<T: Summary>(item: T) { // 同上
    println!("Breaking news! {}", item.summarize());
}

pub fn notify(item: impl Summary + Display) {}
pub fn notify<T: Summary + Display>(item: T) {} // 同上

fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {}
fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{} // 同上
```

#### 使用 trait bound 有条件地实现方法
- 通过使用带有 trait bound 的泛型参数的 impl 块，可以有条件地只为那些实现了特定 trait 的类型实现方法

    ```rust
    use std::fmt::Display;

    struct Pair<T> {
        x: T,
        y: T,
    }

    impl<T> Pair<T> {
        fn new(x: T, y: T) -> Self {
            Self {
                x,
                y,
            }
        }
    }

    impl<T: Display + PartialOrd> Pair<T> {
        fn cmp_display(&self) {
            if self.x >= self.y {
                println!("The largest member is x = {}", self.x);
            } else {
                println!("The largest member is y = {}", self.y);
            }
        }
    }
    ```
- 对任何实现了特定 trait 的类型有条件地实现 trait. 对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations, 它们被广泛的用于 Rust 标准库中. 例如，标准库为任何实现了 Display trait 的类型实现了 ToString trait: `impl<T: Display> ToString for T {}`.




### `std::error::Error`
`std::error::Error`方法:
- err.description() : 返回 &str 类型的错误消息
- err.cause() : 返回一个 Option<&Error>，这是触发 err 的底层错误（如果有的话）

## 类型系统














## 数据类型


随着类型越来越丰富, 值类型和引用类型难以描述全部情况, rust所以引入了：
- 值语义（Value Semantic）

    复制以后，两个数据对象拥有的存储空间是独立的，互不影响

    基本的原生类型都是值语义，这些类型也被称为 POD（Plain old data）. POD 类型都是值语义，但是值语义类型并不一定都是 POD 类型

    具有值语义的原生类型，在其作为右值进行赋值操作时，**编译器会对其进行按位复制**

- 引用语义（Reference Semantic）

    复制以后，两个数据对象互为别名. 操作其中任意一个数据对象，则会影响另外一个.

    智能指针Box<T>封装了原生指针，是典型的引用类型. Box<T>无法实现 Copy，意味着它被 rust 标记为了引用语义，禁止按位复制.

    引用语义类型不能实现 Copy，但可以实现 Clone 的 clone 方法，以实现深复制.


在 Rust 中，可以通过是否实现 Copy trait 来区分数据类型的值语义和引用语义. 但为了更加精准，Rust 也引用了新的语义：复制（Copy）语义和移动（Move）语义
- Copy语义：对应值语义, 即实现了 Copy 的类型在进行按位复制时是安全的
- Move语义：对应引用语义, 在 Rust 中不允许按位复制，只允许移动所有权

实现了 Copy trait的作用: 实现 Copy trait 的类型同时拥有复制语义，在进行赋值或者传入函数等操作时，默认会进行按位复制.

对于默认可以安全的在栈上进行按位复制的类型，就只需要按位复制，也方便管理内存.
对于默认只可在堆上存储的数据，必须进行深度复制. 深度复制需要在堆内存中重新开辟空间，这会带来更多的性能开销.

#### 哪些实现了 Copy
- 结构体 ：当成员都是复制语义类型时，不会自动实现 Copy
- 枚举体 ：当成员都是复制语义类型时，不会自动实现 Copy
- 元组类型 ：本身实现了 Copy. 如果元素均为复制语义类型，则默认是按位复制，否则执行移动语义
- 字符串字面量 &str： 支持按位复制

结构体 && 枚举体：
1. 所有成员都是复制语义类型时，需要添加属性#[derive(Debug,Copy,Clone)]来实现 Copy
1. 如果有移动语义类型的成员，则无法实现 Copy

#### 哪些未实现 Copy
String ：to_string() 可以将字符串字面量转换为String

#### 哪些实现了 Copy trait
原生整数类型

对于实现 Copy 的类型，其 clone 方法只需要简单的实现按位复制即可.

#### 哪些未实现 Copy trait
- Box<T>

## 类型
Rust 支持类型推导，在编译器能够推导类型的情况下，变量类型一般可以省略，但常量（const）和静态变量（static）必须声明类型.

静态值不像常量那样是内联的，当读取和写入静态值时，需要用到 unsafe 代码块. 静态值通常与同步原语搭配使用，它们还用于实现全局锁定，以及与 C 程序库集成.

通常，如果不需要依赖静态的单例属性及其预定义的内存位置，而只需要其具体值，那么应该更倾向于使用常量。它们允许编译器进行更好的优化，并且更易于使用.

全局值只能在初始化时声明非动态的类型，并且在编译期，它在堆栈上的大小是已知的。但 lazy_static!宏，可用于初始化任何能够从程序
中的任何位置全局访问的动态类型。

使用 lazy_static!宏声明的元素需要实现 Sync 特征。这意味着如果某个静态值可变，那么必须使用诸如 Mutex 或 RwLock 这样的多线程类型，而不是 RefCell.

Rust 函数参数的类型和返回值的类型都必须显式定义, 如果没有返回值可以省略, 返回`unit即空元组`. 函数内部如果提前返回, 需要用 return 关键字, 否则最后一个表达式就是其返回值. 如果最后一个表达式后添加了`;`, 隐含其返回值为 unit.

### 标量类型(scalar type)数据
#### 整型
#### 浮点型
#### 布尔类型
#### 字符类型
ref:
- [字符串操作 - 《Rust程序设计 - 17.3 String与str》]()

char : 单个字符, 大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value）.

处于内存安全考虑, rust将字符串分为两种:
- [str](https://github.com/rust-lang/rust/blob/master/library/core/src/str/mod.rs#L122)字符串(也叫字符串切片, 内置类型, 是DST类型), 固定长度的字符串, 通常以不可变借用的形式存在(`&str`)

    rust字符串因为包含长度, 因此不是以`\0`表示结束.

    `&str`字符串类型由两部分组成：
    1. 指向字符串序列的指针
    2. 记录长度的值

    `&str`存储于栈上, str字符串序列存储于程序的静态只读数据段, 栈或者堆内存中. `&str`是一种胖指针.

    > str 是编译器能够识别的内置类型, 表示有限但大小未知的 UTF-8 编码的连续字节序列, 因此str在堆上, 并且不属于标准库.
- String字符串, 长度可变的字符串, 在堆上分配, 与`&str`的主要区别是它有管理内存空间的能力, 而`&str`没有.

    创建方法: `let s = String::from("hello")`, 两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字.

    String类型本质是一个成员变量为`Vec<u8>`类型的结构体，所以它是直接将字符内容存放于堆中的.

    String类型由三部分组成：
    - 执行堆中字节序列的指针（as_ptr方法）
    - 记录堆中字节序列的字节长度（len方法）
    - 堆分配的容量（capacity方法）

    基础类型变String:
    ```rust
    let one = 1.to_string();         // 整数到字符串
    let float = 1.3.to_string();     // 浮点数到字符串
    let slice = "slice".to_string(); // 字符串切片到字符串
    ```

    其他用法:
    ```rust
    fn main() {
        let s = String::from("hello中文");
        for c in s.chars() { // 等同go的 `range []rune(s)`
            println!("{}", c);
        }
    }
    ```

`& 'static str`是静态生命周期字符串. 静态生命周期即程序生命周期.

rust字符串的本质是一段有效的utf8字节序列.

Rust中的字符串不能使用索引访问其中的字符，但可以通过bytes和chars两个方法来分别返回按字节和按字符迭代的迭代器.

Rust提供了另外两种方法：get和get_mut来通过指定索引范围来获取字符串切片.

#### 引用/指针
引用是用`&`和`& mut`操作符来创建, 受Rust的安全检查规则的限制.

引用是Rust提供的一种无所有权的指针语义, 引用的生命期不能超过其引用的资源. 引用是基于指针的实现，它与指针的区别是：指针保存的是其指向内存的地址，而引用可以看做某块内存的别名（Alias）.

裸指针(原生指针):`*const T和*mut T`, 可以在unsafe块下任意使用, 不受Rust的安全检查规则的限制.

智能指针实际上是一种结构体，只是行为类似指针, 智能指针是对指针的一层封装，提供了一些额外的功能，比如自动释放堆内存.

> rust在堆上分配内存的唯一方法是通过智能指针类型.

> rustc自身使用jemalloc,而其构建的lib和bin使用系统内存分配器.

智能指针区别于常规结构体的特性在于：它实现了Deref和Drop这两个trait:
- Deref：提供了解引用能力
- Drop：提供了自动析构的能力

智能指针拥有资源的所有权，而普通引用只是对所有权的借用.

rust指针包括 引用(reference), 原生指针(raw pointer), 函数指针(fn pointer)和智能指针(smart pointer).
引用的本质是非空指针.

解引用deref: 解引用会获得所有权, 解引用操作符是`*`.



### 方法
不过方法与函数是不同的, 因为它们在结构体的上下文中被定义(或者是枚举或 trait 对象的上下文).

impl 块的另一个有用的功能是: 允许在 impl 块中定义不以 self 作为参数的函数, 这被称为 关联函数（associated functions, 在主流的编程语言中, 这也被称为静态方法）, 因为它们与结构体相关联. 它们仍是函数而不是方法, 因为它们并不作用于一个结构体的实例. 比如`String::from`关联函数. 它类似于面向对象编程语言中的静态方法. 这些方法在类型自身上即可调用, 并且不需要类型的实例来调用, 调用方法是`<类型名>::<函数名>`

> 结构体允许拥有多个 impl 块.

impl实例方法的变体, 根据限制由少到多排列的:
- &self 作为第一个参数, 此方法仅提供对类型实例的读取访问权限
- &mut self 作为第一个参数, 此方法提供对类型实例的可变访问
- self 作为第一个参数, 这些方法拥有调用它的实例的所有权，并且类型在后续调用时将失效

### enumerations、enums枚举
> Rust 的枚举与 F#、OCaml 和 Haskell 这样的函数式编程语言中的 代数数据类型（algebraic data types）最为相似

### 泛型
泛型就是把一个泛化的类型作为参数.

> C++ 语言中用"模板"来实现泛型. 泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等.

与枚举类型额函数一样,结构体名称旁边的`<T>`叫做泛型声明. 泛型只有被声明之后才可以实现.

```rust
struct Point<T> { x: T, y: T}
impl<T> Point<T> {
    fn new(x: T,y: T) -> Self {
        Point{x:x, y:y}
    }
}
fn main() {
    let p1 = Point::new(1,2);
    let p1 = Point::new("1","2");   
}
```

### 常见trait
- std::ops 模块的 Add : 允许使用`+`运算符将两个复数相加。
- std::convert 模块的 Into 和 From : 使用户能够根据其他类型创建复数类型。
- Display : 使用户能够输出人类可读版本的复数类型


Rust 标准库针对输入和输出的特性是通过 3 个特型，即 Read、BufRead 和 Write, 见[字符串操作 - 《Rust程序设计 - 18 输入与输出》]()

### 宏
宏语句可以使用圆括号, 中括号, 花括号, 一般使用中括号表示数组.

### 语法
字符串 slice（string slice）是 String 中一部分值的引用. 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.
字符串字面值就是 slice, 是一个指向二进制程序特定位置的 slice.
通用slice跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度.

#### 函数
在Rust中，函数定义以fn关键字开始并紧随函数名称(按小写字母以下划线分割)与一对圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方. 使用函数名加圆括号的方式来调用函数.

> 函数体由一系列的语句和一个可选的结尾表达式构成.

> Rust不关心在何处定义函数，只要这些定义对于使用区域是可见的即可, 这与go相同, 与c不同.

在函数签名中，必须声明每个参数的类型. 函数不支持自动返回值类型判断, 如果没有明确声明函数返回值的类型, 函数将被认为是"纯过程"即不允许产生返回值, 因此return 后面不能有返回值表达式.

> **参数变量和传入的具体参数值有自己分别对应的名称parameter和argument, 即形参和实参**.

rust并不对返回值命名，但要在`箭头（->）`后声明它的类型.
**在 Rust 中，函数的返回值等同于函数体最后一个表达式的值, 因此rust允许省略return**.
rust不支持多返回值, 但可以利用元组来返回多个值.

```rust
fn main() {
    let x = plus_one(5);
}
fn plus_one(x: i32) -> i32 {
    x + 1
}
// 错误: 在包含 x + 1 的行尾加上一个分号，把它从表达式变成语句. 语句并不会返回值，使用空元组 () 表示不返回值. 因为不返回值与函数定义相矛盾，从而出现一个错误.
// fn plus_one(x: i32) -> i32 {
//     x + 1;
// }
```

函数的第一个参数如果是Self相关的类型, 且命名为`self`, 那么这个参数就是receiver. 有receiver的函数即为方法(method), 用`变量实例.方法名`来调用.
没有receiver参数的函数是静态函数(static function), 通过类型加`::`的方式调用.

#### 所有权(ownership)
所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全. **所有权的存在就是为了管理堆数据**.

所有运行的程序都必须管理其使用计算机内存的方式. 一些语言中具有垃圾回收机制(go, java等)，在程序运行时不断地寻找不再使用的内存；在另一些语言中(c, c++等)，开发者必须亲自分配和释放内存. Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在**编译时**会根据一系列的规则进行检查, 在运行时，所有权系统的任何功能都不会减慢程序.

所有权本质上就是在语言层面禁止了同一个可变数据会有多个变量引用的情况, 一旦作为参数传递了, 就会发生所有权的移动（Move）或借用（Borrow）, 即从根本上杜绝了并发情景下的数据共享冲突.

> 变量范围是变量的一个属性, 其代表变量的可行域, 默认从声明变量开始有效直到变量所在域结束.

> Rust 之所以没有明示释放变量的步骤是因为在变量范围结束的时候, 其编译器自动添加了调用释放资源函数的步骤.

> rust的栈中的所有数据都必须占用已知且固定的大小, 在编译时大小未知或大小可能变化的数据会分配到堆上.

Rust中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者.

在进行赋值操作时，对于可以实现Copy的复制语义类型，所有权并未改变. 对于复合类型来说，是复制还是移动，取决于其成员的类型.

所有权的规则:
- Rust 中的每一个值都有一个被称为其所有者（owner）的变量
- 值在任一时刻有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃

    内存在拥有它的变量离开作用域后就被自动释放(调用`drop`方法)

    在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）, 即本质是将资源的生命周期和对象的生命周期绑定.

    > 在推断所有权规则时，作用域是一个非常重要的属性, 它也会被用来推断借用和生命周期

这三条规则很好理解, 核心就是保证单一所有权. 其中第二条规则讲的所有权转移是 Move 语义, Rust 从 C++ 那里学习和借鉴了这个概念.

rust 内存回收策略：内存在拥有它的变量离开作用域后就被自动释放.

所有权规则解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势.

```rust
#[derive(Debug)]
struct Foo(u32);

fn main() {
    let foo = Foo(2048);
    let bar = foo;
    println!("Foo is {:?}", foo); // 报错: foo已被move给bar
    println!("Bar is {:?}", bar);
}
```

```rust
fn main() {
    let foo = 4623;
    let bar = foo;
    println!("{:?} {:?}", foo, bar); // 正常
}
```

```rust
#[derive(Copy, Clone, Debug)]
struct Dummy;

fn main() {
    let a = Dummy;
    let b = a;
    println!("{}", a); // 正常, 因此Dummy有实现Copy
    println!("{}", b);
}
```

所有权也让代码变得复杂, 如果要**避免所有权转移之后不能访问**的情况, 一般需要手动复制, 编写麻烦且效率不高, 因此rust提供了两种解决方法:
1. Rust 提供了 Copy 语义. 如果一个数据结构实现了 Copy trait，那么它就会使用 Copy 语义. 这样, **在赋值或者传参**时, 值会自动**按位拷贝**（浅拷贝）.

    Copy: 默认情况下，通过变量分配或访问，以及从函数返回时复制的值（例如按位复制）具有复制语义. 这意味着该值可以使用任意次数，每个值都是全新的. 

    等同于go的值传递.

    > Clone是Copy的父trait.

    > 默认情况下, C++具有复制语义. 后来的C++ 11 版本提供了对移动语义的支持.

1. 无法使用 Copy 语义，那可以`借用`数据

变量与数据交互的方式:
1. move

    > 当以转移所有权的方式给函数传参时，称其为传值（by value）。如果传给函数的是对值的引用，则称其为传引用（by reference）.

    在 Rust 中，对多数类型而言，给变量赋值、给函数传值或从函数返回值这样的操作不会复制值, 而是转移（move）值.

    移动: 通过变量访问或重新分配给变量时移动到接收项的值表示移动语义. 由于Rust 的仿射类型系统，它默认会采用移动语义. 仿射类型系统的一个突出特点是值或资源只能使用一次，而 Rust 通过所有权规则展示此属性.

    默认情况下，所有类型都有“移动语义”，但是一旦一个类型实现了 `Copy'，它就会得到`复制语义`.

    设计选择: **Rust 永远也不会自动创建数据的 “深拷贝”. 因此，任何 自动 的复制可以被认为对运行时性能影响较小.**

    仅在栈中的基本数据类型的数据的"移动"方式是直接复制, 这不会花费更长的时间或更多的存储空间, "基本数据"类型有这些：

    - 所有整数类型: i32 、 u32 、 i64 等
    - 布尔类型 bool: true 或 false
    - 所有浮点类型: f32 和 f64
    - 字符类型 char
    - 仅包含以上类型数据的元组(Tuples)

    Rust会尽可能地降低程序的运行成本, 所以默认情况下, 长度较大的数据存放在堆中, 且采用移动的方式进行数据交互.

    > 在 match 表达式中，移动类型默认也会被移动.
1. Clone

    克隆仅在需要复制的情况下使用, 毕竟复制数据会花费更多的时间.
    由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 clone 来解决所有权问题.

    Clone的返回类型是 Self，而且函数不可能返回非固定大小的值，所以 Clone 特型本身扩展了 Sized 特型。这样就具有了将实现的 Self 类型绑定为 Sized 的效果.

    克隆一个值通常涉及创建该值所拥有一切内容的副本及分配内存，因此 clone 无论在时间消耗还是内存占用方面都可能比较昂贵.

Copy是一种自动化特征，大多数堆栈上的数据类型都自动实现了它. 它通常用于数据完全在栈上的变量的复制, 比如基元类型和不可变引用(&T); 否则Copy开销很大, 因为它需要从堆中复制数据. Copy 特征复制类型的方式与 C 语言中的 memcpy 函数类似，后者用于按位复制值。默认情况下不会为自定义类型实现 Copy 特征，因为 Rust 希望显式指定复制操作，并且要求开发人员必须选择实现该特征. 没有实现 Copy 特征的类型包括`Vec<T>、 String 和可变引用`等.

> 任何实现 Drop 特型的类型不能是 Copy。Rust 认为如果一个类型需要特殊的清理代码，那就一定需要特殊的复制代码，因此不能是 Copy

> 有一条经验规则，就是任何在值被清除后需要特殊处理的类型都不能是 Copy 类型。比如，Vec 需要释放其元素， File 需要关闭其文件勾柄，而 MutexGuard 需要解锁其互斥量。

> 用户定义的类型默认属于非 Copy 类型。如果自定义结构体的所有字段本身都是 Copy 类型，那可以在定义上方添加 #[derive(Copy, Clone)] 属性把这个类型标注成 Copy 类型;对于并非所有字段都是 Copy 类型的结构体，就算加这个属性也不管用, 编译器会报错.

Clone 特征用于显式复制, 并附带 clone 方法， 类型可以实现该方法以获取自身的副本.

Clone 与 Copy 的不同之处在于, 其中的赋值操作时Copy是隐式复制值, 要复制 Clone值，就必须显式调用 clone 方法. clone 方法是一种更通用的复制机制, Copy 是它的一个
特例，即总是按位复制.

String 和 Vec 这类元素很难进行复制, 只实现了 Clone 特征. 智能指针类型也实现了 Clone 特征, 它只是在指向堆上相同数据的同时复制指针和额外的元数据（例如引用
计数）.

涉及函数入参的所有权机制:
```rust
fn main() {
    let s = String::from("hello");
    // s 被声明有效

    takes_ownership(s);
    // s 的值被当作参数传入函数
    // 所以可以当作 s 已经被移动，从这里开始已经无效

    let x = 5;
    // x 被声明有效

    makes_copy(x);
    // x 的值被当作参数传入函数
    // 但 x 是基本类型，依然有效
    // 在这里依然可以使用 x 却不能使用 s

} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放


fn takes_ownership(some_string: String) {
    // 一个 String 参数 some_string 传入，有效
    println!("{}", some_string);
} // 函数结束, 参数 some_string 在这里释放

fn makes_copy(some_integer: i32) {
    // 一个 i32 参数 some_integer 传入，有效
    println!("{}", some_integer);
} // 函数结束, 参数 some_integer 是基本类型, 无需释放
```

涉及函数返回值的所有权机制:
```rust
fn main() {
    let s1 = gives_ownership();
    // gives_ownership 移动它的返回值到 s1

    let s2 = String::from("hello");
    // s2 被声明有效

    let s3 = takes_and_gives_back(s2);
    // s2 被当作参数移动, s3 获得返回值所有权
} // s3 无效被释放, s2 被移动, s1 无效被释放.

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    // some_string 被声明有效

    return some_string;
    // some_string 被当作返回值移动出函数
}

fn takes_and_gives_back(a_string: String) -> String {
    // a_string 被声明有效

    a_string  // a_string 被当作返回值移出函数
}
```

Rust 有一个叫做 Copy trait(类似深拷贝)的特殊注解，可以用在类似整型这样的**存储在栈上的类型上. 如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用**. Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait.

作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的. 默认支持 Copy 的类型有：
- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型, char
- 元组，当且仅当其包含的类型也都是 Copy 的时候. 比如 (i32, i32) 是 Copy 的，但 (i32, String) 就不是.

将值传递给函数在语义上与给变量赋值相似: 向函数传递值可能会移动或者复制，就像赋值语句一样. 返回值也可以转移所有权.

变量的所有权总是遵循相同的模式：将值赋给另一个变量时**移动**它 . 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有.

引用(`&`)语法可创建一个 指向 值 的引用，但是**并不拥有它**, **因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃**. 实质上"引用"是变量的间接访问方式, 且"引用"并没有在栈中复制变量的值. 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权.

引用举例:
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = &s1; // s2是s1的引用`&String`
    s2.push_str("oob"); // 错误，禁止修改租借的值
    let s3 = s1; //  报错. s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借
    println!("{}", s2);
}

// 改为:
fn main() {
    let s1 = String::from("hello");
    let mut s2 = &s1;
    let s3 = s1;
    s2 = &s3; // 使用前重新从 s3 租借所有权
    println!("{}", s2);
}

fn main() {
    let mut s1 = String::from("run");
    // s1 是可变的

    let s2 = &mut s1;
    // s2 是可变的引用

    s2.push_str("oob");
    println!("{}", s2);
}
```

可变引用与不可变引用相比除了权限不同以外, **可变引用不允许多重引用**, 但不可变引用可以.

Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生. 由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用.

垂悬引用（Dangling References）: 没有实际指向一个真正能访问的数据的指针（注意: 不一定是空指针，还有可能是已经释放的资源）, 比如:
```rust
fn main() {
    // 伴随着 dangle 函数的结束，其局部变量的值本身没有被当作返回值, 被释放了, 但它的引用却被返回, 这个引用所指向的值已经不能确定的存在, 因此会报错
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

**获取引用作为函数参数称为`借用(borrowing)`**.

引用默认不允许修改引用的值, 允许可变引用(`&mut`), 但可变引用有一个很大的限制：**在特定作用域中的特定数据有且只有一个可变引用. 这个限制的好处是 Rust 可以在编译时就避免数据竞争.数据竞争（data race）类似于竞态条件**，它可由这三个行为造成：
- 两个或更多指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

引用的规则:
1. 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用. 即任意时刻不能在拥有不可变引用的同时拥有该变量的可变引用.
2. 引用必须总是有效的.

除了引用, 另一个没有所有权的数据类型是 slice. slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合. 字符串 slice（string slice）是 String 中一部分值的引用. 字符串字面值就是 slice.

> 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出.

使用可变借用的前提是：出借所有权的绑定变量必须是一个可变绑定.

在所有权系统中，引用&x也可以称为x的借用（Borrowing）. 通过&操作符来完成所有权租借。所以引用并不会造成绑定变量所有权的转移.

引用在离开作用域之时，就是其归还所有权之时:
- 不可变借用（引用）不能再次出借为可变借用
- 不可变借用可以被出借多次
- 可变借用只能出借一次
- 不可变借用和可变借用不能同时存在，针对同一个绑定而言
- 借用的生命周期不能长于出借方的生命周期

核心原则：**共享不可变，可变不共享**

因为解引用操作会获得所有权，所以在需要对移动语义类型（如&String）进行解引用时需要特别注意.

> rust 有一个叫 自动引用和解引用（automatic referencing and dereferencing）的功能, 这与golang相同.

## slice
切片（Slice）是对数据值的部分引用. 切片用`&[T]`表示，其中 T 表示任意类型. 切片的引用是一个胖指针（fat pointer）.

```rust
x..y // [x, y) 的数学含义

..y // 等价于 0..y
x.. // 等价于位置 x 到数据结束
.. // 等价于位置 0 到结束
```

> str 是 Rust 核心语言类型, 就是字符串切片（String Slice）, 常常以引用的形式出现（&str）. String 类型是 Rust 标准公共库提供的一种数据类型, 它有所有权, 它的功能更完善——它支持字符串的追加、清空等实用的操作. String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（capacity）属性. String 和 str 都支持切片，切片的结果是 &str 类型的数据.

> 与go不同, rust slice没有cap, 且没法直接创建, 必须依赖数组或 Vec并通过引用来创建; Go 中使用`:`来引用片段, 而 Rust 使用 `..`.

## 生命周期
Rust 生命周期机制是与所有权机制同等重要的资源管理机制, 引入这个概念主要是应对复杂类型系统中资源管理的问题.

生命周期用于处理引用, 即Rust 中的所有**引用**都附加了生命周期信息. 生命周期定义了引用相对值的原始所有者的生存周期，以及引用
作用域的范围.

> 引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算. 但引用往往导致极其复杂的资源管理问题.

大多数情况下它是隐式的, 编译器通过分析代码来确定变量的生命周期. 在某些情况下, 编译器却不能确定变量的生命周期而需要开发者指明.

Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域. 大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样. 但当引用的生命周期可能以一些不同方式相互关联时，Rust 需要开发者使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的.

它是一类允许开发者向编译器提供引用如何相互关联的泛型. Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性. 它是 Rust 最与众不同的功能.

**生命周期纯粹是一个编译期构造**, 它可以帮助编译器确定某个引用有效的作用域, 并确保它遵循借用规则. 它可以跟踪诸如引用的来源，以及它们是否比借用值生命周期更长
这类事情. Rust 中的生命周期能够确保引用的存续时间不超过它指向的值.

Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的.

#### 生命周期注解语法
生命周期注释是描述引用生命周期的办法.

**生命周期注解并不改变任何引用的生命周期的长短**. 与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用. 生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期.

生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短. `'a` 是大多数人默认使用的名称. 生命周期参数注解位于引用的 & 之后，并有一个空格来将引用类型与生命周期注解分隔开.
```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

example:
```rust
fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str { // 让函数返回值的生命周期将与两个参数的生命周期一致
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}

fn main() {
    let r;
    {
        let s1 = "rust";
        let s2 = "ecmascript";
        r = longer(s1, s2);
        println!("{} is longer", r);
    }
}
```

单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的.

泛型、特性与生命周期协同:
```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

**生命周期也是泛型**.

#### 词法作用域（生命周期）
match、for、loop、while、if let、while let、花括号、函数、闭包都会创建新的作用域，相应绑定的所有权会被转移.

函数体本身是独立的词法作用域：
- 当复制语义类型作为函数参数时，会按位复制
- 如果是移动语义作为函数参数，则会转移所有权

借用规则： 借用方的生命周期不能长于出借方的生命周期.

非词法作用域生命周期(Non-Lexical Lifetime，NLL)

#### 生命周期参数
编译器的借用检查机制无法对跨函数的借用进行检查，因为当前借用的有效性依赖于词法作用域. 所以，需要开发者显式的对借用的生命周期参数进行标注.

显式生命周期参数
- 生命周期参数必须是以单引号开头；
- 参数名通常都是小写字母，例如：'a；
- 生命周期参数位于引用符号&后面，并使用空格来分割生命周期参数和类型

标注生命周期参数是由于borrowed pointers导致的. 因为有borrowed pointers，当函数返回borrowed pointers时，为了保证内存安全，需要关注被借用的内存的生命周期(lifetime).

标注生命周期参数并不能改变任何引用的生命周期长短，它只用于编译器的借用检查，来防止悬垂指针. 即：生命周期参数的目的是帮助借用检查器验证合法的引用，消除悬垂指针.

##### 函数签名中的生命周期参数
就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中.

下文的`'a`的实际含义是 foo 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致(即作用域相重叠的那一部分). 这就是开发者告诉 Rust 需要其保证的约束条件. 记住通过在函数签名中指定生命周期参数时， 并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝.

当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中. 这是因为 Rust 能够分析函数中代码而不需要任何协助，不过当函数引用或被函数之外的代码引用时，让 Rust 自身分析出参数或返回值的生命周期几乎是不可能的. 这些生命周期在每次函数被调用时都可能不同. 这也就是为什么需要手动标记生命周期.

```rust
fn foo<'a>(s: &'a str, t: &'a str) -> &'a str;
```
函数名后的<'a>为生命周期参数的声明. 函数或方法参数的生命周期叫做输入生命周期（input lifetime），而返回值的生命周期被称为输出生命周期（output lifetime）.

规则：
- 禁止在没有任何输入参数的情况下返回引用，因为会造成悬垂指针
- 从函数中返回（输出）一个引用，其生命周期参数必须与函数的参数（输入）相匹配，否则，标注生命周期参数也毫无意义.

对于多个输入参数的情况，也可以标注不同的生命周期参数.

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result); // 报错, 因为string2较长时, 到println!时, string2已被释放.
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

当从函数返回一个引用，**返回值的生命周期参数需要与一个参数的生命周期参数相匹配**. 如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域. 比如:
```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

针对这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用， 这样函数调用者就需要负责清理这个值了.

##### 方法定义中的生命周期参数
结构体中包含引用类型成员时，需要标注生命周期参数，则在impl关键字之后也需要声明生命周期参数，并在结构体名称之后使用.

```rust
impl<'a> Foo<'a> {
    fn split_first(s: &'a str) -> &'a str {
        …
    }
}

struct Decoder<'a, 'b, S, R> {
    schema: &'a S,
    reader: &'b R
}

impl<'a, 'b, S, R> Decoder<'a, 'b, S, R>
    where 'a: 'b { // 'a:'b表示'a 的生命周期比'b 长
}
```

在添加生命周期参数'a之后，结束了输入引用的生命周期长度要长于结构体Foo实例的生命周期长度.

##### 结构体定义中的生命周期参数
结构体在含有引用类型成员的时候也需要标注每一个引用的生命周期参数，否则编译失败.

```rust
struct Foo<'a> {
    part: &'a str,
    ...
}
```

struct的生命周期参数标记，实际上是和编译器约定了一个规则：结构体实例的生命周期应短于或等于任意一个成员的生命周期.

> 注：枚举体和结构体对生命周期参数的处理方式是一样的

##### 静态生命周期参数
静态生命周期 'static：是Rust内置的一种特殊的生命周期. **'static生命周期存活于整个程序运行期间**. 所有的字符串字面量都有生命周期，类型为`& 'static str`

字符串字面量是全局静态类型，他的数据和程序代码一起存储在可执行文件的数据段中，其地址在编译期是已知的，并且是只读的，无法更改.

##### 省略生命周期参数
满足以下三条规则时，可以省略生命周期参数. 该场景下，是将其硬编码到Rust编译器中，以便编译期可以自动补齐函数签名中的生命周期参数

生命周期省略规则：
1. 每一个是引用的参数都有它自己唯一的生命周期参数
1. 如果只有一个输入生命周期参数（无论省略还是没省略），则该生命周期都将分配给输出生命周期参数
1. 如果有多个输入生命周期参数，而其中包含 &self 或者 &mut self，那么所有输出生命周期参数被赋予 self 的生命周期. 针对这条真正能够适用的就只有方法签名

举例:
```rust
fn first_word(s: &str) -> &str { // 原始
fn first_word<'a>(s: &'a str) -> &str { // 编译器应用第一条规则，也就是每个引用参数都有其自己的生命周期
fn first_word<'a>(s: &'a str) -> &'a str { // 对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的. 第二条规则表明输入参数的生命周期将被赋予输出生命周期参数. 现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期
```

如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误.

> 被编码进 Rust 引用分析的模式被称为 生命周期省略规则（lifetime elision rules）

##### 生命周期限定

生命周期参数可以向trait那样作为泛型的限定，有以下两种形式：

T: 'a，表示T类型中的任何引用都要“获得”和'a一样长。
T: Trait + 'a，表示T类型必须实现Trait这个trait，并且T类型中任何引用都要“活的”和'a一样长

##### 高阶生命周期
Rust还提供了高阶生命周期（Higher-Ranked Lifetime）方案，该方案也叫高阶trait限定（Higher-Ranked Trait Bound，HRTB）。该方案提供了for<>语法.

for<>语法整体表示此生命周期参数只针对其后面所跟着的“对象”.

## 并发安全与所有权
如果类型T实现了Send： 就是告诉编译器该类型的实例可以在线程间安全传递所有权.
如果类型T实现了Sync：就是向编译器表明该类型的实例在多线程并发中不可能导致内存不安全，所以可以安全的跨线程共享.

## 函数
函数是编程语言的基本要素，它是对完成某个功能的一组相关语句和表达式的封装。函数也是对代码中重复行为的抽象.

### 函数参数
- 当函数参数按值传递时，会转移所有权或者执行复制（Copy）语义
- 当函数参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数（符合规则时不需要显示的标明）

### 函数参数模式匹配
- ref ：使用模式匹配来获取参数的不可变引用
- ref mut ：使用模式匹配来获取参数的可变引用
- 除了ref和ref mut，函数参数也可以使用通配符来忽略参数

对于引用, Rust 支持两种模式: ref 模式和 `&`模式. 前者借用匹配值的元素, 后者匹配引用.

### 泛型函数
函数参数并未指定具体的类型，而是用了泛型T，对T只有一个Mult trait限定，即只有实现了Mul的类型才可以作为参数，从而保证了类型安全.

泛型函数并未指定具体类型，而是靠编译器来进行自动推断的。如果使用的都是基本原生类型，编译器推断起来比较简单。如果编译器无法自动推断，就需要显式的指定函数调用的类型。

### 法和函数
方法代表某个实例对象的行为，函数只是一段简单的代码，它可以通过名字来进行调用。方法也是通过名字来进行调用，但它必须关联一个方法接受者。

### 高阶函数
高阶函数是指以函数作为参数或返回值的函数，它是函数式编程语言最基础的特性

## 闭包(closure)
闭包通常是指词法闭包，是一个持有外部环境变量的匿名函数.

> 闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

外部环境是指闭包定义时所在的词法作用域.

外部环境变量，在函数式编程范式中也被称为自由变量，是指并不是在闭包内定义的变量.

**将自由变量和自身绑定的函数就是闭包**.

> 闭包的大小在编译期是未知的.

Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数. 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算. 不同于函数，闭包允许捕获调用者作用域中的值.

### 闭包的基本语法
闭包由管道符（两个对称的竖线）和花括号（或圆括号）组成.

- 管道符里是闭包函数的参数，可以向普通函数参数那样在冒号后添加类型标注，也可以省略

    例如：let add = |a, b| -> i32 { a + b };

- 花括号里包含的是闭包函数执行体，花括号和返回值也可以省略。

    例如：let add = |a, b| a + b;

- 当闭包函数没有参数只有捕获的自由变量时，管道符里的参数也可以省略

    例如： let add = || a + b;

**如果尝试对同一闭包使用不同类型则会得到类型错误**.

**闭包不要求像 fn 函数那样在参数和返回值上注明类型(但允许自行标注类型)**. 函数中需要类型注解是因为它们是暴露给用户的显式接口的一部分. 严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的,  但是闭包并不用于这样暴露在外的接口：它们储存在变量中并被使用，不用命名他们或暴露给库的用户调用.

闭包通常很短，并只关联于小范围的上下文而非任意情境. 在这些有限制的上下文中，编译器能可靠的推断参数和返回值的类型.

### 闭包的实现
闭包是一种语法糖. 闭包不属于Rust语言提供的基本语法要素，而是在基本语法功能之上又提供的一层方便开发者编程的语法.

闭包和普通函数的差别就是闭包可以捕获环境中的自由变量.

闭包可以作为函数参数，这一点直接提升了Rust语言的抽象表达能力. 当它作为函数参数传递时，可以被用作泛型的trait限定，也可以直接作为trait对象来使用.

闭包无法直接作为函数的返回值，如果要把闭包作为返回值，必须使用trait对象.

### 闭包与所有权
闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用. 即闭包表达式会由编译器自动翻译为结构体实例，并为其实现Fn、FnMut、FnOnce三个trait中的一个:
- `FnOnce`：会转移方法接收者的所有权。没有改变环境的能力，只能调用一次。

    FnOnce 需要**取得其参数的所有权**，只能调用一次.

    从执行环境中获取数据的所有权的闭包实现了 FnOnce 特征. 该名称表示此闭包只能被调用一次。因此，相关的变量只能使用一次。这是构造和使用闭包最不推荐的方法，因为后续不能使用其引用的变量

    ```rust
    fn main() {
        let mut a = Box::new(23);
        let call_me = || {
            let c = a;
            _ = c;
        };
        call_me(); // 成功
        // call_me(); // 报错
    }

    fn main() {
        let range = 0..10;
        let get_range_count = || range.count();
        assert_eq!(get_range_count(), 10); // ✅
        get_range_count(); // ❌
    }
    ```
- FnMut:会对方法接收者进行可变借用。有改变环境的能力，可以多次调用。

    FnMut 只需要**取得可变的引用**，可以多次调用.
    
    当编译器检测出闭包改变了执行环境中引用的某个值时，它实现了 FnMut 特征.

    FnMut 可以在任何可以使用 FnOnce 的地方使用.

    ```rust
    fn main() {
        let mut a = String::from("Hey!");
        let mut fn_mut_closure = || {
            a.push_str("Alice");
        };
        fn_mut_closure();
        println!("Main says: {}", a);
    }
    ```
- Fn:会对方法接收者进行不可变借用。没有改变环境的能力，可以多次调用。

    Fn只需要不可变的引用并可多次调用, 且不改变它从环境中捕获的任何变量, 即 Fn 闭包没有副作用或无状态.

    Fn 可以用在任何可以使用 FnMut 的地方，包括可以使用 FnOnce 的地方.

    仅为读取访问变量的闭包实现 Fn 特征。它们访问的任何值都是引用类型（ &T）。这是使用闭包的默认模式.

    ```rust
    fn main() {
        let a = String::from("Hey!");
        let fn_closure = || {
            println!("Closure says: {}", a);
        };
        fn_closure();
        println!("Main says: {}", a);
    }
    ```

如果要实现Fn，就必须实现FnMut和FnOnce
如果要实现FnMut，就必须实现FnOnce
如果要实现FnOnce，就不需要实现FnMut和Fn

实际上，Fn() 是 FnMut() 的子特型，而 FnMut() 又是 FnOnce() 的子特型。于是 Fn 就成了最专一且最强大的类别。FnMut 和 FnOnce 则是包含使用限制的更广泛的类别.

由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce. 那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 FnMut, 而不需要对被捕获的变量进行可变访问的闭包则也实现了 Fn.

如果希望强制闭包获取其使用的环境值的所有权, 可以在参数列表前使用 **move 关键字. 这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用**.

#### 捕获环境变量的方式
- 对于复制语义类型，以不可变引用（&T）来进行捕获
- 对于移动语义类型，执行移动语义，转移所有权来进行捕获
- 对于可变绑定，并且在闭包中包含对其进行修改的操作，则以可变引用（&mut T）来进行捕获

Rust使用move关键字来强制让闭包所定义环境中的自由变量转移到闭包中.

#### 规则总结
- 如果闭包中没有捕获任何环境变量，则默认自动实现Fn
- 如果闭包中捕获了复制语义类型的环境变量，则：

    - 如果不需要修改环境变量，无论是否使用move关键字，均会自动实现Fn。
    - 如果需要修改环境变量，则自动实现FnMut。

- 如果闭包中捕获了移动语义类型的环境变量，则：

    - 如果不需要修改环境变量，而且没有使用move关键字，则会自动实现FnOnce。
    - 如果不需要修改环境变量，而且使用move关键字，则会自动实现Fn。
    - 如果需要修改环境变量，则自动实现FnMut。

- FnMut的闭包在使用move关键字时，如果捕获变量是复制语义类型的，则闭包会自动实现Copy/Clone。如果捕获变量是移动语义类型的，则闭包不会自动实现Copy/Clone

## 迭代器
迭代器模式允许对一个序列的项进行某些处理. 迭代器（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑, 是一种高效访问集合类型元素的方法.

> 在 Rust 中，**迭代器是 惰性的（lazy）**, 这意味着在调用方法使用迭代器之前它都不会有效果, 仅在需要时对集合中的元素进行求值或访问.

迭代器都实现了一个叫做 Iterator 的定义于标准库的 trait. next 是 Iterator 实现者被要求定义的唯一方法. next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None.

> iter()生成一个不可变引用的迭代器. 如果需要一个获取所有权并返回拥有所有权的迭代器，则可以调用 into_iter. 类似的, 如果希望迭代可变引用，则可以调用 iter_mut().

<table>
<thead>
<tr>
<th><code>Vec&lt;T&gt;</code> 方法</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.iter()</code></td>
<td><code>Iterator&lt;Item = &amp;T&gt;</code></td>
</tr>
<tr>
<td><code>.iter_mut()</code></td>
<td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td>
</tr>
<tr>
<td><code>.into_iter()</code></td>
<td><code>Iterator&lt;Item = T&gt;</code></td>
</tr>
</tbody>
</table>

这些调用 next 方法的方法被称为 消费适配器（consuming adaptors），因为调用它们会消费迭代器.

Iterator trait 中定义了另一类方法，被称为 迭代器适配器（iterator adaptors），允许开发者将当前迭代器变为不同类型的迭代器, 可以链式调用多个迭代器适配器. 不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果.

```rust
let v1: Vec<i32> = vec![1, 2, 3];
// v1.iter().map(|x| x + 1); // 指定的闭包从未被调用过: 因为迭代器适配器是惰性的必须有消费
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect(); // 调用 collect 方法消费新迭代器
```

Rust 的 for 循环可以用于任何实现了  IntoIterator trait 的数据结构.

在执行过程中，IntoIterator 会生成一个迭代器，for 循环不断从迭代器中取值，直到迭代器返回 None 为止。因而，for 循环实际上只是一个语法糖，编译器会将其展开使用 loop 循环对迭代器进行循环访问，直至返回 None.

Rust使用的是外部迭代器，也就是for循环. 外部迭代器：外部可以控制整个遍历过程.

Rust中使用了trait来抽象迭代器模式. Iterator trait是Rust中对迭代器模式的抽象接口.

迭代器主要包含：
- next方法：迭代其内部元素
- 关联类型Item
- size_hint方法：返回类型是一个元组，该元组表示迭代器剩余长度的边界信息

Iter类型迭代器，next方法返回的是Option<&[T]>或Option<&mut [T]>类型的值. for循环会自动调用迭代器的next方法. for循环中的循环变量(是引用)则是通过模式匹配，从next返回的Option<&[T]>或Option<&mut [T]>类型中获取&[T]或&mut [T]类型的值.

IntoIter类型的迭代器的next方法返回的是Option<T>类型，在for循环中产生的循环变量是值，而不是引用.

> 迭代器可能比循环快的原因: 它`展开(unroll)`了循环. 展开是一种移除循环控制代码的开销并替换为每个迭代中的重复代码的优化.

### IntoIterator trait
如果想要迭代某个集合容器中的元素，必须将其转换为迭代器才可以使用.

Rust提供了FromIterator和IntoIterator两个trait，他们互为反操作:
- FromIterator ：可以从迭代器转换为指定类型
- IntoIterator ：可以从指定类型转换为迭代器

Intoiter可以使用into_iter之类的方法来获取一个迭代器. into_iter的参数时self，代表该方法会转移方法接收者的所有权. 而还有其他两个迭代器不用转移所有权
- Iter ：获取不可变借用，对应&self
- IterMut ：获得可变借用，对应&mut slef

### 哪些实现了Iterator的类型？
只有实现了Iterator的类型才能作为迭代器.

实现了IntoIterator的集合容器可以通过into_iter方法来转换为迭代器.

实现了IntoIterator的集合容器有：
- `Vec<T>`
- `&'a [T]`
- `&'a mut [T] => 没有为[T]类型`实现IntoIterator

### 迭代器适配器
Iterator 特型就会提供大量可供选择的适配器方法，或简称适配器（adapter）.

通过适配器模式可以将一个接口转换成所需要的另一个接口. 适配器模式能够使得接口不兼容的类型在一起工作. 适配器也叫包装器(Wrapper).

迭代器适配器，都定义在std::iter模块中：
- Map ：通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器。
- Chain ：通过连接两个迭代器来创建一个新的迭代器。
- Cloned ：通过拷贝原始迭代器中全部元素来创建新的迭代器。
- Cycle ：创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代。
- Enumerate ：创建一个包含计数的迭代器，它返回一个元组（i,val），其中i是usize类型，为迭代的当前索引，val是迭代器返回的值。
- Filter ：创建一个机遇谓词判断式过滤元素的迭代器。
- FlatMap ：创建一个类似Map的结构的迭代器，但是其中不会包含任何嵌套。
- FilterMap ：相当于Filter和Map两个迭代器一次使用后的效果. 它允许闭包在迭代过程中要么转换项（像 map 那样），要么删除项
- Fuse ：创建一个可以快速遍历的迭代器。在遍历迭代器时，只要返回过一次None，那么之后所有的遍历结果都为None。该迭代器适配器可以用于优化。
- Rev ：创建一个可以反向遍历的迭代器
- Scan: 类似于 map，区别在于它会传给闭包一个可修改的值，而且可以选择提前终止迭代
- take 和 take_while : 用于在取得一定项数之后或闭包决定中断时终止迭代

    - take 迭代器在产生最多 n 项后返回 None
    - take_while 迭代器对每一项应用 predicate，在遇到第一个 predicate 返回 false 的项时返回None，后续每次调用 next 也都返回 None
- skip 和 skip_while : 是对 take 和 take_while 的补充，它们从迭代开始清除一定数量的项，或者一直清除到闭包发现一个可以接受的项，然后将剩余项原封不动返回

    - skip_while 适配器使用闭包来决定清除序列开头的多少项
- peekable : 可以让代码在不消费下一项的情况下探测下一项
- fuse : 可以将任何适配器转换为第一次返回 None 之后始终继续返回 None 的迭代器
- zip : 将两个适配器组合为一个适配器，产生之前两个迭代器项的项对，就像拉链把分开的两边拼在一起一样

    ```rust
    let v: Vec<_> = (0..).zip("ABCD".chars()).collect();
    assert_eq!(v, vec![(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]);
    ```
- inspect : 可以方便地用于迭代器适配器管道的调试
- cloned : 将一个产生引用的迭代器转换为产生基于引用克隆的值的迭代器。自然地，引用值的类型必须实现 Clone
- cycle : 返回一个无休止重复底层迭代器的迭代器。底层迭代器必须实现 std::clone::Clone，以便 cycle 可以保存其初始状态并在每次循环开始时重用

Rust可以自定义迭代器适配器

### 消费器
迭代器不会自动发生遍历行为，需要调用next方法去消费其中的数据. 最直接消费迭代器数据的方法就是使用for循环.

Rust提供了for循环之外的用于消费迭代器内数据的方法，叫做消费器（Consumer）.

Rust标准库std::iter::Iterator中常用的消费器：
- any ：可以查找容器中是否存在满足条件的元素
- fold ：该方法接收两个参数，第一个为初始值，第二个为带有两个参数的闭包。其中闭包的第一个参数被称为累加器，它会将闭包每次迭代执行的结果进行累计，并最终作为fold方法的返回值
- collect ：专门用来将迭代器转换为指定的集合类型
- `all`
- `for_each`
- `position`
- max_by 和 min_by : 根据提供的自定义比较方法返回迭代器产生的最大值和最小值
- count 方法从一个迭代器中取, 直到它返回 None，然后返回这个迭代器包含多少项
- max 和 min : 分别返回迭代器产生项的最大值和最小值。迭代器的项类型必须实现 std::cmp::Ord，这样项与项之间才能比较
- max_by_key 和 min_by_key : 可以根据应用到每一项的闭包选择最大或最小的项。闭包可以选择项的某个字段，或者对每一项执行某些计算
- any 和 all : 给迭代器产生的每一项应用闭包，如果闭包对其中一项或全部项返回 true, 才返回 true
- position : 给迭代器产生的每一项应用闭包，返回闭包返回 true 的第一项的索引。更精确地说，position 返回一个索引的 Option：如果闭包对任何项都没有返回 true，则返回None。只要闭包返回 true，position 就停止取值
- nth : 接收一个索引值 n，然后跳过迭代器中相应的项，返回索引对应的项；如果序列在此之前结束，则返回 None
- last : 消费每一项，直到迭代器返回 None，然后返回最后一项。如果迭代器不产生任何项，则 last 返回 None
- find : 从迭代器中取得第一个闭包返回 true 的值，或者如果没有找到合适的项则返回None
- extend: 如果类型实现了 std::iter::Extend 特型，那么它的 extend 方法可以将一个迭代器的项添加到集合中
- partition : 把一个迭代器的项分成两个集合，然后使用闭包决定哪一项属于哪个集合

## 锁
- RwLock读写锁：是多读单写锁，也叫共享独占锁. 它允许多个线程读，单个线程写。但是在写的时候，只能有一个线程占有写锁；而在读的时候，允许任意线程获取读锁。读锁和写锁不能被同时获取。
- Mutex互斥锁：只允许单个线程读和写

## 内存管理
drop-flag：在函数调用栈中为离开作用域的变量自动插入布尔标记，标注是否调用析构函数，这样，在运行时就可以根据编译期做的标记来调用析构函数.

实现了Copy的类型，是没有析构函数的. 因为实现了Copy的类型会复制，其生命周期不受析构函数的影响.

## 异步
在异步操作里, 异步处理完成后的结果, 一般用 Promise 来保存, 它是一个对象，用来描述在未来的某个时刻才能获得的结果的值, 一般存在三个状态:
- 初始状态，Promise 还未运行
- 等待（pending）状态, Promise 已运行, 但还未结束
- 结束状态, Promise 成功解析出一个值，或者执行失败

一般而言, async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行. 大多数语言中, async/await 是一个语法糖（syntactic sugar）, 它使用状态机将 Promise 包装起来, 让异步调用的使用感觉和同步调用非常类似, 也让代码更容易阅读.

## 属性
属性是 Rust 中写给编译器看的各种指令和建议的普适语法.

Rust 代码中的属性是指元素的注释. 属性通常是编译器内置的，不过也可以由用户通过编译器插件创建。它们指示编译器为其下显示的元素注入额外的代码或含义.

属性:
- `#[<name>]`：这适用于每个元素，通常显示在它们定义的上方
- `#![<name>]`：这适用于每个软件包. 它通常位于用户软件包根目录的最顶端部分
- 其他属性

    - `#[cfg(test)]`: 此属性添加在测试模块之上，以提示编译器有条件地编译模块，但仅在测试模式下有效

常见属性:
- `#[repr(C)]` : 要求 Rust 以兼容 C 和 C++ 的方式在内存中存储结构体

    与 C 和 C++ 不同, Rust 不保证结构体的字段或元素在内存中会以某种顺序存储, 但保证把字段的值直接存储在结构体的内存块中.

## test
Rust 的单元测试一般放在和被测代码相同的文件中，使用条件编译  #[cfg(test)] 来确保测试代码只在测试环境下编译.

集成测试一般放在 tests 目录下，和 src 平行. 和单元测试不同, 集成测试只能测试 crate 下的公开接口，编译时编译成单独的可执行文件.

Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的. 测试函数体通常执行如下三种操作：
1. 设置任何所需的数据或状态
1. 运行需要测试的代码
1. 断言其结果是我们所期望的

Rust 社区倾向于根据测试的两个主要分类来考虑问题：单元测试（unit tests）与 集成测试（integration tests）. 单元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口. 而集成测试对于开发者的库来说则完全是外部的. 它们与其他外部代码一样，通过相同的方式使用开发者的代码，只测试公有接口而且每个测试都有可能会测试多个模块.

在编写代码方面, 编写集成测试和单元测试没有太大的区别, 唯一的区别是目录结构和其中的项目需要公开, 开发人员已经根据软件包的设计原则公开了这些项目.

Rust 的私有性规则确实允许你测试私有函数.

Rust 二进制项目的结构明确采用 src/main.rs 调用 src/lib.rs 中的逻辑的方式: 因为通过这种结构，集成测试 就可以 通过 extern crate 测试库 crate 中的主要功能了, 根本原因是只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数, 而二进制 crate 只意在单独运行.

### 单元测试
单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块.

测试模块的 #[cfg(test)] 注解告诉 Rust 只在执行 cargo test 时才编译和运行测试代码，而在运行 cargo build 时不这么做.

cfg 属性代表 configuration ，它告诉 Rust 其之后的项只应该被包含进特定配置选项中, 通常用于条件编译，但不限于测试代码, 比如它可以为不同体系结
构或配置标记引用或排除某些代码. 通常配置选项是 test，即 Rust 所提供的用于编译和运行测试的配置选项. 通过使用 cfg 属性，Cargo 只会在我们主动使用 cargo test 运行测试时才编译测试代码.

### 集成测试
在 Rust 中，集成测试对于需要测试的库来说完全是外部的. 同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作. 一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的. 为了创建集成测试，需要先创建一个 tests 目录, 与 src 同级. Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译.

> tests 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中, 但可将其作为模块以便在任何集成测试文件中使用.

集成测试不需要将任何代码标注为`#[cfg(test)]`. tests 文件夹在 Cargo 中是一个特殊的文件夹， Cargo 只会在运行 cargo test 时编译这个目录中的文件.

可以通过指定测试函数的名称作为 cargo test 的参数来运行特定集成测试.

也可以使用 cargo test 的 --test 后跟文件的名称来运行某个特定集成测试文件中的所有测试, 比如`cargo test --test integration_test`, 只运行了 tests 目录中指定的文件 integration_test.rs 中的测试.

### 测试函数
作为最简单例子，Rust 中的测试就是一个带有 test 属性注解的函数. 属性（attribute）是关于 Rust 代码片段的元数据.

为了将一个函数变成测试函数，需要在 fn 行之前加上`#[test]`.

assert! 宏由标准库提供，在希望确保测试中一些条件为 true 时非常有用. 因此需要向 assert! 宏提供一个求值为布尔值的参数.

测试功能的一个常用方法是将需要测试代码的值与期望值做比较，并检查是否相等. 可以通过向 assert! 宏传递一个使用 == 运算符的表达式来做到。不过这个操作实在是太常见了，以至于标准库提供了一对宏来更方便的处理这些操作 —— assert_eq! 和 assert_ne!, 这两个宏分别比较两个值是相等还是不相等.


> `assert!(a == b)`中的`==`, 实际上会转变成一个方法调用`a.eq(&b)`, eq 方法来自特征 PartialEq. PartialEq 定义了
局部排序，而 Eq 需要全局排序.

> assert_eq! 和 assert_ne! 宏在底层分别使用了 == 和 !=。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必需实现了 PartialEq 和 Debug trait.

> debug_assert!: 类似assert!, 仅在debug模式中, 主要用于代码运行时，对应该保存的任何契约或不变性进行断言的情况, 有助于在调试模式下运行代码时捕获断言异常. 类似的还有debug_assert_eq!和 debug_assert_ne!.

还可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个可选的失败信息参数， 以便在测试失败时将自定义失败信息一同打印出来.

```rust
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`", result
        );
    }
}
```

属性`#[should_panic]`在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败. 还,可给 should_panic 属性增加一个可选的 expected 参数, 测试工具会确保错误信息中包含其提供的文本.

```rust
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!("Guess value must be greater than or equal to 1, got {}.",
                   value);
        } else if value > 100 {
            panic!("Guess value must be less than or equal to 100, got {}.",
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

可以使用 Result<T, E> 编写测试. 但不能对这些使用 Result<T, E> 的测试使用 #[should_panic] 注解, 相反应该在测试失败时直接返回 Err 值.

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

`#[ignore]`: 使用#[ignore]属性标记告知测试工具在执行 cargo test 命令时忽略此类测试功能, 然后可以向测试工具或 cargo test 命令传递`--ignored` 参数来单独运行这些测试.

### 执行测试
`rustc --test first_unit_test.rs`即测试first_unit_test.rs, 默认测试都是并行的, 除非设置了`RUST_TEST_THREADS=1`.

cargo test 在测试模式下编译代码并运行生成的测试二进制文件， 但可以指定命令行参数来改变 cargo test 的默认行为. cargo test 生成的二进制文件的默认行为是并行的运行所有测试，并截获测试运行过程中产生的输出, 这与golang类同.

当运行多个测试时， Rust 默认使用线程来并行运行. `cargo test -- --test-threads=1`可传递 --test-threads 参数和希望使用线程的数量给测试二进制文件, 这里将测试线程设置为 1，告诉程序不要使用任何并行机制.

如果希望能看到通过的测试中打印的值，截获输出的行为可以通过 --nocapture 参数来禁用, 比如` cargo test test_with_fixture --
--nocapture`, test_with_fixture是测试函数.

可以向 cargo test 传递任意测试的名称来只运行这个测试, 比如`cargo test one_hundred`.

指定部分测试的名称，任何名称匹配这个名称的测试会被运行, 比如`cargo test add`, 只运行了所有名字中带有 add 的测试.

可以使用 ignore 属性来标记耗时的测试并排除他们. 当需要运行 ignored 的测试时，可以执行`cargo test -- --ignored`.

### 基准测试
`cargo bench`

基准测试基于:
1. 函数上方的#[bench]注释，这表示该函数是一个基准测试
1. 内部编译器软件包 libtest 包含一个 Bencher 类型，基准函数通过它在多次迭代中运行相同的基准代码，此类型是针对编译器内部的，只适用于测试模式

```rust
// bench_example/src/lib.rs
#![feature(test)]
extern crate test;

use test::Bencher;

pub fn do_nothing_slowly() {
    print!(".");
    for _ in 1..10_000_000 {};
}

pub fn do_nothing_fast() {
}

#[bench]
fn bench_nothing_slowly(b: &mut Bencher) {
    b.iter(|| do_nothing_slowly());
}

#[bench]
fn bench_nothing_fast(b: &mut Bencher) {
    b.iter(|| do_nothing_fast());
}
```

在标有#[bench]注释的函数内部， iter 的参数是一个没有参数的闭包函数.

输出格式是每次迭代花费的时间，括号内的数字表示每次运行之间的差异. 性能较差的实现的运行速度非常慢, 并且运行时间不固定（用+/−符号所示）.

criterion-rs可生成比内置基准测试框架更多的统计报告, 并使用 gnuplot 生成实用的图形和报表, 使用户更容易理解, 使用方法是:
```
# cat Cargo.toml
...
[dev-dependencies]
criterion = "0.1"

[[bench]]
name = "fibonacci"
harness = false
...

# cat criterion_demo/benches/fibonacci.rs
#[macro_use] // 意味着要使用来自此软件包的任何宏时，我们需要使用此属性来选择它，因为默认情况下它们是非公开的
extern crate criterion;
extern crate criterion_demo;

use criterion_demo::{fast_fibonacci, slow_fibonacci};
use criterion::Criterion;

fn fibonacci_benchmark(c: &mut Criterion) { // c可保存基准代码的运行状态
    c.bench_function("fibonacci 8", |b| b.iter(|| slow_fibonacci(8)));
}

criterion_group!(fib_bench, fibonacci_benchmark); // 将fib_bench 的基准名称分配给基准组
criterion_main!(fib_bench);
```
添加了一个名为`[[bench]]`的新属性， 它向 Cargo 表明我们有一个名为 fibonacci的新基准测试，并且它不使用内置的基准测试工具（ harness=false）, 因为我们正在使用
criterion 软件包的测试工具.

使用

## FAQ
### 并发与并行
并发是一种能力，而并行是一种手段. 因为并行处理是基于硬件的，而并发处理是可以通过设计编码进行提高的.

在代码的运行方式中，并发是并行的基础，是同时与多个任务打交道的能力；并行是并发的体现，是同时处理多个任务的手段.

很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个 M:N 的调度器，把 M 个并发任务，合理地分配在 N 个 CPU core 上并行运行，让程序的吞吐量达到最大, 比如go.

### 同步和异步
同步是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束.

同步执行保证了代码的因果关系（causality），是程序正确性的保证.

然而在遭遇 I/O 处理时，高效 CPU 指令和低效 I/O 之间的巨大鸿沟，成为了软件的性能杀手.

异步是指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束.

在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象，用来描述在未来的某个时刻才能获得的结果的值，一般存在三个状态:
1. 初始状态，Promise 还未运行
1. 等待（pending）状态，Promise 已运行，但还未结束
1. 结束状态， Promise 成功解析出一个值，或者执行失败

在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 以及 async/await.

一般而言，async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用**状态机**将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读.

### 各编程语言中的类型系统
静态类型语言：在编译阶段确定所有变量的类型.
动态类型语言：在执行阶段确定所有变量的类型.
不允许隐式转换的是强类型，允许隐式转换的是弱类型.

- 没类型： 比如汇编语言，没有类型的概念，所有都只是一个数字
- 弱静态类型： 比如C/C++语言，可以定义类型，但是不强制执行，在不同类型之间自动转换
- 强静态类型： 比如Java，定义类型，并且用虚拟机检查类型
- 强动态类型： 比如Python和Ruby，动态推断类型而不需要定义，然后解释器会强制执行.
- 弱动态类型： Perl/PHP,js

> ruby和Python在运行时通过Duck Typing来进行运行时类型检查, 以保证类型安全.

![](/misc/img/rust/9zv7ejia98.jpeg)

### 函数式编程（functional programming）
函数式编程风格通常包含将函数作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等等.

Rust 的一些在功能上与其他被认为是函数式语言类似的特性:
- 闭包（Closures），一个可以储存在变量里的类似函数的结构
- 迭代器（Iterators），一种处理元素序列的方式