# rust
rust是一门同时追求**安全,并发和性能**的现代系统级编程语言.

rust是一门系统编程语言, 特点:
1. 高性能: 没有gc
1. 高可靠: 所有权模型保证了内存安全和线程安全
1. 生产力: 拥有出色的文档、友好的编译器和清晰的错误提示信息, 还集成了一流的工具 cargo, 智能地自动补全和类型检验的多编辑器支持, 以及自动格式化代码等等

Rust 中最大的思维转换就是变量的所有权和生命周期，这是几乎所有编程语言都未曾涉及的领域.

rust三大设计哲学:
1. 内存安全
ref:
- [Rust、Go、C ，哪个才是“内存管理大师”？](https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655873042&idx=1&sn=db17488d9ea741c280cf26ee6fb4b8ea)

	类型安全即类型系统可以保证程序的行为是意义明确, 不出错的. c/c++的类型系统不是类型安全的, 比如它们不检查数组越界, 这导致发生了语音规范规定之外的行为即未定义行为(Undefined Behavior).

    > 类型安全: 类型系统给内存中的plain data赋予了类型信息，如果不按照类型信息来解释内存中的数据，应该产生编译错误或者 产生well-specified的运行时错误.

    类型安全是内存安全的前提.

    内存安全: 不会出现内存访问错误, 只有当程序访问未定义内存时才会产生内存错误. 常见的场景有:
    1. 引用空指针
    1. 使用未初始化内存
    1. 释放后再次使用, 即虚悬指针
    1. 缓冲区溢出, 比如数组越界
    1. 非法释放已释放过的指针或未分配的指针, 即重复释放

    rust为了保证内存安全, 建立了严格的安全内存管理模型:
    - 所有权系统: 每个被分配的内存都有一个独占其所有权的指针. 只有当该指针被销毁时, 其对应的内存该会被随之释放.
    - 借用和生命周期: 每个变量都有其生命周期, 一旦超出生命周期, 变量就会被自动释放. 如果是借用, 则可以通过标记生命周期参数供编译器检查的方式, 防止出现虚悬指向即释放后使用的情况.

    rust所有权系统还包括了从现代c++借鉴的RAII机制, 这是rust无gc但是可以安全管理内存的基石. 在 C++ 中，这种 item 在生命周期结束时释放资源的模式被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）.
    
    > 悬垂指针（dangling pointer, 也叫虚悬指针）是其指向的内存可能已经被分配给其它持有者.

    为了实现内存安全, rust还具备独有的特性:
    1. 仿射类型(Affine Type), 该类型可用来表达rust所有权中的Move语义.
    1. 借用, 生命周期

    借助类型系统, rust可在编译阶段对类型进行检查是否满足安全内存模型, 有效地阻止未定义行为的发生.

    Rust通过使用借用检查器(borrow checker)、所有权(ownership)、借用(borrow)这三个概念来管理和确保跨堆栈和堆的内存安全来管理内存，从而实现内存管理.

	所有权有点类似核心原则, 而借用和生命周期是对语言类型系统的扩展.

    内存安全bug和并发安全的bug的产生内在原因均是内存的不正当访问造成的. 借助装备了所有权的强大类型系统, rust还解决了并发安全问题. 它通过静态检查分析, 在编译期就能检查出多线程并发代码中所有的数据竞争问题.
1. 零成本抽象

    零成本抽象即如果不使用某个抽象, 就不用为它付出开销.

    rust的绝大多数抽象并不存在运行时的开销, 其一切都是在编译期完成的.

    rust的零成本抽象的基石是泛型和trait.
1. 实用性

    为了保证安全性, Rust 引入了强大的类型系统和所有权系统, 不仅保证内存安全, 还保证了并发安全, 同时还不会牺牲性能.

    为了保证支持硬实时, rust借鉴了c++的确定性析构, RAII和智能指针, 用于自动地, 确定地管理内存, 从而避免了gc的引入.

    为了保证程序的鲁棒性, rust重新审视了错误处理机制. rust针对三类非正常情况: 失败, 错误和异常, 提供了专门的处理方式:
    - 失败: 使用断言工具
    - 错误: 基于返回值的分层错误处理. 比如`Option<T>`用来处理可能存在空值的情况, `Result<T>`用来处理可以被合理解决并需要传播的错误
    - 异常: rust将其看作无法被合理解决的问题, 提供了线程恐慌机制, 发生异常时, 线程可以安全地退出.

    为了兼容现有生态, rust支持方便且零成本的FFI机制, 兼容C-ABI, 在语言架构层面上将rust分为safe rust和unsafe rust两部分. unsafe专门和外部生态打交道, 因为rust编译器检查和跟踪的范围有限, 不能检查到与其链接的其他生态接口, 因此这些生态由自身来保证安全性. 总结就是, safe rust由rust编译器在编译时保证安全, unsafe rust开发者让编译器信任自身有能力保证安全.

    同时rust提供了强大的包管理器cargo.

rust编程的哲学和golang相同: 组合优于继承. rust不提供类型层面上的继承, 所有的类型都是独立存在的.

## 发版
Rust 编译器的版本号采用了`语义化版本号（ Semantic Versioning ）`规划, 版本格式为: `主版本号.次版本号.修订号`.

为了兼顾更新速度以及稳定性, Rust 使用了多渠道发布的策略:
- nightly

	nightly 版本是每天在主版本上自动创建出来的版本，这个版本上的功能最多，更新最快，但是某些功能存在问题的可能性也更大 因为新功能会首先在这个版本上开启，供用户试用.

	nightly 版本中使用试验性质的功能，必须手动开启 featur gate 也就是说要在当前项目的入口文件中加入`#![feature (name,...)]`语句, 否则是编译不过的. 等到这个功能最终被稳定了, 再用新版编译器编译的时候，它会警告你这个 feature gate 现在是多余的了，可以去掉了.

- beta

	beta 版本是每隔 段时间，将一些在 nightly 版本中验证过的功能开放给用户使可以被看作 stable 版本的“预发布”版本
- stable

	stable 版本则是正式版，它定期发布一个新版本，一些实验性质的新功能在此版本上无法使用, 因此它也是最稳定、最可靠的, 保证向前兼容的版本. 

Rust 相对重大的设计必须经过 RFC(Request For Comments ）设计步骤. 这个步骤主要是用于讨论如何“设计”语言. [这个项目](https://github.com/rust-lang/rfcs)旨在于所有大功能必须先写好设计文挡，讲清楚设计的目标、实现方式 优缺点等，让整个社区参与讨论，然后由“核心组”(Core Team)的成员参与定夺是否接受这个设计. 许多深层次的设计思想问题可以在这个项目中找到答案.

rust的`RFC -> Nightly -> Beta -> Stable`策略成功实践了快速迭代、敏捷交付以及 视用户反馈的特点，同时也保证了核心设计的稳定性--用户可以根据自己的要和风险偏好，选择合适的版本.

2017 年下半年, rust 设计组又提出了一个基于 poch 演进策略（后来也被称为edition). 它要解决的问题是`如何让 Rust 平稳地进化`. 简单来说就是让 Rust 的兼容性保证是一个有时限的长度, 而不是永久.


## 编译
Rust 是跨平台语次编译, 到处运行, 这得益于 LLVM.

rust编译器是LLVM编译器的前端, 它将代码编译成LLVM IR, 然后通过LLVM编译成对应架构的机器码.

rust源码经过分词和解析生成AST(抽象语法树), 再进一步简化处理为HIR(High-level IR, 方便编译器做类型检查), 再进一步编译为[MIR](https://play.rust-lang.org/)(middle IR, 在rust 1.12引入), 最后MIR被翻译为LLVM IR, 之后由LLVM编译成目标机器码.

引入MIR原因:
1. 缩短编译时间

    实现了增量编译, 仅重新编译更改过的部分.
1. 缩短执行时间

    进入llvm前实现更细颗粒度的优化即增加了更多的优化空间. 单纯依赖llvm的优化颗粒度太粗, 且rust无法控制
1. 更精确的类型检查

    实现更灵活的借用检查

MIR是基于控制流图（Control Flow Graph，CFG）的抽象数据结构，它用有向图（DAG）形式包含了程序执行过程中所有可能的流程, 所以将基于MIR的借用检查称为非词法作用域的生命周期, 因此确实不依赖词法作用域了.

MIR由一下关键部分组成：
- 基本块（Basic block，bb），他是控制流图的基本单位，
    
    - 语句（statement）
    - 终止句（Terminator）

- 本地变量, 栈中内存的位置，比如函数参数、局部变量等. 一般用下划线和数字作为标识(比如`_1`), 其中`_0`通常表示返回地址.
- 位置（Place），在内存中标识未知的额表达式。
- 右值（RValue），产生值的表达式。


> LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time), 链接时间(link-time), 运行时间(run-time)以及空闲时间(idle-time).

> 无疑，不同编译器的中间语言IR是不一样的，而IR可以说是集中体现了这款编译器的特征：它的算法，优化方式，汇编流程等等，想要完全掌握某种编译器的工作和运行原理，分析和学习这款编译器的中间语言无疑是重要手段. 由于中间语言相当于一款编译器前端和后端的“桥梁”，如果我们想进行基于LLVM的后端移植，无疑需要开发出对应目标平台的编译器后端，想要顺利完成这一工作，透彻了解LLVM的中间语言无疑是非常必要的工作. LLVM相对于gcc的一大改进就是大大提高了中间语言的生成效率和可读性, LLVM的中间语言是一种介于c语言和汇编语言的格式, 它既有高级语言的可读性, 又能比较全面地反映计算机底层数据的运算和传输的情况, 精炼而又高效.

## 语言架构
rust概念层次:
1. 混合编程规范

	面向对象+函数式
1. 语义

	所有权, move, copy, 借用, 生命周期, drop等
1. 类型系统

	承载上层的语义和混合编程规范, 赋予了 Rust 高级的抽象表达能力和安全性. 同时还保留了对底层代码执行、数据表示和内存分配等操作的控制能力.

1. 安全内存管理层

### 语言组成
rust组成:
- 语言规范

	主要由 Rust 语言参考（ The Rust Reference）和 RFC 文档共同构成.

	Rust 语言参考是官方团队维护的一份参考文档(非正式但已最接近正式规范), 包含了三类内容:
	1. 对每种语言结构及其用法的描述
	1. 对内存模型、并发模型、链接、调试等内存的描述
	1. 影响语言设计的基本原理和参考

- 编译器
- 核心库

	Rust的语法由核心库和标准库共同提供, 其中核心库是标准库的基础.

    它定义了rust语言的核心, 不依赖于操作系统和网络等相关的库, 不负责堆分配,不提供并发和I/O.

    可通过在模块顶部引入`#![no_std]`来使用核心库, 它是做嵌入式开发所必须的. 核心库和标准库的功能有一些重复.
    
    核心库组成:
    1. 基础trait, 如Copy, Debug, Display,Option等
    1. 基本原始类型, 如 bool, char, i8/u8, i64/u64, isize/usize, f32/f64, str, array, slic, tuple, pointer等
    1. 常用功能型数据类型, 比如String, Vec, HashMap, Rc, Arc, Box等

        String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型.

        Rust 标准库中还包含一系列其他字符串类型，比如 OsString、OsStr、CString 和 CStr, 前缀(非String/非Str)对应着它们提供的所有权和可借用的字符串变体.

        使用 to_string 方法从字符串字面值创建 String: `"...".to_string()` <=> `String::from("...")` <=> `str::to_string("hello")`<=>`ToString::to_string("hello")`<=>`<str as ToString>::to_string("hello")`.

        其他形式称为限定方法调用，因为它们需要指定`方法关联的类型或特型`. 最后一种带尖括号的形式，则同时指定了两者，因此称为完全限定方法调用, 比如`<str as ToString>::to_string()`.

        完全限定方法调用用途:
        1. 两个trait方法同名, 不知用哪个
        1. 无法推断self参数的类型
        1. 将函数本身作为参数
        1. 在宏里调用trait方法

        **Rust 的字符串不支持索引**.

        遍历: `for c in "नमस्ते".chars()`或`for b in "नमस्ते".bytes()`.

        Rust 的原始字符串语法是在`r`后跟一个或多个`#`和一个双引号, 然后是字符串内容, 最后以另一个双引号及相同个数的`#`结尾. 原始字符串中的任何字符都无须转义，包括双引号. 为避免歧义，通过在双引号两侧添加更多的`#`，总是可以明确标识字符串的结束位置
    1. 常用的宏定义, 如println()!, assert!, panic!, vec!

        Rust 中的宏(`!`)与C/C＋＋ 中的宏是完全不一样的东西. 简单点说，可以把它理解为一种安全版的编译期语法扩展, 这里之所以使用宏，而不是函数，是因为标准输出宏可以完成编译期格式检查. 更加安全. 这个宏最终还是调用了`std::io`模块内提供的一些函数来完成的. 如果需要更精细地控制标准输出操作, 也可以直接调用标准库来完成.

        Rust 支持声明宏（declarative macro）和过程宏（procedure macro），其中过程宏又包含三种方式：函数宏（function macro），派生宏（derive macro）和属性宏（attribute macro）. println! 是函数宏，是因为 Rust 是强类型语言，函数的类型需要在编译期敲定，而 println! 接受任意个数的参数，所以只能用宏来表达.

- 标准库

    提供应用程序开发所需的基础和跨平台支持.

    标准库组成:
    1. 与核心库一样的基本trait, 原始数据类型, 功能型数据类型和常用的宏等, 以及与核心库几乎完全一致的API.
    1. 并发, I/O和运行时.
    
        如线程模块, 用于消息传递的通道类型, Sync trait等并发模块, 文件, tcp, udp, 管道, socket等常见I/O.
    1. 平台抽象.
        - os模块提供了许多与操作环境交互的基本功能, 包括程序参数, 环境变量, 目录导航
        - 路径模块封装了处理文件路径的平台特定规则.
    1. 底层操作接口

        如std::mem,std::ptr, std::intrinsic等, 操作内存,指针, 调用编译器固有函数.

    1. 可选和错误处理类型Option和Result, 以及各种迭代器.

    Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举, 这个枚举是`Option<T>`，而且它定义于标准库中.
- 包管理器

Rust 源代码的后缀名使用`.rs`表示, 且必须使用 utf-8 编码.

#### Rust命令规范
> rust使用蛇形命名法(snake case)来规范函数和变量名称的风格: 只使用小写的字母进行命名, 并以`_`分割word.

- 函数： 蛇形命名法（snake_case），例如：func_name()
- 文件名： 蛇形命名法（snake_case），例如file_name.rs、main.rs
- 临时变量名：蛇形命名法（snake_case）
- 全局变量名：
- 结构体： 大驼峰命名法，例如：struct FirstName { name: String}
- enum类型: 大驼峰命名法
- 关联常量：常量名必须全部大写
- Cargo默认会把连字符`-`转换成下划线`_`
- Rust也不建议以`-rs`或`_rs`为后缀来命名包名, 而且会强制性的将此后缀去掉

#### 语句与表达式
Rust 是一门基于表达式（expression-based）的语言.

Rust 的语法分成两大类: 语句 Statement 和表达式 Expression. 语句是指要执行的一些操作但不返回值的表达式, 表达式主要用于计算求值, 它们的区别是后面带不带分号.

语句又分为两种:
1. 声明语句(Declaration statement）

	用于声明各种语言项(Item)，包括声明变量、静态变量、常量 结构体、函数等，以及通过 extern和use引入包和模块等
1. 表达式语句(Expression statement)
	
	特指以分号结尾的表达式. 此类表达式求值结果将会被舍弃, 并总是返回`单元类型()`

rust使用`{}`表示复杂表达式, 比如:
```rust
    // 在块中可以使用函数语句, 最后一个步骤是表达式, 此表达式的结果值是整个表达式块所代表的值, 这种表达式块叫做函数体表达式.
    // 函数体表达式并不能等同于函数体, 它不能使用 return 关键字
    let y = {
        let x = 3;
        x + 1
    };
```

Rust编译器在解析代码的时候，如果碰到分号，就会继续往后面执行; 如果碰到语句，则执行语句; 如果碰到表达式，则会对表达式求值，如果分号后面什么都没有，就会补上单元值.

当遇到函数的时候，会将函数体的花括号识别为块表达式（Block Expression ）. 块表达式是由一对花括号和一系列表达式组成的, 它总是返回块中最后一个表达式的值.

#### 变量和绑定
let创建的变量称为绑定(Binding), 它表明了标识符（ Identifier) 和值（ Value ）之间建立了一种关联关.

> 使用 let 关键字创建变量并绑定一个值是一个语句, 因为语句不返回值， 因此，不能把 let 语句赋值给另一个变量. 在C语言或Ruby语言中的赋值语句会返回所赋的值, 因此`x = y = 6`是正确的, 它使得x和y变量同时拥有6这个值; 而rust不能这样写.

rust类型没有“默认构造函数”，变量没有“默认值” .
Rust 里面的下划线是一个特殊 的标识符，在编译器内部它是被特殊处理的.

Rust的表达式一般可以分为位置表达式(Place Expression ）和 值表达式(ValueExpression). 在其他语言中, 一般叫作左值(Value, 因为它在赋值运算符的左边)和右值(RValue, 除左值外的值).

位置表达式就是表示内存位置的表达式, 分别有以下几类:
- 本地变量
- 静态变量
- 解引用(`*expr`)
- 数组索引(`expr[expr]`) 
- 字段引用（`expr.field`) 
- 位置表达式组合

通过位置表达式可对某个数据单元的内存进行读写. 值表达式一般只引用了某个存储单元地址中的数据, 它相当于数据值, 只能进行读操作.

let关键字声明位置表达式默认不可变, 即**不可变绑定**, 只能对对应的存储单元进行读取. 引用默认情况下也是不可变的.
let mut声明的**可变绑定**可以对相应的存储单元进行写入.

> mut在模式匹配中是修饰变量绑定, `&mut`是表示引用, mut的意义完全不同.

> 在 Rust 中，一般把声明的局部变量并初始化的语句称为`变量绑定`, 强调的是“绑定”的含义，与 C/C＋＋ 中的“赋值初始化”语句有所区别: Rust中，每个变量必须被合理初始化之后才能被使用, 使用未初始化变量这样的错误，在Rust 中是不可能出现的 （利用 unsafe 做 hack 除外）. 编译器做一个执行路径的静态分析，确保变量在使用前一定被初始化.

> 类型一定是跟在冒号`:`后面, 这样语法歧义更少，语法分析器更容易编写.

> const(常量)可以在任意作用域进行定义，而定义的常量贯穿整个程序的生命周期. 在编译的时候，常量就能确定其值, 编译器不一定会给const分配内存空间, 同时编译器**会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址**；对于变量出现重复的定义(绑定)会发生变量遮盖，而对于常量则是不允许出现重复的定义的.

> 全局(static)变量和常量类似，但static变量不会被内联，在整个程序中，全局变量只有一个实例, **必须是编译期可确定的常量**，也就是说所有的引用都会指向一个相同的地址. 因为全局变量可变，就会出被多个线程同时访问的情况，因而引发内存不安全的问题，所以对于全局可变(static mut)变量的访问和修改代码就必须在unsafe块中进行定义. 声明static变量时禁止调用普通函数, 但const fn可以, 因为const fn是编译时执行的.

在存储的数据比较大，需要引用地址或具有可变性的情况下使用静态变量. 否则，应该优先使用普通常量. 推荐使用lazy_static实现复杂的static变量初始化.

> 赋值号左边的部分是一个“模式”，`let (mut a, mut b) = (1, 2);`是对 tuple 的模式解构，`let Point { x : ref a, y : ref b} = p;`是对结构体的模式解构.

格式化输出
ref:
- [字符串操作 - 《Rust程序设计 - 17.4 格式化值》]()

打印操作由 std::fmt 里面所定义的一系列宏来处理，包括：
- format!：将格式化文本写到字符串（String）
- print!：与 format! 类似，但将文本输出到控制台（io::stdout）
- println!: 与 print! 类似，但输出结果追加一个换行符
- eprint!：与 format! 类似，但将文本输出到标准错误（io::stderr）
- eprintln!：与 eprint! 类似，但输出结果追加一个换行符

[println! format](https://doc.rust-lang.org/std/fmt/#formatting-traits):
- nothing(即默认)⇒ Display : `println!("{}",2)`
- ? ⇒ Debug : `println!("{:?}",2)`
- x? ⇒ Debug with lower-case hexadecimal integers
- X? ⇒ Debug with upper-case hexadecimal integers
- :#? ⇒ 带换行和缩进的Debug打印 : `println!("{:#?}",("t1","t2"))` 
- o ⇒ Octal : `println!("{:o}",2)`
- x ⇒ LowerHex : `println!("{:x}",2)`
- X ⇒ UpperHex : `println!("{:X}",2)`
- p ⇒ Pointer : `println!("{:p}",&2)`
- b ⇒ Binary :  : `println!("{:b}",2)`
- e ⇒ LowerExp : `println!("{:e}",2)`
- E ⇒ UpperExp : `println!("{:E}",2)`
- 命名参数       : `println!("{a} {b} {b}",a = "x", b="y")`

> 想把 a 输出两遍可用: `println!("a is {0}, a again is {0}", a);`

#### 所有权与引用
所有权转移: 当位置表达式出现在值上下文中, 表示将会把内存地址转移给另一个位置表达式.

**在语义上, 每个变量绑定实际上都拥有该存储单元的所有权, 这种转移内存地址的行为就是所有权(ownership)的转移, 在rust中称为移动(move)语义, 那种不转移的情况实际上是一种复制(copy)语义. **rust没有gc, 以完全依靠所有权来进行内存管理.

rust提供引用操作符(`&`), 此时不转移所有权, 可直接获取表达式的存储单元地址(即内存位置), 可通过该地址对存储进行读取. 因此引用已被称为借用.

模式匹配可能导致变量所有权转移, 使用ref可避免该情况. ref是模式的一部分, 它只能出现在赋值操作符的左边. `&`是借用运算符, 是表达式的一部分, 只能出现在赋值操作符的右边.

#### 函数和闭包
和主流语言一样, main函数代表程序的入口.

函数是对代码中重复行为的抽象。在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分.

函数是通过关键字 fn 定义的.

rust中函数是一等公民, 其自身可作为函数的参数和返回值使用. 一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包

const 函数是纯函数，必须是可重现的。这意味着它们不能将可变参数带入任何类型，也不能包含动态的操作，例如堆分配.

闭包即匿名函数, 闭包有以下几个特点:
- 可以像函数一样被调用
- 可以捕获上下文环境中的自由变量
- 可以自动推断输入和返回的类型

函数是对代码中重复行为的抽象。在现代编程语言中，函数往往是一等公民，这意味着函数可以作为参数传递，或者作为返回值返回，也可以作为复合类型中的一个组成部分.

闭包与函数的区别: 闭包可捕获外部变量, 而函数不可以.

闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分.

Rust 中闭包实际上就是由一个匿名结构体和 trait 来组合实现的.

```rust
// 一般情况下, 闭包默认会按引用捕获变量, 如果将此闭包返回, 则引用也会跟着返回, 但这里随着函数调用结束, 本地变量i会被销毁, 随闭包返回的i的引用就变成了虚悬指针.
// 因此需要使用move来将被引用的变量的所有权转移到闭包中, 不再按引用捕获变量, 这样闭包才可以安全地返回.
pub fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    move |j| j * i
}
```

#### 作用域与生命周期
rust的作用域是静态作用域, 即词法作用域(lexical scope), 由一对花括号来开辟作用域, 该作用域在词法分析阶段就已确定, 不会动态改变.

变量绑定的生命周期(lifetime): 从使用let声明创建变量绑定开始, 到超出词法作用域的范围时结束.

Rust允许在同一个代码块中声明同样名字的变量的做法被称为变量遮蔽(variable shadow), **个人强烈不推荐使用**. 隐藏区别于mut: 隐藏会创建新变量, 同时可改变其类型.

#### CTFE
rust编译器像C++或D语言一些, 支持编译时函数执行(compile-time function execution, CTFE, from rust 2018).

rust中固定长度的数组必须在编译期就知道长度, 否知会报错, 这就用了CTFE的能力.

`const fn`强制编译器在编译期执行函数, 其中const一般用于定义全局常量.

除了 onst fn 官方还在实现 const generics 特性.

rust编译器目前可以支持的常量表达式有字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等.

# base
## 文档
`cargo doc --no-deps --open`, `--no-deps`是告诉cargo忽略生成依赖项的文档.

> 可以将 cargo doc 与 cargo watch 搭配使用, 以获得无缝编写文档的体验，并在生成的页面上获得对项目中任何文档更改的实时反馈.

> 通过cargo-travis可在在 GitHub 项目的 gh-pages 分支页面上托管项目文档

## 代码
rust代码使用`.rs`扩展名, 且必须是utf-8编码.

注释由rustdoc解析, 支持:
- 元素级：这些注释适用于模块中的元素, 例如结构体、枚举声明、函数及特征常量等. 它们应该出现在元素的上方. 对于单行注释, 它们以`///`开头, 而对于多行
注释, 则以`/*`开头，以`*/`结尾.
- 模块级：这些是出现在根层级的注释, 例如 main.rs、 lib.rs, 以及其他任意模块, 可使用`//!`表示单行注释的开始, 使用`/*!`表示多行注释的开始, 并将`*/`
作为结尾标记. 它们适用于概述软件包和某些示例.

> `///`=`#[doc]`, `//!`=`#![doc]`

这些注释会被转成文档属性`#[doc(key=value)]`.

常见文档属性:
- #![doc(html_logo_url = "image url")：用于在文档页面的左上角添加徽标（ logo）
- #![doc(html_root_url = "https://docs.rs/slotmap/0.2.1")]：用于设置文档页面的统一资源定位器（ Uniform Resource Locator， URL）
- #![doc(html_playground_url = "https://play.rust-lang.org/")]： 用于在文档中的代码示例附近放置一个“ Run”按钮，以便能够通过在线 Rust 工作台运行它
元素级属性
- #[doc(hidden)]：假定你已经为公共函数 foo 编写了文档作为自己的注释，但是不希望该函数的使用者查看这些文档，那么可以使用此属性告知 rustdoc 忽略为 foo 生
成文档
- #[doc(include)]：用于引用来自其他文件的文档。如果文档很长，这有助于你将文档和代码分开

Rust 允许在文档注释中使用`'`来嵌入代码:
```rust
// doctest_demo/src/lib.rs

//! This crate provides functionality for adding things
//!
//! # Examples
//! ```
//! use doctest_demo::sum;
//!
//! let work_a = 4;
//! let work_b = 34;
//! let total_work = sum(work_a, work_b);
//! ```

/// Sum two arguments
///
/// # Examples
///
/// ```

/// assert_eq!(doctest_demo::sum(1, 1), 2);
/// ```
pub fn sum(a: i8, b: i8) -> i8 {
a + b
}
```

## 语句/表达式
> Rust 中一切皆表达式，当某个地方需要一个表达式，但实际却是一个语句时，编译器会自动补上`单元值()`，这算是一个特殊的表达式.

Rust 程序里, 表达式（ Expressio ）和语句（ Statement ）是完成流程控制、计算求值的主要工具. 在Rust 里, 表达式可以是语句的一部分，反过来，语句也可以是表达式的一部分. 一个表达式总是会产生 个值，因此它必然有类型; 语句不产生值，它的类型永远是`()`. 如果把一个表达式加上分号，那么它就变成了一个语句；如果把语句放到一个语句块中包起来, 那么它就可以被当成一个表达式使用.

rust中语句块也可以是表达式的一部分. 语句和表达式的区分是后者不带`;`. 如果带了分号, 意味着这是一条语句，它的类型是`()`; 如果不带分号，它的类型就是表达式的类型.

Rust 中的表达式语法具有非常好的“一致性”，每种表达式都可以嵌入到另一种表达式中，组成更强大的表达式.

Rust 表达式包括字面量表达式、方法调用表达式、数组表达式、索引表达式、单目运算符表达式、双目运算符表达式等:
- 运算表达式

	比较运算符的两边必须是同类型的, 并满足 PartialEq 约束.

	**Rust里面的运算符优先级与C语言里面的运算符优先级设置是不一样的，有些细微的差别. 建议: 如果碰到复杂一点的表达式, 尽量用小括号明确表达计算顺序, 避免依赖语言默认的运算符优先级**.
- 赋值表达式

	Rust规定, 赋值表达式的类型为`unit`即`()`, 以避免像C语言那样的连续赋值, 或者误将`==`写成`=`

	Rust 不支持`++`,`--`运算符，请使用`+=1`,`-=1`替代

	在 rust 中没有必要专门设计像 C/C＋＋ 那样的三元运算符`?:`, 因为通过现有的设计可以轻松实现同样的功能, 且可读性更佳.

Rust 表达式又可以分为‘左值’ （lvalue ）和‘右值’（rvalue)两类. 所谓左值是这个表达式可以表达一个内存地址，它们可以放到赋值运算符左边使用, 其他的都是右值.

Rust 对所有类型（包括结构体）的命名有一个约定，即每个单词的首字母要大写，比如GrayscaleMap，称为驼峰拼写法（CamelCase）。字段和方法的名字要小写，单词间以下划
线分隔，称为蛇形拼写法（snake_case）.

## 变量, 函数和数据结构
Rust 引用永远不为空. 没有跟 C 的 NULL 或 C++ 的 nullptr 对应的东西存在。引用没有默认的初始值（无论什么类型的变量，在其初始化之前都不能使用）。而且， Rust（在 unsafe代码外部）不会将整数转换为引用，因此不能把 0 转换成引用.

- 变量

	- 不可变: `let x:T;`
	- 可变: `let mut x:T;`, 当声明为可变变量时, x的内容可被修改, 且允许可变引用.

		```rust
		let (mut a, mut b) = (1, 2); 
		let Point { x : ref a, y : ref b} = p;
		let mut v:Vec<u8> = Vec::new();
		```

	实际上, let 语句引入了一个模式解构, 不能把 let mut 视为一个组合, 而应该将 `mut x` 视为一个组合.

	Rust中，一般把声明的局部变量并初始化的语句称为“变量绑定”，强调的是“绑定”的含义，与 C/C＋＋ 中的“赋值初始化”语句有所区别.

	Rust 中，每个变量必须被合理初始化之后才能被使用, 使用未初始化变量这样的错误，在Rust 是不可能出现的 （利用 unsafe hack 除外）.

	Rust 允许在同一个代码块中声明同样名字的变量, 如果这样做, 后面声明的变量会将前面声明的变量“遮蔽”(Shadowing)起来. 实际上，传统编程语 C/C＋＋ 中也存在类似的功能，只不过它们只允许嵌套的代码块内部变量出现遮蔽, 而 Rust 在这方面放得稍微宽一点, 同一语句块内部声明的变量也可以发生遮蔽.

	rust变量声明的类型后置更方便类型推导.

	Rust 只允许**`局部变量/全局变量`实现类型推导，而函数签名等场景则是不允许, 这是特意这样设计的**:
	局部变量只有局部的影响; 全局变量必须当场初始化; 而函数名具有全局性影响. 函数签名如果使用自动挡类型推导, 可能导致某个调用的地方使用方式发生变化, 它的参数、返回值类型就发生了变化, 进而导致其他调用地方的编译错误，这是设计者不希望看到的情况.

	> 在编译器能够推导类型的情况下，变量类型一般可以省略，但常量（const）和静态变量（static）必须声明类型

	> Rust 的类型推断基于 Hindly-Milner 类型系统.

- 静态变量:  需要明确指定常量的数据类型

	- 不可变: `static X:T = T::new();`
	- 可变: `static mut X:T = T::new();`

	静态变量和常量一样全局可访问, 它也被编入可执行文件的数据段. 静态变量可以被声明为可变.

	static 语句同样也是一个模式匹配, 与let 不同的是，用static 声明的变量的生命周期是整个程序，从启动到退出, static变量的生命周期永远是`'static`, 它占用的内存也不会在执行过程中被回收. 这也是 rust 中唯一的声明全局的方法.

	在使用静态变量时, 有一些限制, 可用lazy_static检查:
	1. 全局变量必须在声明的时候马上初始化

		**局部变量声明后只要在使用前初始化即可**.
	1. 全局变量的初始化必须是**编译期常量**，不能包括执行期才能确定的表达式、语句和函数调用
	1. 带有 mut 修饰的全局变量，在使用的时候必须使用 unsafe 关键字

		修改静态变量本质上不是线程安全的.

	rust禁止在声明static变量的时候调用普通函数, 或者利用语句块调用其他非const代码. const fn是允许的, 因为它是在编译期执行的.

	> 名称要求使用大写，否则编译器会报 Warning

- 常量: 不允许用mut修饰, 且需要明确指定常量的数据类型.

	`const X:T = <value>;`

	常量是一个右值, 它不能被修改. 常量编译后会被放在可执行文件的数据段, 全局可访问.

	常量的初始化表达式也一定是一个**编译期常量**, 不能是运行期的.

	它与 static 大区别在于: 编译器并不一定会给const常量分配内存空间, 在编译过程中，它很可能会被内联优化. 因此, 千万不要用 hack 的方式, 通过 unsafe 代码去修改常量的值, 这么做是没有意义的. const也不具备类似 let 模式匹配功能.

	常量不支持重定义（遮蔽），这和变量是不同的.

	> 常量名一般使用大写字母，否则编译器会报 Warning.

	与静态变量的区别:
	1. 常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址
	1. 常量不可变，而静态变量和普通变量一样，默认不可变，但可以通过 mut 关键字定义为可变

	结构体、枚举和特征中的常量:
	```rust
	enum Item {
	    One,
	    Two,
	}
	struct Food {}

	impl Item {
	    const DEFAULT_COUNT: u32 = 34;
	}
	impl Food {
	    const FAVORITE_FOOD: &str = "Cake";
	}

	trait Circular {
	    const PI: f64 = 3.14;
	    fn area(&self) -> f64;
	}
	struct Circle {
	    rad: f64,
	}
	impl Circular for Circle {
	    fn area(&self) -> f64 {
	        Circle::PI * self.rad * self.rad
	    }
	}
	fn main() {
	    let c_one = Circle { rad: 4.2 };
	    println!("Area of circle one: {}", c_one.area());
	}
	```

- 函数: `func x(a1:T1,...)-> T{}`

	> Rust 函数名一般建议使用下划线风格（小写字母），即 蛇形命名法（snake_case），否则编译器会警告；而 Go 使用驼峰风格

	> 函数参数和变量一样，默认是不可变的，当需要可变参数时，可使用 mut 修饰.

	> 虽然 Rust 不支持多返回值，但因为有元组类型，因此返回元组相当于支持多返回值.

	rust函数使用fn标识, 其参数列表与let一样也可模式解构.

	在rust中， 如果函数没有返回值， 那么其返回值是unit即空元组`()`

	Rust 中, 每个函数具有自己单独的类型，但是这个类型可以自动转换成fn类型. 因此两个有同样的参数类型和同样的返回值类型的函数, 但它们是不同类型因而不能赋值给相同变量, 解决方案是让先转为通用的fn类型即可.

	Rust 支持一种特殊的发散函数（ Diverging functions ）, 它的返回类型是`!`. 发散类型的最大特点就是，它可以被转换为任意一个类型.

	Rust 中，有以下这些情况永远不会返回，它们的类型就是!:
	1. panic 以及基于它实现的各种函数/宏，比如`unimplemented!, unreachable!` ; 
	1. 死循环 `loop {}`
	1. 进程退出函数 `std::process::exit` 以及类似的 libc 中的 exec 一类函数

	在大部分主流操作系统上，一个进程开始执行的时候可以接受一系列的参数，退出的时候也可以返回一个错误码. 许多编程语言也因此为 main 函数设计了参数和返回值类型, rust和go不同, 传递参数和返回状态码都由单独的 API 来完成.

	Rust 设计组扩展了 main 函数的签名，使它变成了一个泛型函数，这个函数的返回类型可以是任何一个满足 Terminationtrait的类型，其中`（）,booL Result` 是满足这个约束的，它们都可以作为 main 函数的返回
类型.

	函数可以用 const 键字修饰，这样的函数可以在编译阶段被编译器执行，返回值也被视为编译期常量.

	Rust 函数参数的类型和返回值的类型都必须显式定义，如果没有返回值可以省略，返回 unit。函数内部如果提前返回，需要用 return 关键字，否则最后一个表达式就是其返回值。如果最后一个表达式后添加了; 分号，隐含其返回值为 unit.

	example:
	```rust
	fn pi() -> f64 {
	  3.1415926
	}

	fn not_pi() {
	  3.1415926;
	}

	fn main() {
	  let is_pi = pi();
	  let is_unit1 = not_pi();
	  let is_unit2 = {
	    pi();
	  };
	  
	  println!("is_pi: {:?}, is_unit1: {:?}, is_unit2: {:?}", is_pi, is_unit1, is_unit2);
	}
	```

- 元组: 它通过圆括号包含一组表达式构成

	如果元组中只包含一个元素, 应该在后面添加一个逗号, 以区分括号表达式和元组. 元组内部也可以一个元素都没有 这个类型单独有一个名字， unit （单元类型）.
	访问元组内部元素有两种方法, 一种是“模式匹配”（ pattern destructuring ）, 另外一种是“数字索引”.

	unit 类型是 Rust 最简单的类型之一， 是占用空间最小的类型之一. 空元组与空结构体 struct Foo 一样，都是占用0字节空间. `std::mem::size_of`函数可以计算一个类型所占用的内存空间.

	> 元组只允许用常量作为索引

- 结构体: `struct S{...}`, 不能使用自动类型推导功能, 必须显式指定.

	三种形式:
	1. 空结构体, 不占用任何空间, 比如`struct Marker;`
	1. 元组结构体(`tuple struct `), struct的每个成员都是匿名的, 可通过索引范围, 比如`struct Color(u8,u8,u8);`
	1. 普通结构体, struct的每个成员都有名字, 可通过名字访问

		```rust
		struct Person{
			name: String,
			age: u8,
		}
		```

	Rust 允许 struct 类型的初始化使用一种简化的写法: 如果有局部变量名字和成员变量名字恰好一致, 那么可以省略掉重复的冒号初始化.

	Rust 设计了一个语法糖，允许用一种简化的语法赋值使用另外一个 struct 的部分成员: `..expr`这样的语法, 只能放在初始化表达式中, 所有成员的最后最多只能有一个.

	`struct Fool;`/`struct Foo();`/`struct Foo{}`其实是同一个东西.

	tuple struct 一个特别有用的场景，那就是当它只包含一个元素的时候，就是所谓的newtype idiom. 因为它实际上让我们非常方便地在一个类型的基础上创建了一个新的类型.

	通过关键字 type, 可创建一个新的类型名称，但是这个类型不是全新的类型，而只是一个具体类型的别名, 在编译器看来, 这个别名与原先的具体类型是一模一样. 而使用 tuple struct 做包装，则是 创造了一个全新的类型，它跟被包装的类型不能发生隐式类型转换, 可以具有不同的方法, 满足不同的 trait, 完全按需而定.

	`Account { name, .. }`的`...`表示不关心Account除name外的其他字段.

- enum: `enum E{...}`

	两种形式:
	1. 枚举

		```rust
		enum Status {
			Ok = 0,
			Bad = 1,
			NotFound = 2,
			...
		}
		```
	1 标签联合

		enum可承载多个不同的数据结构中的一种, 比如元组和struct.

		```rust
		// 由于它实在是太常用, 标准库将 Option 以及它的成员 Some,None 都加入到了Prelude, 它表示的含义是`要么存在、要么不存在`
		// Rust 在语言层面彻底不允许空值 null 的存在，但无奈null 可以高效地解决少量的问题，所以 Rust 引入了 Option 枚举类. Option 是 Rust 标准库中的枚举类，这个类用于填补 Rust 不支持 null 引用的空白.
		// 由于 Option 是 Rust 编译器默认引入的，在使用时可以省略 `Option::` 直接写 None 或者 Some().
		enum Option<T>{
			Some(T),
			None,
		}
		```

		> 很多语言默认不允许 null，但在语言层面支持 null 的出现（常在类型前面用`?`符号修饰）.

	如果说`tuple, struct, tuple struct`, 在Rust 中代表的是多个类型的“与”关系，那么 enum 类型在 Rust 中代表的就是多个类型的“或”关系.

	与C/C＋＋ 中的枚举相比, Rust 中的 enum 要强大得多，它可以为每个成员指定附属的类型信息. 它是一种更安全的类型, 可以被称为`tagged union`.

	rust enum内存布局:
	- tag: 	一个内部的整数`tag 标记`来描述当前变量属于哪种类型

		这个标记对用户是不可见的，通过恰当的语法设计，保证标记与类型始终是匹配的，以防止用户错误地使用内部数据.

		Rust 对某些枚举会直接优化掉标签字段. 比如上面的Option, 如果其类型 T 是 Box 或其他智能指针类型， Rust 就会省掉 Option<T> 的标签字段. 因此 `Option<Box<i32>>` 在内存中只用 1 个机器字存储, 0 表示 None，非零表示 Some 封装的值
	- value: 足以容纳最大变体所有字段的内存来存储

	Rust 里面也支持 union 类型，这个类型与C语言中的 union 完全一致, 但在 Rust 里面，读取它内部的值被认为是 unsafe 行为, 一般情况下我们不使用这种类型. 它存在的主要目的是为了方便与C语言进行交互.

	```rust
	enum Number {
		Int(i32),
		Float(f32),
	}
	```
	等价于:
	```c
	struct Number {
		enum {Int, Float} tag;
		union {
			int32_t int_value;
			float float_value;
		} value;
	};
	```

	在实际中, enum 的内存布局未必是这个样子， 编译器有许多优化，可以保证语义正确的同时减少内存使用，并加快执行速度. 如果是在 FFI 下， 要保证 Rust 里面的 enum 的内存布局和C语言兼容的话, 可以给这个 enum 添加一个`#[repr(C, Int)]`属性标签.

	> rust的enum其实是一种代数类型系统(Algebraic Data Type, ADT), 即enum内部的variant(用于区分enum里面的数据类型)的类型是函数类型. 因此Some可以当成函数作为参数传递给迭代器的`map()`. 其实struct也是ADT, 枚举被称为求和类型, 是因为它可以容纳的值的范围基本上是其变体的取值范围的总和; 而结构体被称为乘积类型, 是因为它的取值区间是其每个字段取值区间的笛卡儿积.

Rust 里的合法标识符（包括变量名、函数名、 trait 名等） 必须由数字、字母、 下划线组成， 且不能以数字开头, 这个规定和许多现有的编程语言是一样.

rust的`_`和go类似, 是一个特殊的标识符，在编译器内部它是被特殊处理的, 其的含义是`忽略这个变量绑定, 后面不会再用到了`.

Rust 中, enum和struct均为内部成员创建了新的名字空间, 如果要访问内部成员，可
以使用`::`, 不同的 enum 中重名的元素也不会互相冲突.

rust复合类型支持递归定义, 但需要使用指针, 否则计算其大小时因递归而无解.


type alias:
```rust
type Carry = u8;
```

## 基本数据类型
基本数据类型也叫标量类型(scalar type), 表示只能存储单个值的类型.

rust有四种标量类型:整型, 浮点, 布尔, 字符型.

- bool : true, false
- char : 单个字符, 大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value）, 等价于go的rune. char 由单引号包裹, 不同于字符串使用双引号.

	对于ASCII字符用`u8`表示.
	
	> Unicode 标量值包含从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF 在内的值.
- 整数

	整数是一个没有小数部分的数字. 有符号整数范围: -2^(n-1)~2^(n-1)-1; 无符号范围: 0~2^n-1

	> 如果一个变量是有符号类型，那么它的最高位的那一个 bit 就是“符号位”，表示该数为正值还是负值; 如果个变量是无符号类型，那么它的最高位和其他位一样，表示该数的大小.

    大小  有符号     无符号
    8 bit   i8  u8
    16 bit  i16     u16
    32 bit  i32     u32
    64 bit  i64     u64
    128 bit     i128    u128
    Arch    isize   usize // arch 是由 CPU 构架决定的大小的整型类型, 与指针占用的空间大小一致, 在 x86 机器上为 32 位，在 x64 机器上为 64 位. 即isize和usize是自适应类型, 它们主要作为某些集合的索引.

    > Rust 要求数组索引必须是 usize 值.

    > 所有数值字面量支持任意位置添加`_`以方便阅读, 并且支持后缀表示类型, 比如`0x_ff_u8`

    > 整数自动推导时**默认是i32**, 即使在 64 位机器上也是 i32.

    > 字面量后面可以跟后缀，可代表该数字的具体类型，从而省略掉显示类型标记, **个人不推荐**.

    > rust不支持`++/--`

    > Rust 也继承了 C 的按位整数操作符 &、 |、 ^、 << 和 >>, 但对于按位非， Rust 使用 `!` 而不是 `~`

    > 与 C 不一样， Rust 中位操作的优先级高于比较操作。`x & BIT != 0` =>`(x & BIT)!= 0`

    c中无符号算术运算永远不会overflow, 如果超出范围则自动舍弃高位数据; 有符号如果发生了overflow, 则是undefined behavior, 由编译器处理. 

    未定义行为有利于编译器做一些更激进的性能优化，但是这样的规定有可能导致在程序员不知情的某些极端场景下, 产生诡异 bug.

    Rust 的设计思路则倾向于预防 bug, 而不是无条件压榨效率, Rust 设计者希望能尽量减少`未定义行为`. 因此rust在debug模式下编译器自动插入溢出检查, 一旦溢出就panic; 在release下, 不检查整数溢出, 而是自动舍弃高位即二进制补码包装（two’s complement wrapping）的操作. rustc可使用`-C overflow-checks=no/yes`决定是否开启溢出检查.

    开发者可以调用标准库中的`checked_*, saturating_*, wrapping_*`系列函数更精细地自主控制整数溢出的行为:
	- `checked_*`系列函数返回的类型是`Option<_>`, 当出现溢出的时候，返回None
	- `saturating_`系列函数返回类型是整数, 如果溢出，则给出该类型可表示范围的`最大/最小`值
	- `wrapping_*`系列函数则是直接抛弃已经溢出的最高位, 将剩下的部分返回.

	在对安全性要求非常高的情况下, 强烈建议用户尽量使用这几个方法替代默认的算术运算符来做数学运算. rust 标准库中就大量使用了这几个方法. ，标准库还提供了一个叫作`std::num::Wrapping<T>`的类型, 它重载了基本的运算符， 可以被当成普通整数使用, 凡是被它包起来的整数, 任何时候出现溢出都是截断行为.

	```rust
	fn main() { 
	    let i = 10 0 i8; 
	    println! ("checked { : ?}", i.checked_add(i)); 
	    println! ("saturating {:?}", i.saturating_add(i)); 
	    println! ("wrapping {:?}", i. wrapping_add( i));
	}

	输出结果为:
	checked None
	saturating 127
	wrapping - 56
	```
- 浮点型

	rust提供基于IEEE-754-2008标准的浮点类型: f32/f64. `std::num::FpCategory`可表示浮点状态(`Nan/Infinite/Zero/Subnormal/Normal`), 默认是f64.

	标准库 std::f32和std::f64都提供了 IEEE 所需的特殊常量值, 比如INFINITY （无穷大）、 NEG INFINITY （负无穷大）、 NAN （非数字值）,MIN（最小有限值)和MAX(最大有限值）.

	> 非0数除以0是inf; 0除以0是Nan; `inf * 0.0`=Nan; `inf/inf`=NaN.
- 数组

	数组Array是 Rust内建的原始集合类型, 数组的特点为:
	- 数组大小固定
	- 元素均为同类型
	- 默认不可变

	数组的类型签名为`[T;N]. T是一个泛型标记, 代表数组中元素的某个具体类; N代表数组的长度, 是一个编译时常量, 必须在编译时确定其值.

	数组是在栈（stack）而不是在堆（heap）上为数据分配内存空间. 对于原始固定长度数组，只有实现了 Copy trait 的类型才能作为其元素，也就是说，只有可以在栈上存放的元素才可以存放在该类型的数组中.

	未来rust 还将支持VLA (variable-length array ）数组即可变长度数组. 对于可变长度数组, 将会基于可以在栈上动态分配内存的函数来实现.
- range

	Range是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列.

	range类型包括左闭右开和全闭两种区间.

	`(1..5)` 表示左闭右开区间,`（1..=5）`则表示全闭区间. 它们分别是 `std::ops::Range`和`std::ops::Rangelnclusive`的实例.

- slice

	slice是对一个数组(包括固定大小数组和动态数组)的**引用**片段. 在底层，切片代表一个指向数组起始位置的指针和数组长度. 如果用`[T]`类型表示连续序列，那么切片类型就是`&[T]`和`&mut[T]`.

- str字符串类型(也叫字符串切片)

	出于内存安全的考虑, Rust 将字符串分为两种类型, 一种是固定长度字符串，不可随便更改其长的str 字符串; 另一种是可增长 符串，可以随意改变其长度的String字符串.

	本质上, 字符串字面量属于 str 类型, 只不过它是静态生命周期字符串`&'static str`.
	所谓静态生命周期，可以理解为该类型字符串和程序代码一样是持续有效.

	str 字符串类型由两部分组成：指向字符串序列的指针和记录长度的值. 可以通过 str模块提供的 as_ptr 和len方法分别求得指针和长度.

	Rust 中的字符串本质上是一段有效的 UTF8字节序列.
- 指针
	> 与 C 指针不同的是， Rust 引用永远不会是空值，因为在安全 Rust 代码中根本不可能产生空引用, 而且 Rust 引用默认是不可修改的.

	无GC 的编程语言， C/C++以及 Rust, 对数据的组织操作有更多的自由度, 表现为:
	- 同一个类型，某些时候可以指定它在栈上, 某些时候可以指定它在堆上. 内存分配方式可以取决于使用方式, 与类型本身无关.
	- 既可以直接访问数据 ，也可以通过指针间接访问数据. 可以针对任何一个对象取得指向它的指针
	- 既可以在复合数据类型中直接嵌入别的类型的实体, 也可以使用指针, 间接指向别的类型
	- 甚至可能在复合数据类型末尾嵌入不定长数据构造出不定长的复合数据类型

	Rust 有不止一种指针类型, 常见的几种指针类型:
	- `Box<T>` : 指向**在堆上分配**的类型T的, 具有所有权的指针, 有权释放内存

    	Rust中的值默认被分配到栈内存, 可通过`Box<T>`将值装箱(在堆内存中分配). 可通过解引用来获取`Box<T>`中的T. 因为`Box<T>`的行为像引用, 并且可以自动释放内存, 因此将其称为智能指针.

    	Box 类型的所有权语义取决于包装类型。如果基础类型为Copy, 那么 Box 实例将成为副本，否则默认情况下将发生移动.

    	String类型和Vec类型的值都是被分配到堆内存并返回指针的，通过将返回的指针封装来实现Deref和Drop.

    	```rust
    	struct Node {
			data: u32,
			next: Option<Box<Node>>
		}
    	```

    	Box<T>是指向类型为T的堆内存分配值的智能指针. 当Box<T>超出作用域范围时，将调用其析构函数，销毁内部对象，并自动释放堆中的内存.
	- `&T` : 指向类型T的借用指针, 也称为引用, 无权释放内存, 无权写数据, 是 Copy 类型.

		类似C中的`const T*`
	- `&mnut T` : 指向类型T的mut型借用指针, 无权释放内存, 有权写数据, 不是Copy类型.

		类似C中的`T*`
	- `*const T` : 指向类型T的只读裸(即原始)指针, 没有生命周期信息, 无权写数据. 它是 Copy 类型。这类似于&T，只是它可以为空值.
	- `*mut T` : 指向类型T的可读写裸(即原始)指针, 没有生命周期信息, 有权写数据.  它不支持 Copy 特征（ non-Copy）.

	> Rust 的原始指针实际上就是 C++ 中的那种指针, 使用原始指针是不安全的，因为 Rust 不会跟踪它指向哪里.

	```rust
	fn main() {
		// 可将引用强制转换为原始指针
	    let a = &56;
	    let a_raw_ptr = a as *const i32;
	    // or
	    let b = &mut 5634.3;
	    let b_mut_ptr = b as *mut f64;
	}
	```

	此之外，在标准库中还有一种封装起来的可以当作指针使用的类型, 即智能指针(smart pointer, 来自c++):
	- `Rc<T>` : 指向类型T的引用计数指针, 共享所有权, 线程不安全

	    通过clone方法共享的引用所有权称为强引用，RC<T>是强引用.

	    当与一个 Rc 类型交互时，其内部会发生如下变化:
		- 当通过调用 Clone()获取对 Rc 的一个新共享引用时， Rc 会增加其内部引用计数。Rc 内部使用 Cell 类型处理其引用计数。
		- 当引用超出作用域时，它会对引用计数器执行递减操作。
		- 当所有共享引用计数超出作用域时， refcount 会变成 0。 此时， Rc 上的最后一次 drop	调用会执行相关的资源清理工作

		Rc<T>主要通过两种方式使用:
		- 静态方法 Rc::new 会生成一个新的引用计数器。
		- clone 方法会增加强引用计数并分发一个新的 Rc<T>

		Rc 内部会保留两种引用：强引用（ Rc<T>）和弱引用（ Weak<T>）。二者都会维护每种类型的引用数量的计数，但是仅在强引用计数值为零时，才会释放该值. 它的弱引用可打破引用循环.
	- `Arc<T>` : 指向类型T的原子型引用计数指针, 共享所有权, 线程安全
	- `Cow<’a, T>` : Clone-on-write, 写时复制指针. 可能是借用指针, 也可能是具有所有权的指针 

    	Cow<T>的功能是：以不可变的方式访问借用内容，以及在需要可变借用或所有权的时候再克隆一份数据. Cow<T>旨在减少复制操作，提高性能，一般用于读多写少的场景. Cow<T>的另一个用处是统一实现规范.
    - Cell<T>：提供实现了 Copy 特征的类型的内部可变性. 换句话说，有可能获得多个可变引用

    	在一个不可修改的值内部有一个小小的可修改数据, 这就叫作内部修改能力（interior mutability）.

    	Cell 唯一特别的地方是不需要对其自身的mut 引用, 也能取得或设置其私有字段的值.

    	Cell<T>可以为值提供可变性，甚至允许值位于不可引用之后。它以极低的开销提供此功能:
		- Cell::new 方法允许你通过传递任意类型 T 来创建 Cell 类型的新实例。
		- get:get 方法允许你复制单元（ cell）中的值。仅当包装类型 T 为 Copy 时，该方法
		才有效。
		- set：允许用户修改内部的值，即使该值位于某个不可变引用的后面. 这个方法的 self 参数是以非 mut 引用的形式传入的
	- RefCell<T>：提供了类型的内部可变性，并且不需要实现 Copy 特征. 它用于运行时的锁定以确保安全性

		与 Cell<T> 类似， RefCell<T> 是只包含一个 T 类型值的泛型类型. 但与 Cell 不同， RefCell 支持借用它的 T 类型值的引用.

		为某个非 Copy 类型支持 Cell 的功能

		RefCell 类型提供了以下方法:
		- new : 创建一个新 RefCell，将 value 转移到其中
		- borrow : 回一个 Ref<T>，基本上是对 ref_cell 中值的共享引用. 如果这个值已经被可修改地借用了，这个方法会panic
		- borrow_mut : 返回一个 RefMut<T>，基本上是对 ref_cell 中值的可修改引用。如果这个值已经被借用了，这个方法会panic.

		上述两个 borrow 方法之所以会panic，是因为试图破坏 Rust 中 mut 引用是排他引用的规则.

		唯一的不同是，常规情况下把引用保存到变量， Rust结构体会通过编译时检查来确保安全地使用它。如果检查失败，编译器会报错。而 RefCell 会通过运行时检查强制应用相同的规则。因此如果开发者破坏了规则，就会收到panic

	Cell和 RefCell，以及包含它们的任何类型，都不是线程安全的. 为此， Rust 不会同时允许多个线程访问它们.

	`Rc<T>和Arc<T>`多用于gui编程. Cell和RefCell提供了共享可变性, 此时会将借用检查从编译时移动到运行时. 这是通过内部可变性实现的.

	> 内部可变性：在这种可变性中，即使你有一个引用某种类型的&SomeStruct，如果其中的字段类型为 Cell<T>或 RefCell<T>，那么仍然可以修改其字段.

Rust使用as用于类型转换, 前提是编译器认为是合理的转换.


智能指针是因为它们还具有与之相关联的额外元数据和代码, 它们会在创建和销毁指针时被调用和执行. 智能指针超出作用域时能够自动释放底层资源是采用它们的主要原因之一.
智能指针的大部分特性要归功于两个特征Drop 和 Deref:
- Drop: 释放资源, 通常由Rust编译器在编译后的代码中每个作用域结束的位置插入 drop 方法调用, 类似C++中的析构函数.

	它包含一个 drop 方法, 当对象超出作用域时就会被调用。该方法将&mut self 作为参数。使用 drop 释放值是以LIFO 的方式进行的.
- Deref: 它定义了一个名为 Deref 的方法，并会通过引用获取 self 参数，然后返回对底层类型的不可变引用, 即让指针反映封装值的类型

	DerefMut可提供对底层类型的可变引用.


Deref 和 DerefMut 特型的设计初衷是为了实现智能指针类型（如 Box、Rc 和 Arc），以及某些会频繁通过引用来使用的类型的所有者版本（如 Vec<T> 和 String 就是 [T] 和 str 的所
有者版本）。如果目的仅仅是让 Target 类型的方法自动在类型上可见（就像 C++ 中让基类的方法在子类上可见那样），则不应该实现 Deref 和 DerefMut。这样并不能保证始终有效，
一旦出问题则很难发现.

打印类型:
```rust
fn print_type_of<T>(_: &T) {
		println!("{}", std::any::type_name::<T>())
}

fn main() {
    let x = 32;
    print_type_of(&x);
  	// 输出：i32
}
```

## 复合(compound)类型
复合类型（Compound types）可以将多个标量组合成一个类型. Rust 有两个原生的复合类型：元组（tuple）和数组（array）.

rust提供5种复合类型:
1. 元组(Tuple) : 一种**异构有限**序列, 即元素类型可能不同的**固定长度**的序列. 

    **如果元组中只包含一个元素，应该在后面添加一个逗号，以区分括号表达式和元组**.

    通过`tuple_name.<N>`的形式访问.
    因为let支持模式匹配(pattern destructuring), 因此可用let解构元组.
    单元值(unit)就是空元组`()`, 不占用内存空间, 可用`std::mem::size_of::<()>()`查看.

    当元组中只有一个元素时（即元组长度是 1），唯一的元素后面必须加上逗号, 这是避免将小括号当做计算的优先级.
1. 数组(array) : 与元组不同，数组中的每个元素的类型必须相同. Rust 中的**数组是固定长度**的：一旦声明，它们的长度不能增长或缩小. **数组的大小是在编译时确定
的常量**.

    定义: `let a: [T; n] = {}`
    vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型.

    将所有元素初始化为相同值的语法: `let ys: [i32;500] = [1;500]`

    在rust中, 两个元素类型和成员个数相同的数组才是同类型的.

    多维数组: `[[T;m];n]`

    Rust 中关于数组越界的行为, 定义得非常清晰. 相比于 C/C+, Rust消除的是`"未定义行为"(Undefin Behaviour)`

    > 当想要在栈（stack）而不是在堆（heap）上为数据分配空间, 或者是想要确保总是有固定数量的元素时，数组非常有用. 但是数组并不如 vector 类型灵活.

1. 结构体(Struct)

    Rust 允许 struct 类型的初始化使用一种简化的的写法: 如果有局部变量名字与成员变量名字恰好一致, 那么可以省略掉重复的冒号初始化`: `, 比如:
    ```rust
    fn build_user(email: String, username: String) -> User {
        User {
            email,
            username,
            active: true,
            sign_in_count: 1,
        }
    }
    ```

    结构体更新语法（struct update syntax）: 使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例, 比如:
    ```rust
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
    // 使用结构体更新语法为一个 User 实例设置新的 email 和 username 值，不过其余值来自 user1 变量中实例的字段
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1 //  `..user1`后面不可以有逗号
    };
    ```

    结构体名称需遵从驼峰式命名规则.
    结构体上方的`#[derive(Debug, PartialEq)]`是[属性(类似于代码生成)](https://doc.rust-lang.org/reference/attributes/derive.html), 可让结构体自行实现Debug trait 和 PartialEq trait, 即允许对struct实例进行打印(通过`{:?}或{:#?}`)和比较.

    分三种:
    1. 具名结构体(named-field struct)

        它是rust面向对象思想的一种体现.
    1. 元组结构体(tuple-like struct)

        没有字段名称, 仅有类型. 比如`struct Color(i32, i32, i32);`
        当一个元组结构体只有一个字段时, 比如`struct UserId(u64);`, 称为New Type模式. 因为它把一种类型封装成了新类型.

        > 对于具有 3 个以上字段的数据类型，建议具名结构体.
    1. 单元结构体(unit-like struct)

        没有任何字段的结构体, 比如`strcut Empty{}`.
        `std::ops::RangeFull`就是一个单元结构体.

        在Release编译模式下, 单元结构体实例会被优化为同一个对象; 而在Debug模式下, 则不会进行这样的优化.

        类单元结构体常常在想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用.

    在rust中函数和方法是有区别的, 不在impl块中定义的函数是自由函数, 而在impl块中定义的函数是方法, 第一个参数通常是`&self/&mut self`, 表示对结构体实例自身的引用.

    > impl方法分关联方法和实例方法, 区别是关联方法没有self类型参数, 而实例方法有. 其实`instance.foo()`是一种语法糖, 等价于`<InstanceType>::foo(&instance)`

    > 如果结构体类型包含引用，则必须指定这些引用的生命期

    > 生命周期可确保结构体引用的数据有效性跟结构体本身保持一致, 如果尝试在结构体中存储一个引用而不指定生命周期将是无效的即会报错.

    > 引用结构体成员给其他变量赋值时, 要注意：所有权的转移可能会破坏结构体变量的完整性.

1. 枚举体(Enum)

    分三类:
    1. 无参数枚举体

        ```rust
        enum Number {
            Zero,
            One,
        }

        let a = Number::One;
        ```
    1. 类C枚举体

        ```rust
          enum Number {
            Zero = 1 ,
            One = 2,
        }

        let a = Number::One as i32;
        ```
    1. 带类型参数的枚举体

        ```rust
          enum IpAddr {
            V4(u8,u8,u8,u8),
            V6(String),
        }

        let a = IpAddr::V4(127,0,0,1);
        let b : fn(String) -> IpAddr = IpAddr::V6;//  IpAddr::V6是 `fn(String) -> IpAddr` 函数指针.

        enum Message {
            Quit,
            Move { x: i32, y: i32 }, // 此时并不能像访问结构体字段一样访问枚举类绑定的属性, 而是需要使用`match`
            Write(String),
            ChangeColor(i32, i32, i32),
        }

        // 上面那个枚举等同于有四个含有不同类型的成员
        struct QuitMessage; // 类单元结构体
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // 元组结构体
        struct ChangeColorMessage(i32, i32, i32); // 元组结构体


        // 等价的c定义
        struct Message {
            int tag;
            union {
                struct {} Quit;
                struct {
                    int32_t x, y;
                } Move;
                struct {
                    char* a;
                } Write;
                struct {
                    int32_t _1, _2, _3;
                } ChangeColor;
            } cases;
        }

        enum Book {
            Papery {index: u32},
            Electronic {url: String},
        }
       
        let book = Book::Papery{index: 1001};
        let ebook = Book::Electronic{url: String::from("url...")};
       
        match book {
            Book::Papery { index } => {
                println!("Papery book {}", index);
            },
            Book::Electronic { url } => {
                println!("E-book {}", url);
            }
        }
        ```

        **结构体和枚举还有另一个相似点：可以使用 impl 在枚举上定义方法**.

        Rust的enum与C++ 的enum和union都不同. 它是一种更安全的类型, 可以被称为["tagged union"](https://www.zhihu.com/question/452956370). 这个情况下, rust一般再加一个整型（一般是4 byte，有例外）用作tag, 然后每个case都是一个struct，最后在union起来. enum的某些情况是可以优化的, 优化方法: niche optimization.


        ```rust
        enum Number { 
            Int(i32),
            Float(f32), 
        }
        ```
        用c理解即是:
        ```c
        struct IpAddr { 
            enum {Int, Float} tag; 
            union { 
                int32_t int_value; 
                float float_value; 
            } value; 
        };

        enum Foo {
            C1(&i32, bool),
            C2,
            C3
        }

        // 可被优化成: 当_2为0或者1时Foo表示C1，为2时表示C2，为3时表示C3。 后两种情况下的_1的值未定义.
        struct Foo {
            int32_t *_1;
            uint8_t _2;
        }
        ```

        Rust enum 类型的变量需要区分它里面的数据究竟是哪种变体, 所以它包含了一个内部的`tag 标记`来描述当前变量属于哪种类型. 这个标记对用户是不可见的, 通过恰当的语法设计, 保证标记与类型始终是匹配的，以防止用户错误地使用内部数据, 可用`std::mem::size_of::<Number>()`输出大小来验证.
1. 联合体(Union) 
    rust也支持 union 类型, 这个类型与C中的 union 完全一致, 但在 Rust 里面, 读取它内部的值被认为是 unsafe 行为, 一般情况下不使用这种类型, 而它存在的主要目的是为了方便与C语言进行交互.


> tuple, struct, tuple struct 这几种类型，实质上是同样的内存布局，区别仅仅在于是否给类型及成员起了名字.

## 类型转换
在 Rust 中，将一个值从一种类型转换为另一种类型通常需要显式转换。类型转换使用 as.

不过，有些涉及引用类型的转换非常简单直接，根本不需要显式进行:
- 把一个 mut 引用转换为非 mut 引用
- &String 类型的值会自动转换为 &str 类型
- &Vec<i32> 类型的值会自动转换为 &[i32]
- &Box<Chessboard> 类型的值会自动转换为 &Chessboard

上述的后3种转换被称为“解引用强制转换”（deref coercion），因为它们适应于实现了内置的 Deref特型的类型。比如`&Box<Chessboard>`解引用强制转换的目的是让 Box 这种智能指针类型看起来尽可能像它后面的值.

## 流程控制
主流编程语言都会有常用的流程控制语句:条件语句和循环语句. Rust也有但叫做流程控制表达式.

满足某个条件时会跳转, Rust 支持
- 分支跳转: `if/else`
- 模式匹配: Rust 的模式匹配可以通过匹配表达式或者值的某部分的内容，来进行分支跳转
	
	需要根据表达式**所有可能**的值进行匹配, 并进行相应的处理.

	`match expr {}`或`if let pat = expr {}`, `if let`是match的简写, 表示仅关心某种模式匹配的情况

	Rust 的模式匹配吸取了函数式编程语言的优点，强大优雅且效率很高. 它可以用于 struct / enum 中匹配部分或者全部内容.

	```rust
	use std::str::FromStr;
	/// 解析字符串s，格式为一对坐标值，如"400x600"或"1.0,0.5"
	///
	/// 特别地， s的格式应该是"<左值><分隔符><右值>"的形式，其中<分隔符>
	/// 就是separator参数传入的字符，而<左值>和<右值>都是字符串，可以通过
	/// T::from_str来解析
	///
	/// 如果s的格式没错，就返回Some<(x, y)>。如果解析出错，则返回None
	fn parse_pair<T: FromStr>(s: &str, separator: char) -> Option<(T, T)> {
		match s.find(separator) {
			None => None,
			Some(index) => {
				match (T::from_str(&s[..index]), T::from_str(&s[index + 1..])) {
					(Ok(l), Ok(r)) => Some((l, r)),
					_ => None
				}
			}
		}
	}

	#[test]
	fn test_parse_pair() {
		assert_eq!(parse_pair::<i32>(",10", ','), None);
		assert_eq!(parse_pair::<i32>("10,20", ','), Some((10, 20)));
		assert_eq!(parse_pair::<f64>("0.5x1.5", 'x'), Some((0.5, 1.5)));
	}
	```

	```rust
	match balloon.location {
		Point { x: 0, y: height } => // 匹配x=0的情况, 不能放在`Point { x: x, y: y }`后避免`unreachable pattern`
			println!("straight up {} meters", height),
		Point { x: x, y: y } =>
			println!("at ({}m, {}m)", x, y)
	}
	```

- 错误跳转: 在错误跳转中，当调用的函数返回错误时，Rust 会提前终止当前函数的执行，向上一层返回错误

	`expr?`, 比如`fs::write("/tmp/1.log", b"hello")?;`

	```rust
	let output = File::create(filename)?;
	// 同上
	let output = match File::create(filename) {
		Ok(f) => f
		Err(e) => return Err(e)
	};
	```
- 异步跳转: 在 Rust 的异步跳转中, 当 async 函数执行 await 时, 程序当前上下文可能被阻塞, 执行流程会跳转到另一个异步任务执行, 直至 await 不再阻塞.

	`expr.await`, 比如`socket.write(data).await?`

Rust 编译器使用流敏感（flow-sensitive）分析控制流:
- Rust 检查贯穿函数的每条路径，确保返回值为正确类型。为了正确地完成这个检查， 它需要知道是否可能到达函数末尾。
- Rust检查局部变量永远不会在未始终化时被使用。因此必须检查贯穿函数的每一条路径，以确保不会抵达一个变量尚未经过初始化就被使用的地方。
- Rust 会对无法抵达的代码给出警告。如果贯穿函数的路径没有一条能抵达， 那么相应的代码就是无法抵达的

在强制执行这些规则时，语言必须在简单（simplicity）和机巧（cleverness）之间取得平衡。前者可以让程序员有时候更容易明白编译器在说什么，后者有助于减少误报及避免拒
绝实际上非常安全的程序。 Rust 追求简单，其流敏感分析压根不会检查循环条件，而只是假设程序中的任何条件不是 true 就是 false, 因此下述代码会报错:
```rust
fn wait_for_process(process: &mut Process) -> i32 {
	while true {
		if process.wait() {
			return process.exit_code();
		}
	}
} // 错误：并非所有控制路径都返回值
```

而loop 表达式就是作为解决这个问题的“心口如一”的方案给出的.

如果把这个规则强加给以 break 或 return 表达式结尾的块、无穷 loop、对 panic!()或 std::process::exit() 的调用，则是不明智的。这些表达式共有的特点是它们都不以
惯常的方式结束，不返回值. 因此在 Rust 中，这些表达式没有常规的类型。不正常结束的表达式通常被指定为特殊类型 !(!表示永远也不会返回, 即它是一个发散函数（divergent function）)，它们不受其他类型需要遵从的规则的约束.

### 条件表达式
表达式一定会有值, 所以if表达式的分支必须返回同一个类型的值才可以. if表达式的求值规 和块表达式一致.

代码中的条件表达式必须产生一个bool类型的值，否则就会触发编译错误. 不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值.

变量绑定支持if表达式. `if ... else if ... else`: `let x = if condition {} else {}`. 这也是Rust没有三元操作符`?:`的原因.

### 循环表达式
Rust 的循环和大部分语言都一致, 支持死循环`loop {}`、条件循环`while expr {}/while let pattern = expr{}`，以及对迭代器的循环`for x in iter {}`. 循环可以通过 break 提前终止，或者 continue 来跳到下一轮循环.

```rust
fn fib_loop(n: u8) {
    let mut a = 1;
    let mut b = 1;
    let mut i = 2u8;
    
    loop {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
        
        if i >= n {
            break;
        }
    }
}

fn fib_while(n: u8) {
    let (mut a, mut b, mut i) = (1, 1, 2);
    
    while i < n {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
    }
}

fn fib_for(n: u8) {
    let (mut a, mut b) = (1, 1);
    
    for _i in 2..n {
        let c = a + b;
        a = b;
        b = c;
        println!("next val is {}", b);
    }
}

fn main() {
    let n = 10;
    fib_loop(n);
    fib_while(n);
    fib_for(n);
}
```

> 在 C 语言中 for 循环使用三元语句控制循环，但是 Rust 中没有这种用法，需要用 while 循环来代替. 且没有 do-while 的用法(do 被规定为保留字)

> loop 循环可以通过 break 关键字类似于 return 一样使整个循环退出并给予外部一个返回值.

> 可在loop/while/for 循环前面加上`生命周期标识符`(该标识符以单引号开头), 其在内部的循环中可以使用 break/continue 语句来选择跳出到哪一层.

> 如果一个 loop 永远不返回，那么它的类型就是“发散类型”. 编译器可以判断出发散类型, 其后代码是永远不会执行的死代码.

> `loop{}`和`while true{}` 循环有何区别, 为什么 Rust 设计了loop, 难道不是完全多余的吗？实际上不是, 主要原因在于, 相比于其他的许多语言, Rust 要做更多的静态分析. 它俩在运行时是没有什么区别, 它们主要是会影响编译器内部的静态分析. `let x; loop { x = 1; break; }`可以执行, `let x; while true { x = 1; break ; }`会报错, 因为编译器认为while语句的执行跟条件表达式在运行阶段的值有关, 因此不确定x是否一定会初始化而报错. 本质是Rust编译器在对while循环做流分析(Flow Sensitive ）时, 不会检查循环
条件, 编译器会认为 while 循环条件可真可假，所以循环体里的表达式也会被忽略. 这一切都是因为 CTFE 功能的限制, while达式无法作为编译器常量来使用, 同理`if true`在只有一条分支的情况下 ，也会发生类情况.

> for 循环的主要用处是利用迭代器对包含同样类型的多个元素的容器执行遍历，如数组,链表,HashMap,HashSet等.

Rust 的 for 循环可以用于任何实现了  IntoIterator trait 的数据结构. 在执行过程中，IntoIterator 会生成一个迭代器，for 循环不断从迭代器中取值，直到迭代器返回 None 为止。因而，**for 循环实际上只是一个语法糖，编译器会将其展开使用 loop 循环对迭代器进行循环访问，直至返回 None**

通过斐波那契数列, 使用 if 和 loop / while / for 这几种循环，来实现程序的基本控制流程:
```rust

fn fib_loop(n: u8) {
    let mut a = 1;
    let mut b = 1;
    let mut i = 2u8;
    
    loop {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
        
        if i >= n {
            break;
        }
    }
}

fn fib_while(n: u8) {
    let (mut a, mut b, mut i) = (1, 1, 2);
    
    while i < n {
        let c = a + b;
        a = b;
        b = c;
        i += 1;
        
        println!("next val is {}", b);
    }
}

fn fib_for(n: u8) {
    let (mut a, mut b) = (1, 1);
    
    for _i in 2..n { // 2…n == `2<= x < n`. Range 的下标上标都是 usize 类型，不能为负数. 如果`for _i in 2..=n`那么是`2<= x <= n`
        let c = a + b;
        a = b;
        b = c;
        println!("next val is {}", b);
    }
}

fn main() {
    let n = 10;
    fib_loop(n);
    fib_while(n);
    fib_for(n);
}
```

### match 表达式与模式匹配
match 用于匹配各种情况, 有点类似其他编程语言中的switch或case.

match 也支持使用模式匹配(Pattern Matching). match表达式要求所有的分支都必须返回相同的类型,且如果是一个单独的match表达式而不是赋值给变量时，每个分支必须返回()类型.

match 分支左边就是模式，右边就是执行代码. 模式匹配同时也是一个表达式, 和 if 表达式类似，所有分支必须返回同一个类型. 但是左侧的模式可以是不同的。

使用操作符＠可以将模式中的值绑定给一个变量, 供分支右侧的代码使用，这类匹配叫绑定模式(Binding Mode). match 表达式必须穷尽每一种可能，所以一般情况下，使用通配符`_`来处理剩余的情况.

除了 match 表达式，还有 let 绑定、函数参数、for 循环等位置都用到了模式匹配.

Rust 的模式匹配被广泛应用在状态机处理、消息处理和错误处理中.

> rust不支持switch, 而是使用match. 很多语言摒弃 switch 的原因都是因为 switch 容易存在因忘记添加 break 而产生的串接运行问题，Java 和 C# 这类语言通过安全检查杜绝这种情况出现.

### if let while let 达式
Rust 还提供了 if let和while let 表达式 用来在某些场合替 match 表达式.

if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值. 在 if let 中可包含一个 else, else 块中的代码与 match 表达式中的 `_` 分支块中的代码相同.

## 错误处理
常见错误处理方式:
1. 返回代码

	在发生错误时，大量的 C 函数会返回−1 或 NULL。当进行系统调用时出现错误， C 语言会设置全局变量 errno 表示调用失败
1. 异常

	Java 和 C#之类的高级编程语言就是采用`try...catch`方式处理错误的

Rust 没有沿用上述两种处理方式, 而是借鉴 Haskell定义了Option和Result.

Option表示是否有值.

Option:
```rust
use std::collections::HashMap;

fn main() {
	let mut map = HashMap::new();
	map.insert("one", 1);
	map.insert("two", 2);

	let incremented_value = match map.get("one") {
		Some(val) => val + 1,
		None => 0
	};
	println!("{}", incremented_value);

	let incremented_value2 = if let Some(v) = map.get("one") {
		v + 1
	} else {
		0
	};
	println!("{}", incremented_value2);

	let incremented_value3 = map.get("three").unwrap() + 1; // 会panic
	println!("{}", incremented_value3);
}
```

另一种不太安全的方法是在 Option 上调用解压缩方法，即`unwrap()和expect()`(panic时, expect可传递信息)。如果返回的结果是 Some，那么调用这些方法后将提取内部的值；如果返回
的结果是 None，则会发生异常。仅当我们确定 Option 值确实包含某个值时，才推荐使用这些方法.

Result 和 Option 类似，但具有一些额外的优点，即能够存储和错误上下文有关的任意异常值，而不只是 None.

Result把错误封装在  `Result<T, E>` 类型中, 同时提供了`?`操作符来传播错误, 方便开发. `Result<T, E>` 类型是一个泛型数据结构，T 代表成功执行返回的结果类型, E 代表错误类型.

Result:
```rust
fn main() {
	let _my_result: Result<_, ()> = Ok(64);
	// or
	let _my_result = Ok::<_, ()>(64);

	// 同样，我们可以创建 Err 类型的变量
	let _my_err = Err::<(), f32>(345.3);
	let _other_err: Result<bool, String> = Err("Wait, what ?".to_string());
}
```

Option 和 Result 类型之间的转换:
- ok:  Result -> Option, 丢弃Err
- ok_or: Option -> Result

std::panic::catch_unwind 会接收一个闭包并处理其中发生的灾难性故障. 它不会阻止灾难性故障的发生，它只是停止发生灾难性故障
的线程中的堆栈展开. 且catch_unwind 不是 Rust 中处理错误的推荐方案, 因为它不能确保捕获所有灾难性故障， 例如让程序终止运行的故障.

发生灾难性故障后默认的展开行为会导致内存开销过于昂贵的极端情况, 单片机禁用该展开的方法是在Cargo.toml添加属性:
```toml
[profile.release]
panic = "abort"
```

## 宏
ref:
- [内置宏 from <<rust程序设计>> 第20章 20.2]()
- [调试宏 from <<rust程序设计>> 第20章 20.2]()
- [<<The Little Book of Rust Macros>>]
	深入宏

元编程是改变程序中指令和数据方式的一种编程技术. 它允许像处理任何其他数据那样通过指令生成新的代码. 许多语言都支持元编程，例如 Lisp 的宏、 C 的#define 构造及 Python 的元类.

rust宏和c/c++中的宏完全不是一个概念. 它是一种安全版的编译期语法扩展, 之所以使用宏, 而不是函数, 是因为宏可以完成编译期格式检查, 更加安全. 在编译期间，在检查类型和生成任何机器码之前，每个宏调用都会被扩展（expanded）.

> 函数则不具备字符串格式化的静态检查功能，如果出现了不匹配的情况, 只能是运行期报错.

> `format!, write!`最终还是调用`std::io`模块提供的一些函数来完成的. 如果用户需要更精细地控制标准输出操作, 也可以直接调用标准库来完成.

> derive可以根据名称实现一个或多个特征, 是一个过程宏，它只是简单地为实现它的类型的 impl 块生成代码, 并实现特征方法或任何
关联函数.

一般的经验法则是，宏可以在函数无法提供所需解决方案的情况下使用，其中的代码具有相当的重复性，或者在需要检查类型结构体并在编译期生成代码的情况下使用宏.

同时应该谨慎地使用宏，它们会使代码难以维护和理解. 同时大量使用宏会导致性能损失, 因为会产生大量重复的代码，这会影响 CPU 指令缓存.

rust支持的宏:
1. 声明式宏

	这些是宏的最简单形式。它们是使用 macro_rules!宏创建的，其本身就是一个宏。它们提供与调用函数类似的功能，但是很容易通过名称末尾的!予以区
分。它们是在项目中快速编写小型宏的首选方法. 此时不需要考虑如何生成代码，因为 DSL 会替代劳.
1. 过程宏

	过程宏是宏的一种更高级形式，可以完全控制代码的操作和生成。这些宏没有任何 DSL 支持，并在某种意义上是程序性的，你必须为给定的标记树输入编
写如何生成或转换代码的指令。其缺点是实现起来很复杂，需要对编译器的内部机制，以及程序如何在编译器的内存中表示有一些了解。 macro_rules!宏可以在项目
的任何位置定义， 而过程宏需要通过将 Cargo.toml 文件中的属性设置为 proc−macro= true 来生成独立的软件包

macro_rules! 是 Rust 中定义宏的主要方式. 并非所有的宏都是以这种方式定义的. 比如 file!、line! 和 macro_rules!，本身是内置在编译器中的。

使用 macro_rules! 定义的宏完全基于模式匹配实现逻辑。宏的主体就是一系列规则的`( 模式1 ) => ( 模板1 );`.

## 代码管理
rust支持使用mod 来组织代码.

使用方法: 在项目的入口文件`lib.rs/main.rs`里, 用 mod 来声明要加载的其它代码文件. 如果模块内容比较多, 可以放在一个目录下, 再在该目录下放一个 mod.rs 引入该模块的其它文件, mod.rs 和 Python 的 `__init__.py` 有异曲同工之妙.

在 Rust 里, 一个项目也被称为一个 crate. crate 可以是可执行项目，也可以是一个库.

在一个 crate 下，除了项目的源代码，单元测试和集成测试的代码也会放在 crate 里. Rust 的单元测试一般放在和被测代码相同的文件中，使用条件编译  #[cfg(test)] 来确保测试代码只在测试环境下编译.

集成测试一般放在 tests 目录下，和 src 平行. 和单元测试不同，**集成测试只能测试 crate 下的公开接口，编译时编译成单独的可执行文件**. 在 crate 下，如果要运行测试用例，可以使用`cargo test`.

当代码规模继续增长，把所有代码放在一个 crate 里就不是一个好主意了，因为任何代码的修改都会导致这个 crate 重新编译，这样效率不高. 此时可以使用 workspace, 一个 workspace 可以包含一到多个 crates，当代码发生改变时，只有涉及的 crates 才需要重新编译. 当要构建一个 workspace  时，需要先在某个目录下生成一个 Cargo.toml，包含 workspace 里所有的 crates，然后再通过  cargo new 生成对应的 crates.

workspace Cargo.toml例子:
```toml
[workspace]

members = [
	"core",
	...
	"server",
]
```

## trait
ref:
- [Rust 的标准库 Trait 之旅](https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/)

所有的 trait 中都有一个隐藏的类型 Self，代表当前这个实现了此 trait 的具体类型. trait 中定义的函数，也可以称作关联函数（ associated function). 函数的第一个参数如果是 Self 相关的类型，且命名为 self（小写），这个参数可以被称为“receiver ”（接收者）. 具有 receiver 参数的函数，称为“方法”（method), 可以通过变量实例使用小数点来调用. 没有 receiver 参数的函数，称为“静态函数”（static function ），可以通过类型加`::`的方式来调用.

```rust
trait T { 
	fn methodl(self: Self); 
	fn method2(self: &Self); 
	fn method3 (self: &mut Self); 
}
// 上下两种写法是完全一样的
trait T { 
	fn methodl (self) ; 
	fn method2(&self); 
	fn method3(&mut self); 
}
```

直接对它 impl 来增加成员方法, 无须 trait 名字, 比如：
```rust
impl Circle { 
	fn get radius(&self) -> f64 { self.radius } 
}
```
可以把这段代码看作是为 Circle 类型 impl 了一个匿名的 trait. 用这种方式定义的方法叫作这个类型的`内在方法`（ inherent methods).

> 结构体方法的第一个参数必须是 &self，不需声明类型，因为 self 不是一种风格而是关键字. 而在调用结构体方法的时候不需要填写 self, 这是出于对使用方便性的考虑.

> 结构体关联函数: 在 impl 块中却没有 &self 参数, 这种函数不依赖实例，但是使用它需要声明是在哪个 impl 块中的, 比如`String::from`.

trait 中可以包含方法的默认实现, 如果需要针对特殊类型作特殊处理，也可以选择重新实现来`override`默认的实现方式.

impl 的对象甚至可以是 trait, 如下:
```rust
trait Shape { 
	fn area(&self) -> f64;
}

trait Round { 
	fn get_radius(&self) -> f64;
}

struct Circle { 
	radius: f64, 
}

impl Round for Circle {
	fn get_radius(&self) -> f64 { self.radius } 
}

// impl Trait for Trait 
impl Shape for dyn Round {
	fn area(&self) -> f64 { 
		std::f64::consts::PI * self.get_radius() * self.get_radius() 
	}
}

fn main() { 
	let  c =Circle { radius : 2f64}; 
	// build err
	// c. area ( ) ; 

	let b = Box::new(Circle {radius : 4f64}) as Box<dyn Round>;
	b.area();
}
```

上面的`impl Shape for Round`和`impl<T: Round> Shape for T`是不一样的, 在前一种写法中, self 是`&Round`类型, 它是一个 trait object ，是胖指针. 在后一种写法中, self 是&T, T是具体类型 前一种写法是为 trait object增加一个成员方法; 而后一种写法是为所有的满足`T: Round`的具体类型增加一个成员方法. 所以上面的示例中，我们只能构造一个 trait object 之后才能调用 area()成员方法.

指向一个特型类型（如 writer）的引用，称为特型目标（trait object）. 特型目标是一个胖指针，包含指向值的指针和指向表示该值类型的表的指针, 类似go的`interface{}`. C++ 同样也有这种运行时类型信息，其被称为虚拟表（virtual table）或 vtable.

与 Java 和 C# 的接口类似，特型目标不支持静态方法. 此时想要使用特型目标就必须修改特型, 给每个静态方法都添加`where Self: Sized`绑定, 让Rust知道该特型目标不支持该静态方法, 但可使用其他方法.

trait 对象给了我们运行时的多态性. Trait 对象是不确定大小的，所以它们必须总是在指针后面.

并非所有的 trait 都可以转换为 trait 对象。如果一个 trait 满足这些要求，它就是对象安全的:
1. trait 不需要 Self: Sized。
1. 所有 trait 的方法都是对象安全的

	如果 trait 方法满足这些要求，它就是对象安全的:
	- 方法需要 Self: Sized 或
	- 该方法只在接收器位置使用 Self 类型

**Rust 2018 edition开始, trait object 的语法会被要求加上 dyn 关键字即`impl Shape for dyn Round`**, 2015可用`impl Shape for Round`.

dyn(动多态, 类似golang的接口):
```rust
use std::fmt::Debug;

#[derive(Debug)]
struct Square(f32);
#[derive(Debug)]
struct Rectangle(f32, f32);

trait Area: Debug {
	fn get_area(&self) -> f32;
}

impl Area for Square {
	fn get_area(&self) -> f32 {
		self.0 * self.0
	}
}

impl Area for Rectangle {
	fn get_area(&self) -> f32 {
		self.0 * self.1
	}
}
fn main() {
	let shapes: Vec<&dyn Area> = vec![&Square(3f32), &Rectangle(4f32,2f32)]; //  `&dyn Area` 表示的，意味着它是指向 Area 某些实现的指针
	for s in shapes {
		println!("{:?}", s);
	}
}
```

```rust
use std::io::Write;
fn main() {
    let mut buf: Vec<u8> = vec![];
    let writer: &dyn Write = &mut buf;
}
```

trait依赖:
```rust
trait Vehicle {
	fn get_price(&self) -> u64;
}

trait Car: Vehicle {
	fn model(&self) -> String;
}
```

Car 特征指定了约束，任何实现特征的类型必须实现 Vehicle 特征.


trait形式:
1.  marker trait

	在 std::marker 模块中定义的特征被称为标记特征（ marker trait）。这种特征不包含任何方法，声明时只是提供特征名称和空的函数体.

	标准库中的示例包括 Copy、 Send、 Sync也是标记特征，因为它们用于简单地将类型标记为属于特定的组群，以获得一定程度的编译期保障.

	自动 trait 是指如果一个类型的所有成员都实现了这个 trait，那么这个 trait 就会被自动实现. 所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait. 自动trait有Send、 Sync.
1. 简单trait

	```rust
	trait Foo {
		fn foo();
	}
	```

	标准库中的一个示例是 Default 特征，它主要是针对可以使用默认值初始化的类型实现的.
1. 泛型trait

	```rust
	pub trait From<T> { // 将 T 转换为 Self
		fn from(T) -> Self;
	}

	trait Into<T> { // 将 Self 转换为 T
	    fn into(self) -> T;
	}
	```

	TryFrom 和 TryInto 是 From 和 Into 的不可靠版本.

	From和 Into 则是取得它们参数的所有权，转换类型，再把结果的所有权返回给调用者.
1. 关联类型trait

	当需要在函数签名中使用 Self 以外的其他类型, 但又希望类型由实现者选择, 而不是在 trait 声明中硬编码

	```rust
	trait Foo {
		type Out;
		fn get_value(self) -> Self::Out;
	}

	// ----
	trait Trait {
	    type AssociatedType;
	    fn func(arg: Self::AssociatedType);
	}

	struct SomeType;

	impl Trait for SomeType {
	    type AssociatedType = i8; // chooses i8
	    fn func(arg: Self::AssociatedType) {}
	}

	fn main() {
	    SomeType::func(-1_i8); // can only call func with i8 on SomeType
	}
	```

	它在trait中声明了相关类型.
1. trait依赖

	`trait Subtrait: Supertrait {}`: 所有实现 Subtrait 的类型都是所有实现 Supertrait 的类型的子集

	```rust
	trait Vehicle {
		fn get_price(&self) -> u64;
	}

	trait Car: Vehicle { // 实现者必须实现Car和Vehicle.
		fn model(&self) -> String;
	}
	```

	没有规定一个类型必须同时实现一个 subtrait 和一个 supertrait. 它可以在另一个类型的实现中使用其中一个类型的方法:
	```rust
		trait Supertrait {
	    fn super_method(&mut self);
	}

	trait Subtrait: Supertrait {
	    fn sub_method(&mut self);
	}

	struct CallSuperFromSub;

	impl Supertrait for CallSuperFromSub {
	    fn super_method(&mut self) {
	        println!("in super");
	    }
	}

	impl Subtrait for CallSuperFromSub {
	    fn sub_method(&mut self) {
	        println!("in sub");
	        self.super_method();
	    }
	}

	struct CallSubFromSuper;

	impl Supertrait for CallSubFromSuper {
	    fn super_method(&mut self) {
	        println!("in super");
	        self.sub_method();
	    }
	}

	impl Subtrait for CallSubFromSuper {
	    fn sub_method(&mut self) {
	        println!("in sub");
	    }
	}

	struct CallEachOther(bool);

	impl Supertrait for CallEachOther {
	    fn super_method(&mut self) {
	        println!("in super");
	        if self.0 {
	            self.0 = false;
	            self.sub_method();
	        }
	    }
	}

	impl Subtrait for CallEachOther {
	    fn sub_method(&mut self) {
	        println!("in sub");
	        if self.0 {
	            self.0 = false;
	            self.super_method();
	        }
	    }
	}

	fn main() {
	    CallSuperFromSub.super_method(); // prints "in super"
	    CallSuperFromSub.sub_method(); // prints "in sub", "in super"
	    
	    CallSubFromSuper.super_method(); // prints "in super", "in sub"
	    CallSubFromSuper.sub_method(); // prints "in sub"
	    
	    CallEachOther(true).super_method(); // prints "in super", "in sub"
	    CallEachOther(true).sub_method(); // prints "in sub", "in super"
	}
	```

### trait泛型参数
```rust
// trait declaration generalized with lifetime & type parameters
trait Trait<'a, T> {
    // signature uses generic type
    fn func1(arg: T);

    // signature uses lifetime
    fn func2(arg: &'a i32);

    // signature uses generic type & lifetime
    fn func3(arg: &'a T);
}

struct SomeType;

impl<'a> Trait<'a, i8> for SomeType {
    fn func1(arg: i8) {}
    fn func2(arg: &'a i32) {}
    fn func3(arg: &'a i8) {}
}

fn main() {
    SomeType::func1(-1_i8); // can only call func with i8 on SomeType
}
```

```rust
// make T = Self by default
trait Trait<T = Self> {
    fn func(t: T) {}
}

// any type can be used as the default
trait Trait2<T = i32> {
    fn func2(t: T) {}
}

struct SomeType;

// omitting the generic type will
// cause the impl to use the default
// value, which is Self here
impl Trait for SomeType {
    fn func(t: SomeType) {}
}

// default value here is i32
impl Trait2 for SomeType {
    fn func2(t: i32) {}
}

// the default is overridable as we'd expect
impl Trait<String> for SomeType {
    fn func(t: String) {}
}

// overridable here too
impl Trait2<String> for SomeType {
    fn func2(t: String) {}
}
```

### 泛型类型 vs 关联类型
泛型类型和关联类型都将决定权交给了实现者, 让他们决定在 trait 的函数和方法中应该使用哪种具体类型. 一般的经验法则是
1. 当每个类型只能有一个 trait 的实现时, 使用关联类型
1. 当每个类型可以有许多可能的 trait 的实现时, 使用泛型类型

关联类型:
```rust
trait Add {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -> Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Rhs = Point;
    type Output = Point;
    fn add(self, rhs: Point) -> Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

// 支持 Point + Point, 而不支持Point + i32
fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
```

泛型类型:
```rust
trait Add<Rhs> {
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add<Point> for Point {
    type Output = Self;
    fn add(self, rhs: Point) -> Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add<i32> for Point {
    type Output = Self;
    fn add(self, rhs: i32) -> Self::Output {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

// 将 Rhs 从关联类型重构为泛型类型 支持 Point + Point, 也支持Point + i32
fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3 = p1.add(p2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
    
    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert_eq!(p3.x, 3);
    assert_eq!(p3.y, 3);
}
```

允许Point+Point=Line:
```rust
trait Add<Rhs, Output> {
    fn add(self, rhs: Rhs) -> Output;
}

struct Point {
    x: i32,
    y: i32,
}

impl Add<Point, Point> for Point {
    fn add(self, rhs: Point) -> Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

impl Add<i32, Point> for Point {
    fn add(self, rhs: i32) -> Point {
        Point {
            x: self.x + rhs,
            y: self.y + rhs,
        }
    }
}

struct Line {
    start: Point,
    end: Point,
}

impl Add<Point, Line> for Point {
    fn add(self, rhs: Point) -> Line {
        Line {
            start: self,
            end: rhs,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let p3: Point = p1.add(p2);
    assert!(p3.x == 3 && p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let int2 = 2;
    let p3 = p1.add(int2);
    assert!(p3.x == 3 && p3.y == 3);

    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    let l: Line = p1.add(p2);
    assert!(l.start.x == 1 && l.start.y == 1 && l.end.x == 2 && l.end.y == 2)
}
```

### 作用域
```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn main() -> Result<(), io::Error> {
    let mut file = File::open("Cargo.toml")?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer)?; // read_to_string(buf: &mut String) 由 std::io::Read trait 声明，并由 std::fs::File 结构体实现，但为了调用它，std::io::Read 必须在作用域内
    Ok(())
}
```

标准库中的 prelude 是标准库中的一个模块, 即 std::prelude::v1, 它在每个其他模块的顶部被自动导入即`use std::prelude::v1::*`. 因此, 相关 trait 总是在作用域内，永远不需要显式导入它们.


### 默认实现
```rust
trait Trait {
    fn method(&self) {
        println!("default impl");
    }
}

struct SomeType;
struct OtherType;

// use default impl for Trait::method
impl Trait for SomeType {}

impl Trait for OtherType {
    // use our own impl for Trait::method
    fn method(&self) {
        println!("OtherType impl");
    }
}

fn main() {
    SomeType.method(); // prints "default impl"
    OtherType.method(); // prints "OtherType impl"
}
```


```rust
use std::fmt::Debug;
use std::convert::TryInto;
use std::ops::Rem;

trait Even {
    fn is_even(self) -> bool;
}

impl<T> Even for T
where
    T: Rem<Output = T> + PartialEq<T> + Sized,
    u8: TryInto<T>,
    <u8 as TryInto<T>>::Error: Debug,
{
    fn is_even(self) -> bool {
        self % 2.try_into().unwrap() == 0.try_into().unwrap()
    }
}

impl Even for u8 { // 通用的全面实现和特定实现冲突. 因为rust保证了Trait 一致性即任何给定类型的 trait 最多存在一个实现的属性
    fn is_even(self) -> bool {
        self % 2_u8 == 0_u8
    }
}

#[test]
fn test_is_even() {
    assert!(2_i8.is_even());
    assert!(4_u8.is_even());
    assert!(6_i16.is_even());
    // etc
}
```

### Any
这个 trait 很少需要使用，因为在大多数情况下，参数化多态性要优于临时多态性，后者也可以用枚举来模拟，因为枚举的类型更安全，需要的迂回更少.

```rust
use std::any::Any;

#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn inc(&mut self) {
        self.x += 1;
        self.y += 1;
    }
}

fn map_any(mut any: Box<dyn Any>) -> Box<dyn Any> {
    if let Some(num) = any.downcast_mut::<i32>() {
        *num += 1;
    } else if let Some(string) = any.downcast_mut::<String>() {
        *string += "!";
    } else if let Some(point) = any.downcast_mut::<Point>() {
        point.inc();
    }
    any
}

fn main() {
    let mut vec: Vec<Box<dyn Any>> = vec![
        Box::new(0),
        Box::new(String::from("a")),
        Box::new(Point::default()),
    ];
    // vec = [0, "a", Point { x: 0, y: 0 }]
    vec = vec.into_iter().map(map_any).collect();
    // vec = [1, "a!", Point { x: 1, y: 1 }]
}
```

### Operator Traits
ref:
- rust表达式小结 from `<<Rust程序设计>>#6.15 优先级与关联性`

Rust 中的所有运算符都与 trait 相关, 如果想为自定义类型实现运算符，就必须实现相关的 trait.

<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>

所有的 PartialEq<Rhs> 实现必须确保相等是对称的和传递的。这意味着对于所有的 a, b, 和 c:
- 对称性: a == b => b == a
- 传递性: a == b && b == c => a == c

根据定义`trait Eq: PartialEq<Self> {}`, Eq 是一个标记 trait，是 PartialEq<Self> 的子 trait. 它还保证了自反性即 对所有 a都有a == a. 在这个意义上，Eq 完善了 PartialEq，因为它代表了一个更严格的相等性版本。如果一个类型的所有成员都是Eq 的，那么 Eq 实现就可以为该类型派生

几乎所有其他的 PartialEq 类型都是 Eq, 但浮点类型是 PartialEq 的，但不是 Eq 的，因为 NaN != NaN.

所有的 PartialOrd 实现必须确保比较是不对称的和传递的。这意味着对于所有的 a, b, 和 c:
- 不对称性 : a < b => !(a > b)
- 传递性: a < b && b < c => a < c

PartialOrd 是 PartialEq 的一个子 trait，它们的实现必须总是相互一致.

Ord在 PartialOrd 所要求的不对称性和传递性的基础上，还保证不对称性是完全的，即对于任何给定的 a 和 b，a == b 或 a > b 中只有一个是真的. 在这个意义上，Ord 完善了 Eq 和 PartialOrd，因为它代表了一个更严格的比较版本。如果一个类型实现了 Ord，就可以用这个实现来实现 PartialOrd、PartialEq 和 Eq.

PartialOrd 类型都是 Ord, 但浮点数实现了 PartialOrd，但不是 Ord，因为 NaN < 0 == false 和 NaN >= 0 == false 同时为真.

## 面向对象
### 封装
封装就是对外显示的策略，在 Rust 中可以通过模块的机制来实现最外层的封装，并且每一个 Rust 文件都可以看作一个模块，模块内的元素可以通过 pub 关键字对外明示.

```rust
// --- second.rs
pub struct ClassName {
    field: i32,
}

impl ClassName {
    pub fn new(value: i32) -> ClassName {
        ClassName {
            field: value
        }
    }

    pub fn public_method(&self) {
        println!("from public method");
        self.private_method();
    }

    fn private_method(&self) {
        println!("from private method");
    }
}

// --- main.rs
mod second;
use second::ClassName;

fn main() {
    let object = ClassName::new(1024);
    object.public_method();
}
```

### 继承
继承是多态（Polymorphism）思想的实现, 多态指的是编程语言可以处理多种类型数据的代码. 在 Rust 中，通过特性（trait）实现多态.

总结地说，Rust 没有提供跟继承有关的语法糖，也没有官方的继承手段（完全等同于 Java 中的类的继承），但灵活的语法依然可以实现相关的功能.

## 闭包
闭包是可以保存进变量或作为参数传递给其他函数的匿名函数, 闭包相当于 Rust 中的 Lambda 表达式:
```rust
|参数1, 参数2, ...| -> 返回值类型 {
    // 函数体
}
```

闭包主要用作高阶函数的参数。 高阶函数是一个以另一个函数或闭包作为参数的函数.

在大多数语言中，闭包是分配在堆上，动态分派，然后由垃圾回收程序负责回收的. Rust的闭包不会被分配到堆上，除非把它们装到 Box、Vec 或其他容器里, Rust 编译器知道所调用闭包的类型会将该闭包的代码行内化.

## 并发
move:
```rust
use std::thread;

fn main() {
    let s = "hello";
   
    let handle = thread::spawn(move || {
        println!("{}", s);
    });

    handle.join().unwrap();
}
```

channel:
```rust
// 子线程获得了主线程的发送者 tx，并调用了它的 send 方法发送了一个字符串，然后主线程就通过对应的接收者 rx 接收到了
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

## 并发
常见并发模型是并行分叉-合并, 分叉（fork）就是启动一个新线程，而合并（join）就是等待线程完成.

```rust
use std::thread;
fn main() {
    let child = thread::spawn(|| {
        println!("Thread!");
        String::from("Much concurrent, such wow!")
    });
    print!("Hello ");
    let value = child.join().expect("Failed joining child thread");
    println!("{}", value);
}
```

对 spawn 的调用会创建线程并立即返回, 线程开始并发执行而不会阻塞后面的指令. 子线程是以分离状态创建的.

> spawn创建的线程是一个真实的操作系统线程, 有自己的栈, 与 C++、C# 和 Java 中的线程一样.

spawn 函数会返回一个 JoinHandle 类型的值, 可用于连接线程——换句话说就是等待它的终止.

调用 join 会阻塞当前线程，并在执行 join 调用之后的任何代码行之前等待子线程完成, 它返回一个 Result 值. 但如果一个线程正在连接自身或者遇到死锁，那么连接线程可能会失败, 在这种情况下，它会返回一个 Err 变量, 且里面返回的值是 Any 类型.

自定义线程:
```rust
use std::thread::Builder;
fn main() {
    let my_thread = Builder::new()
        .name("Worker Thread".to_string())
        .stack_size(1024 * 4);
    let handle = my_thread.spawn(|| {
        panic!("Oops!");
    });
    let child_status = handle.unwrap().join();
    println!("Child status: {:#?}", child_status);
}

/* output:
Child status: Err(
    Any { .. },
)
*/
```

上例使用了 Builder::new 方法, 调用 name 和 stack_size 方法为线程分配名称和设置堆栈大小.

标准库的 spawn 函数是一个重要的原语，但并不是专门为并行分叉–合并设计的. 当前社区已经有更好的分叉–合并 API 构建在其基础之上, 比如Rayon, 它还支持工作窃取（work-stealing）的技术动态地在线程间平衡负载.

### 并发模型
Rust 并不会倾向于使用任何固有的并发模型, 允许开发者使用自己的模型, 并根据需要使用第三方软件包来解决自己的问题.

Rust 内置了两种流行的并发模型：通过同步共享数据和通过消息传递共享数据.

#### 原子类型
std::sync::atomic 模块包含无锁并发编程要使用的原子类型. 这些类型基本上与标准 C++ 原子类型相同:
- AtomicIsize 和 AtomicUsize 是共享的整数类型，对应单线程的 isize 和 usize 类型
- AtomicBool 是一个共享的 bool 值
- `AtomicPtr<T>` 是不安全指针类型 *mut T 的共享值

#### 同步共享数据
与 C++ 不同，Rust 中受保护的数据保存在 Mutex 内部. rust有互斥锁`Mutex<T>`和读写锁`RwLock<T>`.

```rust
use std::sync::Arc;
use std::thread;
fn main() {
    let nums = Arc::new(vec![0, 1, 2, 3, 4]);
    let mut childs = vec![];
    for n in 0..5 {
        let ns = Arc::clone(&nums); // ns是一个包含所有权的 Arc<Vec<i32>>值, 该值引用相同的 Vec
        let c = thread::spawn(move || {
            println!("{}", ns[n]);
        });
        childs.push(c);
    }

    for c in childs {
        c.join().unwrap();
    }
}
/* output:
4
2
1
0
3
*/
```

通过 Arc 和 Mutex 实现共享可变性:
```rust
use std::sync::{Arc, Mutex};
use std::thread;
fn main() {
    let vec = Arc::new(Mutex::new(vec![]));
    let mut childs = vec![];
    for i in 0..5 {
        let v = vec.clone();
        let t = thread::spawn(move || {
            let mut v = v.lock().unwrap();
            v.push(i);
        });
        childs.push(t);
    }
    for c in childs {
        c.join().unwrap();
    }
    println!("{:?}", vec);
}
/* output:
Mutex { data: [0, 1, 2, 3, 4], poisoned: false, .. }
*/
```
#### 通过消息传递进行通信
std::sync::mpsc 模块提供了一个无锁定的**多生产者、单订阅者（消费者）队列**, 作为希望彼此通信的线程的共享消息队列.

mpsc 模块标准库包含两种通道:
1. channel：一个异步的无限缓冲通道

	使用默认的异步通道时, send 方法永远不会阻塞, 这是因为通道缓冲区是无限的(实际受限于内存).
1. sync_channel：一个同步的有界缓冲通道

	同步通道有一个有界缓冲区, 当它被填满时, send 方法会被阻塞, 直到通道中出现更多空间.

对于这两种通道类型，如果通道是空的，那么 recv 调用会返回 Err 值.

channel:
```rust
use std::sync::mpsc::channel;
use std::thread;
fn main() {
    let (tx, rx) = channel(); // tx 是包含 Sender<T>类型的发送端, rx 是包含 Receiver<T>类型的接收端
    let join_handle = thread::spawn(move || {
        while let Ok(n) = rx.recv() {
            println!("Received {}", n);
        }
    });
    for i in 0..10 {
        tx.send(i).unwrap();
    }
    join_handle.join().unwrap();
}
/* output:
Received 0
Received 1
Received 2
Received 3
Received 4
Received 5
Received 6
Received 7
Received 8
Received 9
*/
```

sync_channel:
```rust
use std::sync::mpsc;
use std::thread;
fn main() {
    let (tx, rx) = mpsc::sync_channel(1);
    let tx_clone = tx.clone();
    let _ = tx.send(0);
    thread::spawn(move || {
        let _ = tx.send(1);
    });
    thread::spawn(move || {
        let _ = tx_clone.send(2);
    });
    println!("Received {} via the channel", rx.recv().unwrap());
    println!("Received {} via the channel", rx.recv().unwrap());
    println!("Received {} via the channel", rx.recv().unwrap());
    println!("Received {:?} via the channel", rx.recv());
}
/* output:
Received 0 via the channel
Received 2 via the channel
Received 1 via the channel
Received Err(RecvError) via the channel
*/
```

#### 线程安全
线程安全指没有数据争用和其他未定义行为.

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T + Send + 'static,
    T: Send + 'static,
```

Rust 代码的彻底安全取决于两个内置特型`std::marker::Send`和`std::marker::Sync`:
- 实现 Send 的类型可以安全地把值传到另一个线程，即它们可以在线程间转移
- 实现 Sync 的类型可以安全地把不可修改引用传到另一个线程，即它们可以在线程间

Send类型包含Sync类型.

spawn 是一个包含 F 和 T 的泛型函数, 并且会接收一个参数 f, 返回的泛型是JoinHandle<T>. 随后的 where 子句指定了多个trait限制:
- F:FnOnce() -> T + Send + 'static：这表示 F 实现了一个只能被调用一次的闭包. 换句话说， f 是一个闭包，通过值获取所有内容并移动从环境中引用的项. 同时表示闭包必须是发送型（ Send），并且必须具有'static 的生命周期，同时执行环境中闭包内引用的任何类型必须是发送型，必须在程序的整个生命
周期内存活。
- T:Send + 'static：来自闭包的返回类型 T 必须实现 Send+'static 特征

Send 是一种标记性特征。它只用于类型级标记，意味着可以安全地跨线程发送值即在线程之间发送是安全的；并且大多数类型都是发送型。未实现 Send 特征的类型是指针、引用等。此外， Send 是自动
型特征或自动派生的特征。复合型数据类型，例如结构体，如果其中的所有字段都是 Send型，那么该结构体实现了 Send 特征.

在 Rust 中，编译器可保证在线程中安全使用和引用类型. 这些保证被实现为特征，即 Send 和 Sync 特征.

Send 类型可以安全地发送到多个线程，这表明该类型是一种移动类型. 非 Send 类型的是指针类型，例如&T，除非 T 是 Sync 类型.

如果某些类型是 Sync 类型，那么指向它的引用即相关的&T 是 Send 类型, 这意味着可以将对它的引用传递给多线程即在线程之间共享它的引用是安全的.

少数没有实现 Send 和 Sync 的类型主要用于在非线程安全的条件下提供可修改能力. 例如引用计数智能指针类型`std::rc::Rc<T>`. 当两个线程都会执行`(Rc<T>).clone()`增加共享引用计数, 但引用计数可能是不准确的, 因为出现了数据争用, 从而导致未定义行为.

几乎所有类型都是 Send 和 Sync 的。唯一值得注意的 Send 异常是 Rc，唯一值得注意的 Sync 异常是 Rc、Cell 和 RefCell。如果我们需要一个 Rc 的 Send 版本，我们可以使用 Arc。如果我们需要 Cell 或 RefCell 的 Sync 版本，我们可以 Mutex 或 RwLock。虽然如果我们使用 Mutex 或 RwLock 只是包裹一个原语类型，通常最好使用标准库提供的原子原语类型，如 AtomicBool、AtomicI32、AtomicUsize 等.

## unsafe
unsafe不过是把 Rust 编译器在编译器做的严格检查退步成为 C++ 的样子, 由开发者自己为其所撰写的代码的正确性做担保.

>  unsafe 块是 Rust 提供的可选机制，专为安全责任自负的程序员使用高级语言特性提供

rust只允许少数几个地方用 unsafe 关键字进行标记:
- 函数和方法
- 不安全的代码块表达式，例如 unsafe{}
- 特征

	动机:
	1. 标记无法发送到线程或在线程之间共享的类型.
	1. 封装一系列类型可能具有未定义行为的操作
- 实现代码块

unsafe 块支持:
1. 可以调用 unsafe 函数
1. 可以解引用原始指针

	原始指针本质上等价于 C 或 C++ 指针，有两种原始指针:
	- `*mut T` 是一个指向 T 且允许修改其引用目标的原始指针
	- `*const T` 是一个指向 T 但只允许读取其引用目标的原始指针

	Rust 虽然会在各种情况下隐式解引用安全指针类型，但原始指针必须显式解引用.
1. 可以访问可修改 static 变量
1. 可以访问通过 Rust 的外来函数接口声明的函数和变量. 即使是不可修改的，这些函数和变量也会被认为是不安全的. 因为它们对其他语言写的代码是可见的，而那些代码不一定遵守 Rust 的安全规则.

在Rust中调用C和C++的类型对照:
|C类型| 对应的std::os::raw类型|
|short| c_short|
|int |c_int|
|long |c_long|
|long long| c_longlong|
|unsigned short |c_ushort|
|unsigned、unsigned int| c_uint|
|unsigned long |c_ulong|
|unsigned long long |c_ulonglong|
|char |c_char|
|signed char |c_schar|
|unsigned char| c_uchar|
|float |c_float|
|double| c_double|
|`void *`、`const void *`| `*mut c_void`、`*const c_void`|