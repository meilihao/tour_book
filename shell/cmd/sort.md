# sort

## 描述

将文件内容进行排序，并将排序结果输出.sort命令既可以从特定的文件，也可以从stdin中获取输入

## 格式
    sort [OPTION]... [FILE]...

## 选项

- -b : 忽略每行开头存在的空格字符
- -c : 检查文件是否已经按照顺序排序
- -d : 按字典序进行排序(只考虑空白和字母)
- -k : 按照特定列进行排序
- -n : 按数值进行排序
- -o : 将输出保存到指定文件
- -r : 逆序排序
- -R : 随机排序
- -k [ FStart [ .CStart ] ] [ Modifier ] [, [ FEnd [ .CEnd ] ][ Modifier ] ] : 按指定区间排序
- -t<分隔符> : 指定排序时所用的分隔符, 而不使用空格
- -u : 去除重复行
- --debug : 输出调试信息

`[ FStart [ .CStart ] ] [ Modifier ] [, [ FEnd [ .CEnd ] ][ Modifier ] ]`解析:
这个语法格式可以被其中的`,`分为两大部分，Start部分和End部分, 如果不设定End部分，那么就认为End被设定为行尾.
Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n(即`-n`)和r(即`-r`)的选项部分.
CStart也是可以省略的，省略的话就表示从本域的开头部分开始
FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算`排序首字符`.
同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符. 或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”

modifier: b、d、f、i、n 或 r:
- n/r/b/d : 即sort选项`-nrbd`
- f : 对本域进行排序时忽略大小写
- i : 忽略"不可打印字符"，只针对可打印字符进行排序（有些ASCII就是不可打印字符，比如\a是报警，\b是退格，\n是换行，\r是回车等等）

举例:
- `-k 2` : 对第二个域进行排序
- `-k 1.2` : 对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序
- `-k 1.2,1.2` : 只对第一个域的第二个字母进行排序
- `-k 3,3` : 这是最准确的表述，表示只对本域进行排序，因为如果你省略了后面的3即`-k 3,`，就变成了`对第3个域开始到最后一个域位置的内容进行排序`

## 例
```sh
$ ps -aux | sort -rnk 3 | head -20 # cpu前20
$ ps -aux | sort -rnk 4 | head -20 # 内存前20
$ sort -nk 2 -t: sort.txt # 根据第二列按照数字排序(字母排在最前面)
$ sort -n -t. -k3,3 -k4.1,4.3 arp.txt // 先按IP地址的第3列排序, 再按照ip地址的第4列排序
$ sort -n -t ' ' -k 3r -k 2 facebook.txt // 让facebook.txt(`公司名称 公司人数 员工平均工资`)按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序
$ sort -n -k 2 1.txt // = sort -k 2,2n 1.txt
```
